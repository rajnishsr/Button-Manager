<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Hca_DevBlocks_Common</name>
    </assembly>
    <members>
        <member name="T:Hca.Common.BaseException.ConcurrentObjectUpdateException">
            <summary>
            This exception represents the condition that occurs when a target object is updated from a source object
            but the target object has been updated by another source object without the current source knowing about
            that update. 
            </summary>
            <threadsafety static="true" instance="false"/> 
            <seealso cref="T:Hca.Common.BaseException.HcaApplicationException"/>
            <remarks>
            <para>
            This condition is also referred to as a "dirty update" since the source of the update has dirty
            data for which they are making the decision to do the update. Generally, this condition is not well tolerated
            by clients since wrong decisions can be made and inconsistency can be introduced without the client knowing
            that the condition existed.</para>
            <para>
            Clients can in most cases recover from this exception by retrieving the current version of data and reapplying
            the update.</para>
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaApplicationException">
            <summary>
            This class provides the base for all user defined exceptions within the HCA framework. It adds to the set of 
            detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. 
            An <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> by default is considered to be recoverable. 
            As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is impossible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.IHcaException">
            <summary>
            This interface provides the base for all exceptions developed within 
            HCA. It adds to the set of detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            In particular the following features can be leverage to help determine
            where and why a problem is occurring in an application.
            <list type="bullet">
            <item>
            <description>
            Unique Id that can be used to correlate exceptions across layers or tiers.
            </description>
            </item>
            <item>
            <description>
            Host Name where exception occurred.
            </description>
            </item>
            <item>
            <description>
            Application Domain where exception occurred.
            </description>
            </item>
            <item>
            <description>
            User as known by the current thread of execution.
            </description>
            </item>
            <item>
            <description>
            User as known by the windows subsystem (if applicable).
            </description>
            </item>
            <item>
            <description>
            What level to log this exception.
            </description>
            </item>
            <item>
            <description>
            Whether a stack trace should be included when logging this exception.
            </description>
            </item>
            <item>
            <description>
            Whether this exception has been logged.
            </description>
            </item>
            <item>
            <description>
            Ability to specify a message key to pull in the text to display when 
            rendering the detail of this exception.
            </description>
            </item>
            <item>
            <description>
            The time the exception occurred
            </description>
            </item>
            </list>
            
            It is recommended that new exceptions only be created if they represent a 
            condition that would be acted on differently if caught. Otherwise, this 
            exception can be used directly with a message key supplied at 
            instantiation so that the display text can vary for the given situation.
            
            When a new exception is created, its name as a string must be added as a
            value in the resource bundle such that a default message is always 
            available if no user defined message key is provided.
            
            This interface inherits the <see cref="T:System.IFormattable"/> interface and provides the 
            formats as described in the <c>ToString(string, IFormatProvider)</c> method.
            
            This interface represents a port of an exception framework developed originally in
            JAVA. Additionally, it borrows some concepts from the .NET Exception Block 
            found at Microsoft.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.IHcaException.PrintStackTrace">
            <overloads>Prints the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.IHcaException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.IHcaException.GetBaseException">
            <summary>(Implied by <see cref="T:System.Exception"/>.) When overridden in a derived class, returns the 
            <see cref="T:System.Exception"/> that is the root cause of one or more subsequent exceptions.</summary>
            <returns>The first exception thrown in a chain of exceptions. If the <see cref="P:System.Exception.InnerException"/> 
            property of the current exception is <see langword="null"/>, this property returns the current exception.</returns>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.Message">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.IHcaException.HostName"/>, <see cref="P:Hca.Common.BaseException.IHcaException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.IHcaException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Default: <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Default:<see langword="false"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Default: <see langword="false"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            If set to <see langword="false"/>, this exception will only be logged if explicitly
            logged through a handler. For example, if the 
            <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> method's <c>alwaysLog</c>
            parameter is <see langword="true"/>, this exception would be logged. Otherwise the
            exception will pass through the handler without logging. 
            
            Default: <see langword="true"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.HelpLink">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Gets or sets a link to the help file associated with this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.InnerException">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Gets the <see cref="T:System.Exception"/> instance that caused the current exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.Source">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Gets or sets the name of the application or the object that causes the error.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.StackTrace">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Gets a string representation of the frames on the call stack at the time the current exception was thrown.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.TargetSite">
            <summary>(Implied by <see cref="T:System.Exception"/>.) Gets the method that throws the current exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.IHcaException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            <para>
            Recoverability should be used by a client to determine whether an exception can be overcome
            through user intervention or whether the exception represents a system problem that can only
            be resolved by support personnel.
            </para>
            <para>
            This method is settable since an exception handler may need to set or unset the value based
            on their knowledge of the situation. For example, a system exception might be marked as unrecoverable
            from a low-level perspective but could become recoverable when some higher level handler had enough 
            detail to prompt for a solution to the exception. Hence the usage of this field should be read-only from 
            the perspective of a client application but writable from a service or infrastructure layer.
            </para>
            <para>
            By default, Exceptions derived from <see cref="T:System.SystemException"/> will be marked as unrecoverable. Exceptions derived
            from <see cref="T:System.ApplicationException"/> will be marked as recoverable by default.
            </para>
            </remarks>
            <value>
            <see langword="true"/> if the client can provide alternate input to correct the exception condition. 
            If <see langword="false"/>, the client must have intervention external to the input of the request to resolve the exception.
            </value>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.#ctor">
            <overloads>Instantiates a new instance of a <see cref="T:Hca.Common.BaseException.HcaApplicationException"/>.</overloads>
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message</summary>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaApplicationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This class provides the base for all user defined exceptions within the HCA framework. It adds to the set of 
            detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. 
            An <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> by default is considered to be recoverable. 
            As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is impossible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaApplicationException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This class provides the base for all user defined exceptions within the HCA framework. It adds to the set of 
            detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. 
            An <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> by default is considered to be recoverable. 
            As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is impossible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.CreationLocalTime">
            <summary>
            Gets a DateTime structure initialized to the local creation time of this 
            exception using the current machine's time zone and daylight savings time 
            settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.UniqueId">
            <summary>
            Gets a unique id that can be used to correlate this exception to 
            any other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.HcaApplicationException.HostName"/>, 
            <see cref="P:Hca.Common.BaseException.HcaApplicationException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaApplicationException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaApplicationException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.ConcurrentObjectUpdateException.#ctor">
            <overloads>
            Initializes a new instance of the <see cref="T:Hca.Common.BaseException.ConcurrentObjectUpdateException"/> class.
            </overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.ConcurrentObjectUpdateException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes a message
            </summary>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.ConcurrentObjectUpdateException.#ctor(System.Exception)">
            <summary>
            Constructor that takes the cause of an exception
            </summary>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ConcurrentObjectUpdateException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Constructor that takes the message and cause for the exception.
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ConcurrentObjectUpdateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor. This is used when reconstituting a serialized object.
            </summary>
            <param name="info">the serialized object information</param>
            <param name="context">the context</param>
        </member>
        <member name="T:Hca.Common.BaseException.DuplicateItemException">
            <summary>
            This exception represents the condition where a duplicate item is found.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <seealso cref="T:Hca.Common.BaseException.HcaApplicationException"/>
            <remarks>
            <para>
            Generally this exception is used when attempting to add or update an item in a collection or data store and the 
            action cannot be completed because it would generate a duplicate item.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.DuplicateItemException.#ctor">
            <overloads>
            Initializes a new instance of the <see cref="T:Hca.Common.BaseException.DuplicateItemException"/> class.
            </overloads>
            <summary>
            Default Constructor.
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.DuplicateItemException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes a message.
            </summary>
            <param name="msg">The message to display.</param>
        </member>
        <member name="M:Hca.Common.BaseException.DuplicateItemException.#ctor(System.Exception)">
            <summary>
            Constructor that takes an exception that causes this exception.
            </summary>
            <param name="cause">The Exception that caused this exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.DuplicateItemException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Constructor that takes a message and exception that caused this exception.
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.DuplicateItemException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor. This is used when reconstituting a serialized object.
            </summary>
            <param name="info">the serialized object information.</param>
            <param name="context">the context</param>
        </member>
        <member name="T:Hca.Common.BaseException.ExceptionConfig">
            <summary>
            This class contains the exception configuration information. This includes
            the stack trace flag and context name of resource bundles.
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="T:Hca.Common.Configuration.ConfigBase">
            <summary>The base class of configuration objects that can be managed by <see cref="T:Hca.Common.Configuration.ConfigFactory"/></summary>
            <threadsafety static="true" instance="false"/>
            <remarks><para>
            By convention, concrete subclasses of <see cref="T:Hca.Common.Configuration.ConfigBase"/> should be 
            named with the 'Config' suffix, e.g. <see cref="T:Hca.Common.Service.ServiceConfig"/>. 
            Subclasses add meaningful properties to describe configuration concepts for 
            their domain. Constructors must call the base constructor, and property setters 
            should call <see cref="M:Hca.Common.Configuration.ConfigBase.CheckWritable"/>. Fields that should never contain 
            <see langword="null"/> should be marked [<see cref="T:Hca.Common.RequiredAttribute">Required</see>]. More complex validation logic can 
            be implemented by overriding <see cref="M:Hca.Common.Configuration.ConfigBase.ValidateCustom"/>.
            </para><para>
            By default, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> will return a configuration object only 
            if the calling assembly also defined the object's class. If a configuration class is 
            intended for direct consumption by other assemblies, it must be marked 
            [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>].
            </para><para>
            Logging and exception handling in code that consumes instances of <see cref="T:Hca.Common.Configuration.ConfigBase"/> can reference the <see cref="P:Hca.Common.Configuration.ConfigBase.Source"/> property to 
            help expose detail about the configuration driving program behavior.
            </para><note>
            This class implements value-based semantics, similar to <see cref="T:Hca.Common.BaseType.ObjectBase"/>. (See <see cref="M:Hca.Common.Configuration.ConfigBase.Equals(System.Object)"/>, <see cref="M:Hca.Common.Configuration.ConfigBase.GetHashCode"/>, <see cref="M:Hca.Common.Configuration.ConfigBase.ToString"/>, and <see cref="P:Hca.Common.Configuration.ConfigBase.InstanceIdentity"/>.)
            </note></remarks>		
            <example>
            Please see the <see cref="N:Hca.Common.Configuration"/> namespace 
            overview for a complete walk-through example of creating a configuration 
            class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>. The HCA DevBlocks Developer Pack provides a 
            Visual Studio template for concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> subclasses.
            </example>
        </member>
        <member name="T:Hca.Common.IIdentifiable">
            <summary>
            Interface that indicates that this class is uniquely identifiable. 
            The semantics of what this means depends on the class.
            </summary>
            <remarks>
            The class is uniquely identifiable in regards to its in memory representation and
            not its lifetime representation.
            </remarks>
        </member>
        <member name="P:Hca.Common.IIdentifiable.InstanceIdentity">
            <summary>
            Return the identity of the object instance.
            </summary>
        </member>
        <member name="F:Hca.Common.Configuration.ConfigBase.instanceId">
            <summary>Holds a guid to identify the runtime instance of the object.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.ConfigBase.readOnly">
            <summary>Holds a boolean indicating whether the object's property setters should throw an exception.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.ConfigBase.source">
            <summary>Holds a human-readable description of where this object was defined.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.#ctor">
            <summary>
            Protected initializer to be called when subclasses are instantiated.
            </summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.SetReadOnly(System.Boolean)">
            <summary>
            Internal helper method used by the <see cref="T:Hca.Common.Configuration.ConfigFactory"/> object to set the <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> property of the object during creation.
            </summary>
            <param name="isReadOnly">Whether an exception should be thrown by a call to <see cref="M:Hca.Common.Configuration.ConfigBase.CheckWritable"/>.</param>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.CheckWritable">
            <overloads>Throws an exception if the configuration object is read-only.</overloads>
            
            <summary>
            Throws an exception for any method or property if the configuration object is read-only.
            </summary>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.CheckWritable(System.Reflection.MethodBase)">
            <summary>
            Throws an exception for the specified <paramref name="method"/> if the configuration object is read-only.
            </summary>
            <param name="method">The method attempting to modify the object's value.</param>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.CheckWritable(System.String)">
            <summary>
            Throws an exception for the specified property (<paramref name="propertyName"/>) if the configuration object is read-only.
            </summary>
            <param name="propertyName">The name of the property attempting to modify the object's value.</param>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.CheckWritable_Impl(System.String)">
            <summary>
            Throws an exception if the configuration object is read-only.
            </summary>
            <param name="methodName">The name of the method (or property) attempting to modify the object's value.</param>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.Validate">
            <summary>
            Ensures usability of this configuration object.
            </summary>
            <remarks>
            This method is called by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> after the 
            configuration object has been instantiated, before it is cached and returned 
            to the caller. For any field marked [<see cref="T:Hca.Common.RequiredAttribute">Required</see>], an exception will be thrown if the value is 
            <see langword="null"/>. The <see langword="virtual"/> method <see cref="M:Hca.Common.Configuration.ConfigBase.ValidateCustom"/> is also called, allowing subclasses to implement 
            more complex validation logic.
            </remarks>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if invalid configuration is detected.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.ValidateRequired">
            <summary>
            Ensures that each field marked [<see cref="T:Hca.Common.RequiredAttribute">Required</see>] is not <see langword="null"/>.
            </summary>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if invalid configuration is detected.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.ValidateCustom">
            <summary>
            Performs subclass-specific validation logic for calls to <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>.
            </summary>
            <remarks>
            This method, called by <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>, may be overridden by 
            subclasses to implement more complex validation logic than that provided by 
            marking fields [<see cref="T:Hca.Common.RequiredAttribute">Required</see>]. The <see langword="virtual"/> implementation is no-op.
            </remarks>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if invalid configuration is detected.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.Equals(System.Object)">
            <summary>
            Overrides <see cref="T:System.Object"/>'s <see cref="M:System.Object.Equals(System.Object)">implementation</see> to provide an equality check with value-based semantics.
            </summary>
            <remarks><para>
            This method is implemented in terms of <see cref="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object)"/>. Subclasses should not need to override this implementation.
            </para><para>
            <see cref="P:Hca.Common.Configuration.ConfigBase.InstanceIdentity"/>, <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/>, and <see cref="P:Hca.Common.Configuration.ConfigBase.Source"/> are ignored for equality comparisons.
            </para></remarks>
            <param name="value">The object to compare with this one.</param>
            <returns><see langword="true"/> if this and the passed object are equal in value; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.GetHashCode">
            <summary>
            Overrides <see cref="T:System.Object"/>'s <see cref="M:System.Object.GetHashCode">implementation</see> to provide a hash code with value-based semantics.
            </summary>
            <remarks><para>
            This method is implemented in terms of <see cref="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)"/>. Subclasses should not need to override this implementation.
            </para><para>
            <see cref="P:Hca.Common.Configuration.ConfigBase.InstanceIdentity"/>, <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/>, and <see cref="P:Hca.Common.Configuration.ConfigBase.Source"/> are ignored for hash code generation.
            </para></remarks>
            <returns>A hash code value for this object.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.op_Equality(Hca.Common.Configuration.ConfigBase,Hca.Common.Configuration.ConfigBase)">
            <summary>Implements the == operator with value-based semantics.</summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects are equal in value; otherwise, <see langword="false"/>.</returns>
            <remarks>This operator is implemented in terms of this class's <see cref="M:Hca.Common.Configuration.ConfigBase.Equals(System.Object)"/> override.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.op_Inequality(Hca.Common.Configuration.ConfigBase,Hca.Common.Configuration.ConfigBase)">
            <summary>Implements the != operator with value-based semantics.</summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="false"/> if the two objects are equal in value; otherwise, <see langword="true"/>.</returns>
            <remarks>This operator is implemented in terms of this class's <see cref="M:Hca.Common.Configuration.ConfigBase.Equals(System.Object)"/> override.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigBase.ToString">
            <summary>
            This method provides a string view of all public properties.
            </summary>
            <remarks>
            This is convenient for debugging.
            </remarks>
            <returns>A string that is a fully recursive dump of the object's values.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.ConfigBase.InstanceIdentity">
            <summary>
            Return the identity of the object instance.
            </summary>
            <remarks>
            See <see cref="T:Hca.Common.IIdentifiable"/> for more information.
            </remarks>
        </member>
        <member name="P:Hca.Common.Configuration.ConfigBase.ReadOnly">
            <summary>
            Gets a boolean indicating whether the object's property setters will throw an exception.
            </summary>
            <remarks>
            Subclasses can manipulate the value of this property using <see cref="M:Hca.Common.Configuration.ConfigBase.SetReadOnly(System.Boolean)"/>.
            </remarks>
        </member>
        <member name="P:Hca.Common.Configuration.ConfigBase.Source">
            <summary>
            Gets or sets a human-readable description of where this object was defined.
            </summary>
            <remarks><para>
            This property is useful for reporting configuration errors, as well as logging 
            details about configuration-driven operations.
            </para><para>
            The <see cref="T:System.String"/> value should be a noun phrase suitable for 
            placement in sentences such as the following: "Using configuration defined 
            in {0}." An example expansion would then read, "Using configuration 
            defined in configuration file [E:\Applications\MyApp\bin\MyInclude.config]: 
            line 41, column 3."
            </para><para>
            <see cref="P:Hca.Common.Configuration.ConfigBase.Source"/> is set by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> for any objects it creates.
            </para></remarks>
        </member>
        <member name="F:Hca.Common.BaseException.ExceptionConfig.includeStackTrace">
            <summary>
            Indicates whether exceptions by default include a stack trace when 
            logged. <see langword="true"/> means they are included. 
            Default: <see langword="false"/>
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.ExceptionConfig.contextName">
            <summary>
            The context name to use for getting the resource message bundle
            information.
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.ExceptionConfig.helpLink">
            <summary>
            A String the has the link to any help that may be available to
            understand this exception. In most cases, an application will
            configure this to a support site and hence this will be set
            in an applications config.xml file.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionConfig.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionConfig.ValidateCustom">
            <summary>
            Validate that values expected are present
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.ExceptionConfig.IncludeStackTrace">
            <summary>
            Return or set <see langword="true"/> if stack traces should be included when logging an exception
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.ExceptionConfig.ContextName">
            <summary>
            Return or set the context name to get the exception bundle names to be used 
            to find exception message text. 
            </summary>
            <returns>string</returns>
        </member>
        <member name="P:Hca.Common.BaseException.ExceptionConfig.HelpLink">
            <summary>
            Return or set location of the default help documentation on exceptions.
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Hca.Common.BaseException.ExceptionHandler">
             <summary>
             This class is a handler to capture exception details and log them to a logger. This class only provides 
             static methods for use and can not be instantiated directly. Exceptions are only logged once unless
             explicitly marked to not be logged or the <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> flag is reset 
             by a client (<see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> = <see langword="false"/>). 
             </summary>
             <threadsafety static="true" instance="false"/> 
             <remarks>
             <para>
             The term handler as used in this class should not be construed to mean that the exception is disposed of but 
             instead that it is logged and value-add processed so that clients might better dispose of the condition. The 
             handler processes exceptions by looking at their type and recasting them to an Hca based exception if a .NET
             exception or returning the exception as is if already an <see cref="T:Hca.Common.BaseException.IHcaException"/>. Hence, clients can always 
             expect an Hca exception from the handler. There are two forms of the handler <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/>
             and <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type)"/>: Both return an <see cref="T:System.Exception"/> which is a 
             <see cref="T:Hca.Common.BaseException.IHcaException"/>, the first will also log the exception if appropriate while that later always log the 
             exception. The first form is the typical usage of the handler. However, if an exception is returned at a 
             layer boundary, it is recommended to use the other form to ensure that the exception has been logged.
             </para>
             <para>
             If a non-HCA exception is thrown it will be wrapped in either one of the HCA supplied .NET wrapper exceptions or 
             at a minimum an <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> (if it derives from <see cref="T:System.ApplicationException"/>) or 
             <see cref="T:Hca.Common.BaseException.HcaSystemException"/> (if it derives from <see cref="T:System.SystemException"/>. The message used for the wrapped 
             exception will be the message from the wrapped exception.
             </para>
             <para>
             An optional message can be supplied to provide supplemental detail to the normal exception message when an exception
             is handled. This message will be only written to the log and is not retained by the wrapped exception. When 
             processing an exception, the originally thrown exception is returned if it is already marked as an 
             <see cref="T:Hca.Common.BaseException.IHcaException"/>. In most cases, the typical usage is to pass the exception and caller's class type for 
             handling and throw the resulting exception. However, if the exception is an <see cref="T:Hca.Common.BaseException.IHcaException"/>, you may want to call the 
             handler but instead of throwing the returned exception (which would be the same as that passed to the handler), you 
             can simply rethrow the exception. This usage maintains the stack trace instead of creating a new stack trace as will
             happen in the throw case.
             </para>
             <para>
             If the exception is wrapped, and the wrapped exception has been logged, the exception is not logged again. 
             If the wrapping exception detail is desired in the log, the client (code that catches the exception and invokes 
             this handler) should use the overridden method, which forces the exception to be logged independent of whether it 
             has been logged previously.
             </para>
             <para>
             Each exception can define the level it will be logged at. By default, exceptions are logged at the 
             <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level. Setting the log level is important in terms of how the exception 
             is processed by any appenders attached through the logging framework (refer to Common Usage Guide for Details).
             For example, severe log levels will be sent to the EventLog which can notify operations that something is wrong
             with the application. However, you would not want to notify operations if the exception was expected, recoverable, or
             for informational purposes. If a client desires the exception to be logged at a different level, it should set 
             the <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/> to the level desired.
             </para>
             <para>
             If <see langword="null"/> is passed as the value for an exception, no processing is done by this handler since no exception is present. 
             If the client application desires a message to the log, use the <see cref="T:Hca.Common.Logger.HcaLogger"/> directly. Finally, when considering
             throwing or rethrowing an exception returned by the handler, you should attempt to preserve the stack trace if the
             exception caught is already an IHcaException-based exception. Refer to the examples that follow for guidance.
             </para>
            </remarks>
            <example>
            This example shows typical usage of the handler:
            <code>
            		try
            		{
            			// Do some work
            		}
            		catch(Exception exc)
            		{
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType());
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            </code>
             This example shows telling the handler to log the exception even if it
             has already been logged:
            <code>
            		try
            		{
            			// Do some work
            		}
            		catch(Exception exc)
            		{
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType(), true);
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            </code>
            This example show providing a supplemental message which will be logged with the
            caught exception:
            <code>
            		try
            		{
            			// Do some work
            		}
            		catch(Exception exc)
            		{
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType(), ExceptionMessage.ArgumentNull());
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            </code>
            This example shows logging the exception at a info level instead of the 
            default of Warn:
            <code>
            		try
            		{
            			// Do some work
            		}
            		catch(Exception exc)
            		{
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType(), 
            				HcaLogger.LogLevel.Info);
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            </code>
            This example shows recasting an exception of <see cref="T:System.IO.FileNotFoundException"/> to 
            <code>
            		try
            		{
            			// Do some work
            		}
            		catch(System.IO.FileNotFoundException exc)
            		{
            			throw ExceptionHandler.HandleException(new ItemNotFoundException(
            				ExceptionMessage.ItemNotFound(itemName), exc), this.getType());
            		}
            		catch(Exception exc)
            		{
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType());
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            </code>
            This example shows marking an exception to not log.
            <code>
            		try
            		{
            			...
            			DoNotLogException exc =  new DoNotLogException();
            			exc.LogException = false;
            			throw exc;
            		}
            		catch(Exception exc)
            		{
            			// This will not log the DoNotLogException exception.
            			IHcaException retExc = ExceptionHandler.HandleException(exc, this.getType());
            			if (exc is IHcaException)
            			{
            				throw;
            			}
            			throw retExc;
            		}
            	</code>
            	This example shows handling an exception and doing some additional work before (re)throwing it
            	<code>
            		try
            		{
            		  ...
            		}
            		catch(System.Exception exc)
            		{
            			bool rethrow = false;
            			if (exc is IHcaException)
            			{
            				rethrow = true;
            			}
            			Exception excToThrow = ExceptionHandler.HandleException(exc, this.getType());
            			// Do Some more work
            			...
            			if (rethrow)
            			{
            				throw;
            			}
            			else
            			{
            				throw excToThrow;
            			}
            		}
            	</code>
            	This example shows handling an exception completely and not throwing it
            	<code>
            		try
            		{
            		  ...
            		}
            		catch(System.ItemNotFoundException exc)
            		{
            			// Might want to log it
            			ExceptionHandler.HandleException(exc, this.getType());
            			// and/or do some other work
            			...
            			// But that's it...
            		}
            	</code>
            </example>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.#ctor">
            <summary>
            Hide Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.DetermineLogLevel(System.Exception)">
            <summary>
            Helper to determine logging level
            </summary>
            <param name="exc"></param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException_Impl(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage,Hca.Common.Logger.HcaLogger.LogLevel,System.Boolean)">
            <summary>
             Implementation of HandleException
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception </param>
            <param name="msg">The supplemental message to use when logging this exception</param>
            <param name="levelToLog">The <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/> to explicitly log this exception</param>
            <param name="alwaysLog">If <see langword="true"/>, exception will always be logged</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.WrapNativeException(System.Exception,System.Boolean@)">
            <summary>
            Wrap a native exception
            </summary>
            <param name="exc">The exception to potentially wrap</param>
            <param name="excCreated"></param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.LogException(System.String,System.Exception,System.String,Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>Logs an exception.</summary>
            <param name="supplementalMessage">Additional information to precede the exception's details.</param>
            <param name="loggingSubject">The exception to be logged.</param>
            <param name="loggerName">The name of the logger to which to write.</param>
            <param name="logLevel">The level at which to log the exception</param>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">Thrown if the method cannot log an exception anywhere</exception>
            <remarks>If the method fails to retrieve the specified logger, it will attempt to log the exception to the Windows event log and to the console. If this fails, an exception is thrown.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)">
            <overloads>
            All overloads of this method will handle a given exception and log it to the current 
            logger given the exception is at the appropriate level and has not already been logged. The passed type, 
            <c>callingClass</c>, is used to demarcate the context where the exception occurred within the logger.
            </overloads>
            <summary>
            Handles a given exception. This overload represents the base implementation of <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/>.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception handling</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,System.Boolean)">
            <summary>
            Handles a given exception while allowing the caller to indicate that the exception must be 
            logged again when the <paramref name="alwaysLog"/> argument is <see langword="true"/> even if already logged.
            </summary>
            <remarks>
            Passing <see langword="false"/> for <paramref name="alwaysLog"/> is equivalent to calling 
            <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/>.
            </remarks>
            <param name="exc">The exception to handle</param>
            <param name="callingClass">The type of the class asking for exception handling</param>
            <param name="alwaysLog">If <see langword="true"/>, exception will always be logged</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>
            Handles a given exception while allowing the caller to override the default level to log for the exception.
            </summary>
            <param name="exc">The exception to handle</param>
            <param name="callingClass">The type of the class asking for exception handling</param>
            <param name="levelToLog">The explicit level to log this exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Logger.HcaLogger.LogLevel,System.Boolean)">
            <summary>
            Handles a given exception while allowing the caller to specify both the level to log and to always log the exception.
            </summary>
            <param name="exc">The exception to handle</param>
            <param name="callingClass">The type of the class asking for exception handling</param>
            <param name="levelToLog">The explicit level to log this exception</param>
            <param name="alwaysLog">If <see langword="true"/>, exception will always be logged</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage)">
            <summary>
            Handles a given exception while allowing the caller to include a supplemental message.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception</param>
            <param name="msg">The supplemental message to include when logging the exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage,System.Boolean)">
            <summary>
            Handles a given exception while allowing the caller to include a supplemental message and specify whether to explicitly log the
            exception.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception</param>
            <param name="msg">The supplemental message to include when logging the exception</param>
            <param name="alwaysLog">If <see langword="true"/>, exception will always be logged</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage,Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>
            Handles a given exception while allowing the caller to include a supplemental message and log level.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception </param>
            <param name="msg">The supplemental message to include when logging the exception</param>
            <param name="levelToLog">The explicit level to log this exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage,Hca.Common.Logger.HcaLogger.LogLevel,System.Boolean)">
            <summary>
            Handles a given exception while allowing the caller to include a supplemental message, log level, and whether to explicitly
            log the exception.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception </param>
            <param name="msg">The supplemental message to include when logging the exception</param>
            <param name="levelToLog">The explicit level to log this exception</param>
            <param name="alwaysLog">If <see langword="true"/>, exception will always be logged</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type)">
            <overloads>
            All methods will handle a given exception and always log it to the current 
            logger given the exception is at the appropriate level and has not
            already been logged. The passed type, <c>callingClass</c>, is used to 
            demarcate the context where the exception occurred within the logger. 
            Further, it is the intent that any cross tier special handling for
            exceptions would be encapsulated within this method. For now, the 
            only differences between this method and <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> is 
            that the exception is always logged. 
            </overloads>
            <summary>
            Handles a given exception and always logs it to the current logger. This overload represents 
            the base implementation of <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type)"/>.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception 
            Handling</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type,Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>
            Handles a given exception and always logs it to the current logger. This overload allows the caller to 
            specify the <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception 
            Handling</param>
            <param name="levelToLog">The <c>LogLevel</c> to explicitly log this exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage)">
            <summary>
            Handles a given exception and always logs it to the current logger. This overload allows the caller to 
            specify the resource key for the exception message text.
            </summary>
            <param name="exc">The exception to Handle</param>
            <param name="callingClass">The type of the class asking for exception 
            Handling</param>
            <param name="msg">The resource key to the message to use for the text
            of this exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type,Hca.Common.Resource.ResourceMessage,Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>
            Handles a given exception and always logs it to the current logger. This overload allows the caller to specify the 
            resource key for the exception message text and the <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.
            </summary>
            <param name="exc">The exception to Handler</param>
            <param name="callingClass">The type of the class asking for exception 
            Handling</param>
            <param name="msg">The resource key to the message to use for the text
            of this exception</param>
            <param name="levelToLog">The <c>LogLevel</c> to explicitly log this exception</param>
            <returns><see cref="T:Hca.Common.BaseException.IHcaException"/></returns>
        </member>
        <member name="T:Hca.Common.BaseException.ExceptionMessage">
            <summary>
            This class defines an Exception Message that can be used with creating exceptions
            or adding detail when handling an exception with the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>.
            </summary>
            <seealso cref="T:Hca.Common.Resource.ResourceMessage"/>
        </member>
        <member name="T:Hca.Common.Resource.ResourceMessage">
            <summary>
            This class represents a message that is stored in a resource.
            </summary>
            <remarks>
            This class provide encapsulation of the context, arguments, and behavior around retrieving a message 
            from a resource. It is intended to be used with the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> and is expected 
            as an argument when forming exception messages.
            This class implements value semantics for equality checks.
            </remarks>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.#ctor(System.String,System.String,System.Object[])">
            <overloads>Initializes a new instance of a resource message.</overloads>
            <summary>
            Create a resource message from a context given a name and some replaceable arguments.
            </summary>
            <param name="context">The context to find the message</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.#ctor(System.IFormatProvider,System.String,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="formatProvider">A provide to use when forming the message from the resource.</param>
            <param name="context">The context to find the message</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.#ctor(System.Boolean,System.String,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="exceptionIfMissing">if <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            <param name="context">The context to find the message</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.#ctor(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="formatProvider">A provide to use when forming the message from the resource.</param>
            <param name="culture">A culture to apply when forming the message from the resource.</param>
            <param name="exceptionIfMissing">if <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            <param name="context">The context to find the message</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.ToString">
            <summary>
            Returns the message from the resource that this class represents.
            </summary>
            <returns>the message for use.</returns>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.Equals(System.Object)">
            <summary>
            Overrides <see cref="T:System.Object"/>'s <see cref="M:System.Object.Equals(System.Object)">implementation</see> to provide an equality 
            check with value-based semantics.
            </summary>
            <remarks>
            This method is implemented in terms of <see cref="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object)"/>. Sub-classes should not need to 
            override this implementation.
            </remarks>
            <param name="obj">The object to compare with this one.</param>
            <returns><see langword="true"/> if this and the passed object are equal in value; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.GetHashCode">
            <summary>
            Overrides <see cref="T:System.Object"/>'s <see cref="M:System.Object.GetHashCode">implementation</see> to provide a hash code 
            with value-based semantics.
            </summary>
            <remarks>
            This method is implemented in terms of <see cref="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)"/>. Sub-classes should not need 
            to override this implementation.
            </remarks>
            <returns>A hash code value for this object.</returns>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.op_Equality(Hca.Common.Resource.ResourceMessage,Hca.Common.Resource.ResourceMessage)">
            <summary>Implements the == operator with value-based semantics.</summary>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects are equal in value; otherwise, <see langword="false"/>.</returns>
            <remarks>This operator is implemented in terms of this class's <see cref="M:Hca.Common.Resource.ResourceMessage.Equals(System.Object)"/> override.</remarks>
        </member>
        <member name="M:Hca.Common.Resource.ResourceMessage.op_Inequality(Hca.Common.Resource.ResourceMessage,Hca.Common.Resource.ResourceMessage)">
            <summary>Implements the != operator with value-based semantics.</summary>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <returns><see langword="false"/> if the two objects are equal in value; otherwise, <see langword="true"/>.</returns>
            <remarks>This operator is implemented in terms of this class's <see cref="M:Hca.Common.Resource.ResourceMessage.Equals(System.Object)"/> override.</remarks>
        </member>
        <member name="P:Hca.Common.Resource.ResourceMessage.Name">
            <summary>
            Returns name used to retrieve the message from a resource.
            </summary>
        </member>
        <member name="P:Hca.Common.Resource.ResourceMessage.Context">
            <summary>
            Returns the context used to retrieve the message from a resource.
            </summary>
        </member>
        <member name="P:Hca.Common.Resource.ResourceMessage.FormatArgs">
            <summary>
            Returns the arguments associated with this message.
            </summary>
            <remarks>
            If there are no arguments an empty collection is returned.
            </remarks>
        </member>
        <member name="F:Hca.Common.BaseException.ExceptionMessage.resourceContextName">
            <summary>
            The context name to use to get resource messages. If no configuration
            file is supplied, this field will be set to exception and hence
            exception message will be attempted from that context.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.#cctor">
            <summary>
            Static constructor to load config resource.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.#ctor(System.String,System.Object[])">
            <summary>
            Create a resource message from a context given a name and some replaceable arguments.
            </summary>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.#ctor(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="formatProvider">A provider to use when forming the message from the resource.</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.#ctor(System.Boolean,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="exceptionIfMissing">If <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.#ctor(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.Object[])">
            <summary>
            Create a resource message from the passed parameters.
            </summary>
            <param name="formatProvider">A provide to use when forming the message from the resource.</param>
            <param name="culture">A culture to apply when forming the message from the resource.</param>
            <param name="exceptionIfMissing">If <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            <param name="name">The name used within the resource to retrieve.</param>
            <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ConcurrentUpdateDetected(System.UInt64,System.UInt64,System.UInt64)">
            <overloads>This message is used when a dirty update is detected while updating and object.</overloads>
            <summary>
            <para>This message is used when a dirty update is detected while updating an object and the new version is known.</para>
            <para><b>Message:</b> "The values of the object with Id [{0}] being updated has changed since it was retrieved 
            for update (new version:[{1}] object version:[{2}]). Please reload the current object and apply your changes 
            again."</para>
            </summary>
            <param name="objectId">The object Id of the object being updated.</param>
            <param name="newVersion">The version as loaded from persistence of the object to update.</param>
            <param name="currentVersion">The version of the object that will update the loaded object.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ConcurrentUpdateDetected(System.UInt64,System.UInt64)">
            <summary>
            <para>This message is used when a dirty update is detected while updating and object.</para>
            <para><b>Message:</b> "The values of the object with Id [{0}] being updated has changed since it was retrieved 
            for update (object version:[{1}]). Please reload the current object and apply your changes again."</para>
            </summary>
            <param name="objectId">The object Id of the object being updated.</param>
            <param name="currentVersion">The version of the object that will update the loaded object.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.CountryCodeInvalidForNorthAmerica">
            <summary>
            <para>This key is used when the Country Code is not proper for a North 
            American phone number.</para>
            <para><b>Message:</b> "The country code for a North American Number must be 1."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.CountryCodeFormatInvalid">
            <summary>
            <para>This key is used when the numeric Country Code is not proper.</para>
            <para><b>Message:</b> "The country code format must be of the form (X)(X)X where () indicates optional 
            and X represents 0-9 unless its the first digit then 1-9."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.AreaCodeFormatForNorthAmericaInvalid">
            <summary>
            <para>This key is used when a Area Code is not proper for a North American 
            phone number.</para>
            <para><b>Message:</b> "The area code format for a North American phone 
            number must be of the form NXX where N indicates digits 2-9, and 
            X indicates digits 0-9 and can not be X11 or X9X or 37X or 96X."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberPrefixFormatForNorthAmericaInvalid">
            <summary>
            <para>This key is used when a Prefix is not proper for a North American 
            phone number.</para>
            <para><b>Message:</b> "The prefix format for a North American phone number 
            must be of the form NXX where N indicates digits 2-9, and X 
            indicates digits 0-9."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberInvalid(System.String)">
            <summary>
            <para>This key is used when the format of a phone number is not valid for North American or International.</para>
            <para><b>Message:</b> "Argument [{0}] does not comply with North American or International phone number formats."</para>
            </summary>
            <param name="phoneNumber">The phone number that is invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberFormatInvalidForInternationalLocalNumber">
            <summary>
            <para>This key is used when a Subscriber (Local Number) is not proper for an 
            international phone number.</para>
            <para><b>Message:</b> "The local number format for an International phone 
            number must be of the form (XXXXXXXXXXX)XXX where () indicates 
            optional and X indicates digits 0-9."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberFormatInvalidForNorthAmericanLocalNumber">
            <summary>
            <para>This key is used when a Local Number is not proper for a North 
            American phone number.</para>
            <para><b>Message:</b> "The local number format for a North American phone 
            number must be of the form XXXX where X indicates digits 0-9."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberCountryCodeIsNull">
            <summary>
            <para>This key is used when a Country Code is <see langword="null"/>.</para>
            <para><b>Message:</b> "The country code must be specified for an international phone number."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberAreaCodeIsNull">
            <summary>
            This key is used when a Area Code is <see langword="null"/>.
            <para><b>Message:</b> "The area code of the phone number must be specified for this request."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberPrefixIsNull">
            <summary>
            <para>This key is used when a Prefix is <see langword="null"/>.</para>
            <para><b>Message:</b> "The prefix of the phone number must be specified for this request."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberLocalNumberIsNull">
            <summary>
            <para>This key is used when a local number is <see langword="null"/>.</para>
            <para><b>Message:</b> "The local number of the phone number must be specified for this request."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberInvalidForNorthAmerica(System.String)">
            <summary>
            <para>This key is used when the format of a North American phone number is not valid.</para>
            <para><b>Message:</b> "Argument [{0}] does not comply with North American phone number format 
            (1) (NXX) NXX XXXX where () indicate optional, N indicates digits 2-9, and X indicates digits 0-9. 
            Area code can not be X11 or X9X or 37X or 96X."</para>
            </summary>
            <param name="phoneNumber">The phone number that is invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberInvalidForInternational(System.String)">
            <summary>
            <para>This key is used when the format of a international phone number is not valid.</para>
            <para><b>Message:</b> "Argument [{0}] does not comply with International number format 
            ((X)(X)X) (XXXXXXXXXXX)XXX where () indicates optional and X indicates digit 0-9."</para>
            </summary>
            <param name="phoneNumber">The international phone number that is invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PhoneNumberAliasInvalidForInternational">
            <summary>
            <para>This key is used when an alias international phone number is used.</para>
            <para><b>Message:</b> "Alias international phone numbers are not allowed."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.SubscriberNumberInvalid">
            <summary>
            <para>This key is used when the format of the subscriber number portion of a phone number is not valid.</para>
            <para><b>Message:</b> "The subscriber number can not be longer than 12 digits."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ArgumentNull(System.String)">
            <summary>
            <para>This key is used when an argument is not provided but should be.</para>
            <para><b>Message:</b> "Argument [{0}] must be supplied."</para>
            </summary>
            <param name="argumentName">The name of the argument.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceNotFound(System.String,System.String)">
            <summary>
            <para>This key is used when a service is not found.</para>
            <para><b>Message:</b> "Service Type [{0}] is not defined for context [{1}]."</para>
            </summary>
            <param name="typeName">The type name of the service that could not be found.</param>
            <param name="serviceContext">The context that was used to discover if the service was present.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceTypeIsRequired">
            <summary>
            <para>This key is used when a service is being specified to use a dynamic proxy and no interface type is specified.</para>
            <para><b>Message:</b> "Argument Service Type is required along with argument optional."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCantBeCreated(System.String)">
            <summary>
            <para>This key is used when a service can't be created given the passed identifier.</para>
            <para><b>Message:</b> "Unable to create service type by [{0}]."</para>
            </summary>
            <param name="identifier">The identifier that specifies the service to be created (e.g. ClassId).</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceTypeCantBeInstantiated(System.Type)">
            <summary>
            <para>This key is used when a service can't be instantiated for a specified Type.</para>
            <para><b>Message:</b> "Unable to create service of [{0}] type."</para>
            </summary>
            <param name="serviceType">The service type that was attempted to instantiate.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCantBeInstantiatedFromCreationMethod(System.String,System.Type)">
            <summary>
            <para>This key is used when a service can't be instantiated for a specified Type.</para>
            <para><b>Message:</b> "Unable to create service from defined Creation Method [{0}] of Type [{1}]."</para>
            </summary>
            <param name="methodName">The method name to instantiate.</param>
            <param name="serviceType">The service type that was attempted to instantiate.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCreationMethodNotFound(System.Type,System.String,System.Type[],System.String)">
            <summary>
            <para>States that the service creation method specified by a given <see cref="T:Hca.Common.Service.ServiceConfig"/> could not be located.</para>
            <para><b>Message:</b> "Could not locate the service creation method [{0}.{1}({2})] specified by the {3} defined in {4}."</para>
            </summary>
            <param name="creationMethodDeclaringType">The type on which the service creation method was expected.</param>
            <param name="creationMethodName">The name of the service creation method.</param>
            <param name="creationMethodArgTypes">The types of the arguments defined.</param>
            <param name="configSource">The location of the ServiceConfig definition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceConstructorNotFound(System.Type,System.Type[],System.String)">
            <summary>
            <para>States that the service constructor specified by a given <see cref="T:Hca.Common.Service.ServiceConfig"/> could not be located.</para>
            <para><b>Message:</b> "Could not locate the service constructor [{0}({1})] specified by the {2} defined in {3}."</para>
            </summary>
            <param name="constructorType">The service type on which the constructor was expected.</param>
            <param name="constructorArgTypes">The types of the arguments defined.</param>
            <param name="configSource">The location of the ServiceConfig definition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCreationMethodException(System.Type,System.String,System.String,System.String)">
            <summary>
            <para>States that an exception occurred when attempting to execute the service creation method specified by a given <see cref="T:Hca.Common.Service.ServiceConfig"/>.</para>
            <para><b>Message:</b> "Could not execute the service creation method [{0}.{1}] specified by the {2} defined in {3}: {4}"</para>
            </summary>
            <param name="creationMethodDeclaringType">The type on which the service creation method was expected.</param>
            <param name="creationMethodName">The name of the service creation method.</param>
            <param name="configSource">The location of the ServiceConfig definition.</param>
            <param name="innerExceptionMessage">The message of the exception that occurred.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceConstructorException(System.Type,System.String,System.String)">
            <summary>
            <para>States that an exception occurred when attempting to execute the service constructor specified by a given <see cref="T:Hca.Common.Service.ServiceConfig"/>.</para>
            <para><b>Message:</b> "Could not execute the [{0}] service constructor specified by the {1} defined in {2}: {3}"</para>
            </summary>
            <param name="constructorType">The service type on which the constructor was expected.</param>
            <param name="configSource">The location of the ServiceConfig definition.</param>
            <param name="innerExceptionMessage">The message of the exception that occurred.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCantBeCreatedAsSingleton">
            <summary>
            <para>This key is used when a singleton service cannot be returned.</para>
            <para><b>Message:</b> "Unable to return singleton service."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceDoesNotSupportSingletonCreation">
            <summary>
            <para>This key is used when a service is attempted to be created as a singleton and the service does not support the single pattern.</para>
            <para><b>Message:</b> "Service appears to not be a singleton. Make sure singleton service has an Instance property."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.TimezoneInitializationInvalid(System.String,System.Object)">
            <summary>
            <para>This key is used when an initialization value for a time zone is not 
            valid.</para>
            <para><b>Message:</b> "The initialization value for the [{0}] is invalid. It can not be set to: [{1}]."</para>
            </summary>
            <param name="paramName">String (name) of what is invalid (i.e. "Timezone Identifier").</param>
            <param name="value"> The invalid value.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.TimezoneNotFound">
            <summary>
            <para>This key is used when a time zone identifier is not found in the predefined time zone list.</para>
            <para><b>Message:</b> "The timezone identifier could not be found in the predefined list of timezones."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.TypeUnexpected(System.Object,System.Type,System.String)">
            <summary>
            <para>This exception is used to designate a class is not of the expected type.</para>
            <para><b>Message:</b> "The Type [{0}] is not of the expected Type [{1}] for [{2}]."</para>
            </summary>
            <remarks>If <see langword="null"/> is passed, <see langword="null"/> is shown.</remarks>
            <param name="objSupplied">The Object that was supplied.</param>
            <param name="typeExpected">The Type Expected.</param>
            <param name="itemName">The name of the argument, property, field that has the wrong type.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.TypeNotAPrimitive(System.Type)">
            <summary>
            <para>Used when an argument is supposed to be a primitive type, but isn't.</para>
            <para><b>Message:</b> "The specified type is not a primitive type: [{0}]."</para>
            </summary>
            <param name="typeSupplied"> The (non-primitive) type of the object.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.TypeCantBeLoaded(System.Type)">
            <summary>
            <para>Used when the type with a given name could not be located.</para>
            <para><b>Message:</b> "The specified type could not be located: [{0}]."</para>
            </summary>
            <param name="typeSupplied">The Type supplied.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyDoesNotDefineType(System.String,System.Type)">
            <summary>
            <para>Used when no property with the specified name exists on a given type.</para>
            <para><b>Message:</b> "The type [{1}] has no property named [{0}]."</para>
            </summary>
            <param name="propertyName">The name of the property that was needed.</param>
            <param name="propertyType">The type of the property that was needed.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyTypeWrong(System.String,System.Type)">
            <summary>
            <para>Used when the value being assigned to a property is of the incorrect type.</para>
            <para><b>Message:</b> "The property [{0}] must be of (or derived from) type [{1}]."</para>
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="propertyType">The Type that must be provided.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyMustImplementInterface(System.String,System.Type)">
            <summary>
            <para>Used when a specified property type doesn't implement a required interface.</para>
            <para><b>Message:</b> "The type specified for property [{0}] must implement the [{1}] interface."</para>
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="interfaceType">The type of the interface that must be implemented.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyElementTypeWrong(System.String,System.Type)">
            <summary>
            <para>Used when an element in a list property is of the incorrect type.</para>
            <para><b>Message:</b> "The elements in property [{0}] must be of (or derived from) type [{1}]."</para>
            </summary>
            <param name="propertyName">The property name.</param>
            <param name="elementType">The type that the elements should be.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyKeyTypeWrong(System.String,System.Type)">
            <summary>
            <para>Used when the key in a dictionary property is of the incorrect type.</para>
            <para><b>Message:</b> "The keys in property [{0}] must be of (or derived from) type [{1}]."</para>
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="keyType">The type the key must be.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ArgumentValueOutOfRange(System.Object,System.Object,System.Object)">
            <overloads>
            Used when an argument value falls outside a valid range.
            </overloads>
            <summary>
            <para>Used when a specified argument value falls outside a valid range.</para>
            <para><b>Message:</b> "The value specified [{0}] falls outside the valid range [{1}-{2}]."</para>
            </summary>
            <param name="value">The Value specified.</param>
            <param name="minValue">The minimum allowed value(inclusive).</param>
            <param name="maxValue">The maximum allowed value(inclusive).</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ArgumentSpecifiedValueOutOfRange(System.String,System.Object,System.Object,System.Object)">
            <summary>
            <para>Used when an argument value falls outside a valid range.</para>
            <para><b>Message:</b> "The value specified or computed for [{0}] with value [{1}] falls outside the valid range [{2}-{3}]."</para>
            </summary>
            <param name="argumentName">The name of the argument that is out of range.</param>
            <param name="value">The Value specified.</param>
            <param name="minValue">The minimum allowed value(inclusive).</param>
            <param name="maxValue">The maximum allowed value(inclusive).</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ArgumentTypeWrong(System.String,System.Type,System.Type)">
            <summary>
            <para>Displayed when an argument is of the wrong type.</para>
            <para><b>Message:</b> "Argument [{0}] must be assignable to type [{1}]. (Actual type was [{2}].)"</para>
            </summary>
            <param name="argName">The name of the argument.</param>
            <param name="expectedType">The expected type of the argument.</param>
            <param name="actualType">The actual type of the argument.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.EmailAddressInvalid(System.String)">
            <summary>
            <para>Displayed when an email address is invalid.</para>
            <para><b>Message:</b> "Email address is not valid: [{0}]."</para> 
            </summary>
            <param name="emailValue">The value of the email address supplied.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.EmailAddressNamedInvalid(System.String,System.String)">
            <summary>
            <para>Displayed when an email address with alias name is invalid.</para>
            <para><b>Message:</b> "Email address [{0}] is not valid: [{1}]."</para> 
            </summary>
            <param name="emailName">The alias name of the email address.</param>
            <param name="emailValue">The email address provided.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.MachineNameCantBeLoaded(System.String)">
            <summary>
            <para>This key is used when the machine name can not be loaded from the environment.</para>
            <para><b>Message:</b> "The Machine Name can not be loaded from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.MachineNameAccessDenied(System.String)">
            <summary>
            <para>This key is used when the machine name can not be loaded due to security constraints.</para>
            <para><b>Message:</b> "Access is denied to acquire the Machine Name from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ThreadPrincipleCantBeLoaded(System.String)">
            <summary>
            <para>This key is used when the thread principle can not be loaded from the environment.</para>
            <para><b>Message:</b> "The Thread Principle can not be loaded from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ThreadPrincipleAccessDenied(System.String)">
            <summary>
            <para>This key is used when the thread principle can not be loaded due to security constraints.</para>
            <para><b>Message:</b> "Access is denied to acquire the Thread Principle from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.WindowsPrincipleCantBeLoaded(System.String)">
            <summary>
            <para>This key is used when the windows principle can not be loaded from the environment.</para>
            <para><b>Message:</b> "The Windows Principle can not be loaded from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.WindowsPrincipleAccessDenied(System.String)">
            <summary>
            <para>This key is used when the windows principle can not be loaded due to security constraints.</para>
            <para><b>Message:</b> "Access is denied to acquire the Windows Principle from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.AppDomainNameCantBeLoaded(System.String)">
            <summary>
            <para>This key is used when the application domain name can not be loaded from the environment.</para>
            <para><b>Message:</b> "The Application Domain Name can not be loaded from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.AppDomainNameAccessDenied(System.String)">
            <summary>
            <para>This key is used when the application domain name can not be loaded due to security constraints.</para>
            <para><b>Message:</b> "Access is denied to acquire the Application Domain Name from the environment due to cause [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ClassNotSerializable">
            <summary>
            <para>This key is used when an object is expected to be serializable but is not.</para>
            <para><b>Message:</b> "This class is not serializable, and this function requires a serializable object."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.DateInvalid(System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>This key is used when a date passed to a method or property is not 
            valid.</para>
            <para><b>Message:</b> "The date provided is not valid: [{1:MM}-{2:dd}-{0:yyyy}]."</para>
            </summary>
            <param name="year">Year provided.</param>
            <param name="month">Month provided.</param>
            <param name="day">Day provided.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.DateTimeInvalid(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>This key is used when a date-time passed to a method or property is not 
            valid.</para>
            <para><b>Message:</b> "The date-time provided is not valid: [{1:MM}-{2:dd}-{0:yyyy} {3:HH}:{4:mm}:{5:ss}.{6}]."</para>
            </summary>
            <param name="year">Year provided.</param>
            <param name="month">Month provided.</param>
            <param name="day">Day provided.</param>
            <param name="hour">Hour provided.</param>
            <param name="minute">Minute provided.</param>
            <param name="second">Second provided.</param>
            <param name="fractional">Fractional Seconds provided.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.DateResultingFromOperationInvalid">
            <summary>
            <para>This key is used when a date manipulation (add, subtract, etc.) results in an invalid date.</para>
            <para><b>Message:</b> "The result of this date modification is not valid."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.DateTimeStringInvalid(System.String)">
            <summary>
            <para>This key is used when a date-time passed to a method or property that takes a string value is not valid.</para>
            <para><b>Message:</b> "The string [{0}] is not a valid date representation."</para>
            </summary>
            <param name="dateTimeValue">The string passed as a date and time.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ValueTypeAssignedNull">
            <summary>
            <para>This exception is used when the default value supplied is <see langword="null"/> while the type it's supplied for is 
            a value type.</para>
            <para><b>Message:</b> "defaultValue cannot be null for a value type."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.DuplicateItemFound(System.Object)">
            <summary>
            <para>Used to indicate that a duplicate item was found.</para>
            <para><b>Message:</b> "A duplicate item [{0}] was found."</para>
            </summary>
            <param name="identifyingDetail">An object whose ToString will provide the details of the duplicate item.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ItemNotFound(System.Object)">
            <summary>
            <para>Used to indicate that a requested item was not found.</para>
            <para><b>Message:</b> "The requested item [{0}] was not found."</para>
            </summary>
            <param name="identifyingDetail">An object whose ToString will provide the details of the duplicate item.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyNotReadable(System.String)">
            <summary>
            <para>Used to indicate that a property is not readable.</para>
            <para><b>Message:</b> "Property [{0}] is not readable."</para>
            </summary>
            <param name="propertyName">The Name of the property that could not be read.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyNotWritable(System.String)">
            <summary>
            <para>Used to indicate that a property is not writable.</para>
            <para><b>Message:</b> "Property [{0}] is not writable."</para>
            </summary>
            <param name="propertyName">The Name of the property that could not be written.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyNotFound(System.String)">
            <summary>
            <para>Used to indicate that a property is missing.</para>
            <para><b>Message:</b> "Property [{0}] not found."</para>
            </summary>
            <param name="propertyName">The property that could not be found.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.PropertyRequiresValue(System.String)">
            <summary>
            <para>Used when a property must be valued and the value is not present.</para>
            <para><b>Message:</b> "Property [{0}] requires a value."</para>
            </summary>
            <param name="propertyName">The property that requires a value.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ArgumentValueInvalid(System.Object,System.String)">
            <summary>
            <para>Used when a value for an argument is invalid</para>
            <para><b>Message:</b> "The value [{0}] for argument [{1}] is invalid."</para>
            </summary>
            <param name="value">The value that was invalid.</param>
            <param name="argumentName">The name of the argument that was invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ValidationError(System.Object,System.Int32)">
            <summary>
            <p>Used when an object fails validation.</p>
            <p><b>Message:</b> "Validation failed for type [{0}] with [{1}] error(s)."</p>
            </summary>
            <param name="valueInError">The object that has errors</param>
            <param name="errorCount">The number of errors encountered during validation.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ValidationError(System.Int32)">
            <summary>
            <p>Used by the default Constructor of the <see cref="T:Hca.Common.BaseException.ValidationException"/> when an object fails validation.</p>
            <p><b>Message:</b> "Validation failed with [{1}] error(s)."</p>
            </summary>
            <param name="errorCount">The number of errors encountered during validation.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.CantLogException">
            <summary>
            <para>This key is used when the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> cannot log an exception anywhere.</para>
            <para><b>Message:</b> "Could not log exception to HcaLogger, Windows Event Log, or Console."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceTypeArgsPrecludesCreationMethod">
            <summary>
            <para>This message is used when a <see cref="T:Hca.Common.Service.ServiceConfig"/> is internally invalid.</para>
            <para><b>Message:</b> "It is an error to specify both ServiceTypeArgs along with ServiceCreationMethod and/or ServiceCreationMethodArgs."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceCreationMethodArgsRequiresMethod">
            <summary>
            <para>This message is used when a <see cref="T:Hca.Common.Service.ServiceConfig"/> is internally invalid.</para>
            <para><b>Message:</b> "It is an error to specify ServiceCreationMethodArgs without specifying ServiceCreationMethod."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ServiceImpersonationRequiresDefaultStack">
            <summary>
            <para>This message is used when a <see cref="T:Hca.Common.Service.ServiceConfig"/> is internally invalid.</para>
            <para><b>Message:</b> "The default interceptor stack must be enabled to specify an account for impersonation."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ExceptionConfigurationNotDefined">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.BaseException.HcaExceptionHelper"/> to report a missing configuration.</para>
            <para><b>Message:</b> "Exception configuration information was not defined, defaulting values with context name of [exception]."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.CouldNotLoadMessage(System.String,System.String)">
            <summary>
            <para>This message is used by when a requested resource message cannot be found.</para>
            <para><b>Message:</b> "Could not load specified message resource [{0}] from resource context [{1}]."</para>
            <para><b>Parameters:</b></para>
            </summary>
            <param name="resource">The name of the message resource.</param>
            <param name="context">The context of the requested resource.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.ConfigurationReloadException">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.Configuration.Store.ConfigStore"/> when a configuration reload throws an exception.</para>
            <para><b>Message:</b> "Unable to reload configuration."</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.UnexpectedExceptionLoadingMessage(System.String,System.String)">
            <summary>
            <para>This message is used when an unexpected exception occurs loading a resource.</para>
            <para><b>Message:</b> "Unexpected exception encountered loading specified message resource [{0}] from resource context [{1}]."</para>
            </summary>
            <param name="resource">The name of the message resource.</param>
            <param name="context">The context of the requested resource.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.CouldNotLoadDefaultMessage(System.String,System.String)">
            <summary>
            <para>This message is used when the default message for a type cannot be found.</para>
            <para><b>Message:</b> "Could not load default message resource for type [{0}] from resource context [{1}]."</para>
            </summary>
            <param name="typename">The full name of the type.</param>
            <param name="context">The context of the resource.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ExceptionMessage.UnexpectedExceptionLoadingDefaultMessage(System.String,System.String)">
            <summary>
            <para>This message is used when an exception occurs while loading the default message.</para>
            <para><b>Message:</b> "Unexpected exception encountered loading default message resource for type [{0}] from resource context [{1}]."</para>
            </summary>
            <param name="typename">The full name of the type.</param>
            <param name="context">The context of the resource.</param>
        </member>
        <member name="P:Hca.Common.BaseException.ExceptionMessage.ExceptionResourceContextName">
            <summary>
            Return the resource context name that is being used to find
            exception messages.
            </summary>
        </member>
        <member name="T:Hca.Common.BaseException.HcaArgumentException">
            <summary>
            This exception wraps the .NET ArgumentException. As such this exception should only be used when representing a 
            condition where an argument is provided to a call and that value is unexpected for the range of normal values.
            </summary>
            <threadsafety static="true" instance="false"/>
            <seealso cref="T:System.ArgumentException"/>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaArgumentException"/>
            is by default marked as nonrecoverable as is typical of system exceptions. 
            When considering whether to use this exception, prefer the use of <see cref="T:Hca.Common.BaseException.InvalidDataException"/> in cases where 
            a user has provided bad data but could correct the input to avoid the exception condition.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.#ctor">
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the msg is <see langword="null"/>, the exception name will be used to locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaArgumentException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This exception wraps the .NET ArgumentException. As such this exception should only be used when representing a 
            condition where an argument is provided to a call and that value is unexpected for the range of normal values.
            </summary>
            <threadsafety static="true" instance="false"/>
            <seealso cref="T:System.ArgumentException"/>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaArgumentException"/>
            is by default marked as nonrecoverable as is typical of system exceptions. 
            When considering whether to use this exception, prefer the use of <see cref="T:Hca.Common.BaseException.InvalidDataException"/> in cases where 
            a user has provided bad data but could correct the input to avoid the exception condition.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaArgumentException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This exception wraps the .NET ArgumentException. As such this exception should only be used when representing a 
            condition where an argument is provided to a call and that value is unexpected for the range of normal values.
            </summary>
            <threadsafety static="true" instance="false"/>
            <seealso cref="T:System.ArgumentException"/>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaArgumentException"/>
            is by default marked as nonrecoverable as is typical of system exceptions. 
            When considering whether to use this exception, prefer the use of <see cref="T:Hca.Common.BaseException.InvalidDataException"/> in cases where 
            a user has provided bad data but could correct the input to avoid the exception condition.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current machine's 
            time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. 
            This is composed of the <see cref="P:Hca.Common.BaseException.HcaArgumentException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaArgumentException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaArgumentException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaArgumentException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaConfigurationException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Configuration.ConfigurationException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaConfigurationException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.#ctor">
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the msg is <see langword="null"/>, the exception name will be used to locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaConfigurationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Configuration.ConfigurationException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaConfigurationException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaConfigurationException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Configuration.ConfigurationException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaConfigurationException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current 
            machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. 
            This is composed of the <see cref="P:Hca.Common.BaseException.HcaConfigurationException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaConfigurationException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaConfigurationException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaConfigurationException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaExceptionHelper">
            <summary>This class provides the functionality for implementing <see cref="T:Hca.Common.BaseException.IHcaException"/>. 
            Delegate to it if you must create a new exception which does not inherit from <see cref="T:Hca.Common.BaseException.HcaApplicationException"/>.
            </summary>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.defaultLogLevel">
            <summary>
            Default Log Level is Warn.
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.includeStackTraceDefault">
            <summary>
            This is the default value for whether stack traces should be included
            when logging an exception. This value should be read from the config.
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.defaultHelpLink">
            <summary>
            The default location for exception help documentation. If none
            defined this will be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.owner">
            <summary>The exception object this instance is helping.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.message">
            <summary>The formatted message to return for this exception</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.hostName">
            <summary>The host where the exception occurred.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.appDomainName">
            <summary>The Application domain where the exception occurred</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.userThreadIdentity">
            <summary>The user identity as known to the current thread where the 
            exception occurred.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.userWindowsIdentity">
            <summary>The user identity as known to the current windows subsystem.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.creationUtcTicks">
            <summary>The ticks in UTC of when this exception occurred</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.loggingLevel">
            <summary>The level at which to log this exception. By default all 
            exceptions are logged at Warn level. If a client desires a different 
            level they can set it after instantiation to the level needed before 
            throwing it back to the invoker.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.includeStackTrace">
            <summary>If <see langword="true"/>, the stack trace is included for this exception when logged.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.isLogged">
            <summary>True if this exception has been logged.</summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.logException">
            <summary>
            If <see langword="false"/>, this exception should not be logged unless it is explicitly
            logged through a method that always logs the exception.
            </summary>
        </member>
        <member name="F:Hca.Common.BaseException.HcaExceptionHelper.isRecoverable">
            <summary>
            If <see langword="true"/>, client can provide input to recover from exception condition. Otherwise
            client must have external intervention.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#cctor">
            <summary>Static constructor to set configuration information.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#ctor(System.Exception)">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.HcaExceptionHelper"/>.</overloads>
            <summary>Constructor</summary>		
            <param name="owner">The exception object this instance will be helping.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#ctor(System.Exception,Hca.Common.BaseException.ExceptionMessage)">
            <summary>Constructor that takes the key as an argument</summary>
            <param name="owner">The exception object this instance will be helping.</param>
            <param name="msg">The message to display</param>
            <remarks>The <paramref name="owner"/> parameter should implement <see cref="T:Hca.Common.BaseException.HcaExceptionHelper.IExtendsToString"/> 
            if the class has extended members which should be included by <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#ctor(System.Exception,System.Exception)">
            <summary>Constructor that takes the cause of the exception as an argument.</summary>
            <param name="owner">The exception object this instance will be helping.</param>
            <param name="innerException">The cause of the exception</param>
            <remarks>The <paramref name="owner"/> parameter should implement <see cref="T:Hca.Common.BaseException.HcaExceptionHelper.IExtendsToString"/> 
            if the class has extended members which should be included by <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#ctor(System.Exception,System.Exception,Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor. If the key is <see langword="null"/>, and a cause is present, the causes message 
            will be used for the message of the exception. Otherwise, the generic message based 
            on this class is used.</summary>
            <param name="owner">The exception object this instance will be helping.</param>
            <param name="innerException">The Exception that caused this exception</param>
            <param name="msg">The message to display</param>
            <remarks>The <paramref name="owner"/> parameter should implement <see cref="T:Hca.Common.BaseException.HcaExceptionHelper.IExtendsToString"/> 
            if the class has extended members which should be included by <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.PrintStackTrace">
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString">
            <overloads>Provides a human-readable ToString that includes the details of this exception.</overloads>
            <summary>Provides a human-readable ToString that includes the details of this exception. 
            This method provides full output of the object.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString(System.String,System.IFormatProvider)">
            <summary>This method provides specialized formatting of an exception based on the passed symbol in the format argument.</summary>
            <param name="format">The format string</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A string representation of the object.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format based on include stack trace flag
            is either like V or VS format.
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString), this ignores include stack trace flag on exception
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any, this ignores include stack trace flag on exception
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any, this ignores include stack trace flag on exception
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.ToString">
            <summary>Throws a <see cref="T:System.NotSupportedException"/>.</summary>
            <returns>Not applicable.</returns>
            <exception cref="T:System.NotSupportedException">Thrown whenever this method is called.</exception>
            <remarks>To avoid accidental confusion with <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>, this method always throws an exception.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Implement the GetObjectData method to serialize custom values.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.PopulateEnvironmentValues(System.String@,System.String@,System.String@,System.String@)">
            <summary>
            Retrieves <paramref name="hostName" />, <paramref name="appDomainName" />, <paramref name="userThreadIdentity" /> 
            and <paramref name="userWindowsIdentity" /> from the environment.
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.DefaultLogLevel">
            <summary>
            Return the default log level used to log exceptions.
            </summary>
            <returns><see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/></returns>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.DefaultHelpLink">
            <summary>
            Return the default location for exception help documentation. If none
            defined this will be <see langword="null"/>.
            </summary>
            <returns><see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/></returns>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current 
            machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.UniqueId">
            <summary>
            Gets a unique id that can be used to correlate this exception to any 
            other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.HcaExceptionHelper.HostName"/>, 
            <see cref="P:Hca.Common.BaseException.HcaExceptionHelper.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaExceptionHelper.CreationUtcTicks"/>.
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.LoggingLevel">
            <summary>
            Gets or sets the logging level set for this exception.
            </summary>
            <remarks>
            Default: <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when 
            logging this exception.
            </summary>
            <remarks>
            Default: <see langword="true"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.IsLogged">
            <summary>
            Gets or set whether this exception has been logged.
            Default: <see langword="false"/>
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.LogException">
            <summary>
            Gets or sets whether this exception should be logged.
            </summary>
            <remarks>
            If <see langword="true"/>, normal logging behavior occurs based on the <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/>
            property and the alwaysLog flag if using the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>.
            Otherwise, if this property is set to <see langword="false"/>, the exception will
            only be logged if explicitly asked to be logged (e.g. by setting
            the alwaysLog flag on <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> to <see langword="true"/>.)
            Default: <see langword="true"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaExceptionHelper.IsRecoverable">
            <summary>
            Gets or sets whether this exception can be recovered from by client input.
            </summary>
            <remarks>
            <para>Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.</para>
            Default: 
            SystemException derived exceptions -&gt; <see langword="false"/>
            ApplicationException derived exceptions -&gt; <see langword="true"/>
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaExceptionHelper.IExtendsToString">
            <summary>
            Used to indicate that an <see cref="T:Hca.Common.BaseException.HcaExceptionHelper"/>'s owner wishes to 
            supply additional detail when it calls <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaExceptionHelper.IExtendsToString.AppendToStringExtensions(System.Boolean,System.IFormatProvider,System.Text.StringBuilder)">
            <summary>Supplies additional detail to <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.</summary>
            <param name="includeVerbose">Whether <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>'s caller requested verbose output.</param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> passed to <see cref="M:Hca.Common.BaseException.HcaExceptionHelper.BuildToString"/>.</param>
            <param name="target">The <see cref="T:System.Text.StringBuilder"/> being used to build the string.</param>
            <remarks>Implementations should append extended members to the <paramref name="target"/> as name-value pairs, one per line.</remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaInvalidOperationException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An 
            <see cref="T:Hca.Common.BaseException.HcaInvalidOperationException"/> by default is considered to be nonrecoverable. As needed an exception handler may 
            reset this default state via the <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user 
            to provide input to resolve the exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.#ctor">
            <overloads>Initializes a new instance of a <see cref="T:Hca.Common.BaseException.HcaInvalidOperationException"/>.</overloads>
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the msg is <see langword="null"/>, the exception name will be used to locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaInvalidOperationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An 
            <see cref="T:Hca.Common.BaseException.HcaInvalidOperationException"/> by default is considered to be nonrecoverable. As needed an exception handler may 
            reset this default state via the <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user 
            to provide input to resolve the exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaInvalidOperationException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This exception wraps the .NET native <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An 
            <see cref="T:Hca.Common.BaseException.HcaInvalidOperationException"/> by default is considered to be nonrecoverable. As needed an exception handler may 
            reset this default state via the <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user 
            to provide input to resolve the exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current 
            machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. 
            This is composed of the <see cref="P:Hca.Common.BaseException.HcaInvalidOperationException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaInvalidOperationException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaInvalidOperationException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaInvalidOperationException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaNotSupportedException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.NotSupportedException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaNotSupportedException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.HcaNotSupportedException"/>.</overloads>
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the <paramref name="msg"/> is <see langword="null"/>, the exception name 
            will be used to locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaNotSupportedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.NotSupportedException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaNotSupportedException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaNotSupportedException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This exception wraps the .NET native <see cref="T:System.NotSupportedException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaNotSupportedException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.HcaNotSupportedException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaNotSupportedException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaNotSupportedException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaNotSupportedException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaSecurityException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Security.SecurityException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSecurityException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.HcaSecurityException"/>.</overloads>
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the <paramref name="msg"/> is <see langword="null"/>, the exception name will be used to 
            locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaSecurityException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Security.SecurityException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSecurityException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.HcaSecurityException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This exception wraps the .NET native <see cref="T:System.Security.SecurityException"/>
            </summary>
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSecurityException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.HcaSecurityException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaSecurityException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaSecurityException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSecurityException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.HcaSystemException">
            <summary>
            This class provides the base for all system defined exceptions within the 
            HCA framework. It adds to the set of detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSystemException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.HcaSystemException"/>.</overloads>
            <summary>Default Constructor</summary>		
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>Constructor that takes the message of the exception</summary>
            <remarks>If the <paramref name="msg"/> is <see langword="null"/>, the exception name will be used to 
            locate a suitable key for the exception.</remarks>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.#ctor(System.Exception)">
            <summary>Constructor that takes the cause of the exception.</summary>
            <param name="cause">The cause of the exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>Constructor that takes the message and cause of the exception.</summary>
            <remarks>
            If the <paramref name="msg"/> is <see langword="null"/>, the cause's exception name will be used to 
            locate a suitable message for the exception.
            If the <paramref name="cause"/> is <see langword="null"/>, the thrown exception will be used to 
            locate a suitable message for the exception.
            </remarks>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor used for deserialization of the exception class.</summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.PrintStackTrace">
            <overloads>Print the stack trace.</overloads>
            <summary>Print the stack trace (including that of the inner exception) to the standard error writer.</summary>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.PrintStackTrace(System.IO.TextWriter)">
            <summary>Print the stack trace (including that of the inner exception) to the supplied writer.</summary>
            <param name="writer">The writer to which to send output.</param>
            <remarks>If the passed writer is <see langword="null"/>, the standard error writer is used.</remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.ToString">
            <overloads>Provides a string representation of this exception</overloads>
            <summary>Provides a string representation of this exception. Equivalent to <c>ToString("G", null)</c>.</summary>
            <returns>A human-readable string representation of the object.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.ToString(System.String,System.IFormatProvider)">
            <summary>Provides a string representation of this exception with optionally customized level of detail.</summary>
            <param name="format">The format string specifying the level of detail to include.</param>
            <param name="formatProvider">The provider as passed from the .NET framework</param>
            <returns>A human-readable string representation of the object with the specified level of detail.</returns>
            <remarks>
            <para>
            <list type="table">
            <item>
            <term>G</term>
            <description>
            (default if not specified) the general format (a full ToString)
            </description>
            </item>
            <item>
            <term>V</term>
            <description>
            the verbose format (a full ToString)
            </description>
            </item>
            <item>
            <term>T</term>
            <description>
            a terse format that only supplies the exception name, source, method,
            unique id and message.
            </description>
            </item>
            <item>
            <term>VS</term>
            <description>
            Like V but includes the stack trace if any.
            </description>
            </item>
            <item>
            <term>TS</term>
            <description>
            Like T but includes the stack trace if any.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.HcaSystemException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.Hca#Common#BaseException#IHcaException#get_InnerException">
            <summary>
            This class provides the base for all system defined exceptions within the 
            HCA framework. It adds to the set of detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSystemException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseException.HcaSystemException.Hca#Common#BaseException#IHcaException#get_TargetSite">
            <summary>
            This class provides the base for all system defined exceptions within the 
            HCA framework. It adds to the set of detail available through Exception.
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            Refer to <see cref="T:Hca.Common.BaseException.IHcaException"/> for details on provided properties and their meaning. An <see cref="T:Hca.Common.BaseException.HcaSystemException"/> 
            by default is considered to be nonrecoverable. As needed an exception handler may reset this default state via the
            <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> property if it is possible for a user to provide input to resolve the
            exception condition.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.Message">
            <summary>Overrides Exception's message property so that we use a formatted message.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.HostName">
            <summary>Gets the host name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.AppDomainName">
            <summary>Gets the application domain name where this exception occurred.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.UserThreadIdentity">
            <summary>Gets the user principle as known to the current thread.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.UserWindowsIdentity">
            <summary>Gets the user principle as known to the windows subsystem.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.CreationUtcTicks">
            <summary>Gets the creation time as a tick count elapsed since 12:00 A.M., January 1, 0001 UTC</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.CreationUtcTime">
            <summary>Gets a DateTime structure initialized to the UTC creation time of this exception.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.CreationLocalTime">
            <summary>Gets a DateTime structure initialized to the local creation time of this exception using the current machine's time zone and daylight savings time settings.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.UniqueId">
            <summary>Gets a unique id that can be used to correlate this exception to any other in the system. This is composed of the <see cref="P:Hca.Common.BaseException.HcaSystemException.HostName"/>, <see cref="P:Hca.Common.BaseException.HcaSystemException.AppDomainName"/>, and <see cref="P:Hca.Common.BaseException.HcaSystemException.CreationUtcTicks"/>.</summary>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.LoggingLevel">
            <summary>Gets or sets the logging level set for this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LoggingLevel"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.IncludeStackTrace">
            <summary>Gets or set whether stack traces should be included when logging this exception.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IncludeStackTrace"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.IsLogged">
            <summary>Gets or set whether this exception has been logged.</summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsLogged"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.LogException">
            <summary>
            Gets or sets whether this exception is subject to logging.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> for details.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.HcaSystemException.IsRecoverable">
            <summary>
            Gets or sets whether this exception is recoverable by the user.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.BaseException.IHcaException.IsRecoverable"/> for details.
            </remarks>
        </member>
        <member name="T:Hca.Common.BaseException.InvalidDataException">
            <summary>
            This exception represents the condition where data is not valid. It should be thrown when arguments from an end-user
            invocation are invalid but could be corrected if the user submitted correct values.
            </summary>
            <remarks>
            This exception represents the condition where an argument is provided that is not acceptable to an operation. 
            It should be thrown when a mandatory value is not present or a field value is not within range of the valid set 
            of values for some field. In particular, this exception is typically thrown when a value/transfer object is used
            to update an entity where the values of that transfer object are not complete or invalid as determined through 
            validation.
            </remarks>
            <seealso cref="T:Hca.Common.BaseException.HcaApplicationException"/>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.InvalidDataException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.InvalidDataException"/>.</overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.InvalidDataException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes the message for the exception.
            </summary>
            <param name="msg">The message key to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.InvalidDataException.#ctor(System.Exception)">
            <summary>
            Constructor that takes a cause.
            </summary>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.InvalidDataException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Constructor that takes the message and cause.
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.InvalidDataException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor. This is used when reconstituting a serialized object.
            </summary>
            <param name="info">the serialized object information</param>
            <param name="context">the context</param>
        </member>
        <member name="T:Hca.Common.BaseException.ItemNotFoundException">
            <summary>
            This exception represents the condition where an item is requested and that item cannot be found.
            </summary>
            <remarks>
            Generally this exception will be used when attempting to retrieve an item from a data store or collection and the 
            item cannot be located. Since not finding an item might be expected (e.g. add of a new item), a client might
            handle this exception by consuming it.
            </remarks>
            <seealso cref="T:Hca.Common.BaseException.HcaApplicationException"/>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.BaseException.ItemNotFoundException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.BaseException.ItemNotFoundException"/>.</overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.ItemNotFoundException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes the message for the exception.
            </summary>
            <param name="msg">The message key to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.ItemNotFoundException.#ctor(System.Exception)">
            <summary>
            Constructor that takes the cause for this exception
            </summary>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ItemNotFoundException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Constructor that takes the message and cause.
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ItemNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor. This is used when reconstituting a serialized object.
            </summary>
            <param name="info">the serialized object information</param>
            <param name="context">the context</param>
        </member>
        <member name="T:Hca.Common.BaseException.NamespaceDoc">
             <summary>
             	<h2 class="dtH2">Overview</h2>
             	This section describes the requirements that shaped the design and implementation of the 
             	Exception Framework. Base exception classes can be found in the 
             	<see cref="N:Hca.Common.BaseException"/> namespace.
             
             	<h3 class="dtH3">References</h3>
             	The following works are referenced in this SDK:
             	<para/>
             	<i>Table 1: Referenced Works</i>
             	<br/>
             	<div class="tablediv">
             		<table class="dtTABLE" cellspacing="0" width="100%">
             			<tr valign="top">
             				<th width="20%">Label</th>
             				<th width="50%">Title</th>
             				<th width="30%">Reference</th>
             			</tr>
             			<tr>
             				<td>Config</td>
             				<td>Configuration Framework Usage section</td>
             				<td>Included in <see cref="N:Hca.Common.Configuration"/>.</td>
             			</tr>
             			<tr>
             				<td>Resource</td>
             				<td>Resource Usage section</td>
             				<td>Included in <see cref="N:Hca.Common.Resource"/>.</td>
             			</tr>
             		</table>
             	</div>
             
             	<h3 class="dtH3">Requirements</h3>
             	The following requirements describe the constraints and functional needs placed on the 
             	framework:
             	<para/>
             	<list type="bullet">
             		<item>
             			Resource driven message files that support user definition outside of code and 
             			internationalization of text.
             		</item>
             		<item>
             			Ability to specify resource message bundles that take precedence over currently 
             			defined bundles so that an application can provide specialized messages for 
             			exceptions that are defined in other libraries.
             		</item>
             		<item>
             			Unique identification of an exception so it can be correlated even across tiers. 
             			This should include at minimum the target machine where the exception was thrown 
             			and the time of the exception.
             		</item>
             		<item>
             			Support to allow an exception to be implicitly logged only once even if thrown up 
             			a chain of invocations.
             		</item>
             		<item>Support for specifying the level that an exception is logged.</item>
             		<item>Support to specify whether a stack trace is captured for logging.</item>
             		<item>
             			Support for marking an exception as <i>do-not-log</i> such that it will only be 
             			logged if explicitly written.
             		</item>
             		<item>Support for the chaining of exceptions.</item>
             		<item>Support for marking an exception as recoverable.</item>
             		<item>
             			Mechanism to handle exceptions in code such that they meet the above requirements 
             			without the developer having to ensure the above characteristics.
             		</item>
             	</list>
             
             	<h3 class="dtH3">Tenets</h3>
             	Exceptions can be processed in many ways. The framework classes described in this SDK are 
             	bound by design tenets listed here: 
             	<para/>
             	<list type="bullet">
             		<item>Exceptions should be handled close to the source of emission.</item>
             		<item>Handling of exceptions should include logging of contents to a durable store.</item>
             		<item>
             			Exceptions should be explicitly handled at boundary points. A boundary in this 
             			sense is any place where the call is returning from one tier to another. This is 
             			especially true if the returning call is remote. In addition, users should consider 
             			whether calls that cross layers within an application should also have explicit 
             			handling.
             		</item>
             		<item>
             			Defining a new exception class should only be considered if the semantics of the 
             			exception would cause an application to take a different action when that 
             			exception is encountered. Otherwise, if the need of an application is to only 
             			provide different text, the use of a base exception class with the needed message 
             			as a resource key is mandated. The goal here is to minimize the explosion of 
             			exceptions that might be defined.
             			<note>
             				A good <i>rule of thumb</i> when determining whether to define a new exception 
             				or use an existing one is:
             				<blockquote>
             					If you can define a state (the exception to be defined) in a state machine 
             					such that you could specify different transition actions when that exception 
             					was evaluated, you probably should define that exception.
             				</blockquote>
             			</note>
             		</item>
             		<item>
             			Exceptions thrown from a method should be at the same level of abstraction as that 
             			method. For example, throwing an <see cref="T:System.IO.IOException"/> from a call 
             			to list all customers with the last name of Doe would be discouraged.
             		</item>
             		<item>
             			If an HCA exception class (i.e., one that implements <see cref="T:Hca.Common.BaseException.IHcaException"/>) 
             			is intended to duplicate the semantics of an existing exception defined in another 
             			library, the new class must inherit the existing exception and reuse its name with 
             			the added prefix <c>Hca</c>. This communicates the intention to replace the other 
             			exception, while avoiding ambiguity that might otherwise require namespace 
             			qualification.
             		</item>
             		<item>
             			All HCA exceptions must be marked with <see cref="T:System.SerializableAttribute"/> 
             			and implement the corresponding constructor. If the exception adds serializable 
             			information, they must also override <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method.
             		</item>
             	</list>
             
             	<h2 class="dtH2">Design</h2>
             	
             	<h3 class="dtH3">ExceptionMessage</h3>
             	<see cref="T:Hca.Common.BaseException.ExceptionMessage"/> provides access to configurable exception resource messages residing 
             	outside of application code. <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> is derived 
             	from <see cref="T:Hca.Common.Resource.ResourceMessage"/> which uses an <see cref="T:Hca.Common.Resource.HcaResourceManager"/> 
             	when <see cref="M:Hca.Common.Resource.ResourceMessage.ToString">ResourceMessage.ToString</see> is called. This
             	provides convenient encapsulation of the context, arguments, and behavior around retrieving a message from a resource store.
             	Use of <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> is the recommended way to retreive resources messages for 
             	exception handling. 
             	
             	<h3 class="dtH3">HcaApplicationException Class</h3>
             	The framework provides a single base exception type that all user exceptions must derive: 
             	<see cref="T:Hca.Common.BaseException.HcaApplicationException"/>. This class extends <see cref="T:System.ApplicationException"/> 
             	of the .NET framework, leveraging the detail captured by that class.
             	<para/> 
             	This class provides several overloaded constructors for creating an exception. Consequently, 
             	most any situation is covered and an artificial value does not have to be provided. For 
             	example, beyond the no argument default constructor, the next most common constructor form 
             	is passing a message key. 
             	<para/>
             	This class adds a formatted message via an <see cref="T:Hca.Common.BaseException.ExceptionMessage"/>, 
             	which is loaded at runtime from a resource file. The goal is that no user defined messages for exceptions 
             	are found as literals in code when using this framework. The only exception to this rule is for classes within the Common 
             	framework on which this namespace depends. To accomplish the load of messages for keys 
             	defined in Common, <see langword="static"/> methods which correspond to the resource key names
             	are defined in <see cref="T:Hca.Common.BaseException.ExceptionMessage"/>.
             	<see cref="T:Hca.Common.BaseException.ExceptionMessage"/> calls <see cref="T:Hca.Common.Resource.HcaResourceManager"/> which uses 
             	these keys to load the actual message for the exception. This allows culture information to be 
             	accounted for so that machines running a different language can show an appropriate message. 
             	Additionally, if the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> does not find the 
             	given key, the framework defaults to a general message for the thrown exception based on 
             	the exception's fully qualified name. However, if the key passed is <see langword="null"/> and a cause is present, the 
             	cause's message will be used instead of the default message. This case is typical when the 
             	exception handler implicitly wraps a .NET exception. It is also possible for applications 
             	to override a message found in an existing resource bundle by providing new key definitions 
             	in a different resource (i.e. another dll that contains the new key and message). This 
             	ensures that existing assemblies or satellite resource DLLs do not have to be modified just 
             	to change an existing message. Setup and configuration of these resources is discussed in 
             	more detail in <see cref="N:Hca.Common.Resource"/>.
             	<para/>
             	The properties of this class declare where and when the exception occurred and why it might 
             	have happened. The goal is to gather as much useful information as possible to help discern 
             	the cause of the problem. This information can be particularly useful when dealing with 
             	exceptions found in logs that span physical machines.
             	<para/>
             	This class uses <see cref="T:Hca.Common.BaseException.ExceptionConfig"/> through 
             	<see cref="T:Hca.Common.Configuration.ConfigFactory"/> to load default information valued on 
             	new instances of an exception. This configuration information is explained in detail in 
             	<see cref="N:Hca.Common.Configuration"/>.
             
             	<h3 class="atH3">ExceptionHandler</h3>
             	<see cref="T:Hca.Common.BaseException.ExceptionHandler"/> provides methods to handle exceptions 
             	by appropriately logging them and returning either the passed  <see cref="T:Hca.Common.BaseException.IHcaException"/> 
             	or wrapping a system (non - <see cref="T:Hca.Common.BaseException.IHcaException"/>) exception in the 
             	appropriate <see cref="T:Hca.Common.BaseException.IHcaException"/> based on the original <see cref="T:System.Exception"/> type. 
             	The result is that the returned exception can always be cast to the 
             	richer <see cref="T:Hca.Common.BaseException.IHcaException"/>. Two general methods are provided by this class: 
             	<list type="number">
             		<item><see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/></item>
             		<item><see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type)"/></item>
             	</list>
             	<para/>
             	<list type="bullet">
             		<item>
             			The first method is designed as the normal method to be called when dealing with 
             			exceptions. It gives the caller several overloaded forms, which should suit any 
             			calling condition based on the information present and the amount of control 
             			desired in how the exception is handled. 
             		</item>
             		<item>
             			The second method is used when an exception is to be marshaled across a tier or 
             			between subsystem layers. The intent of this method is to distinguish between 
             			ordinary use and cross-tier use so that if special processing or handling is needed 
             			in the second case, the first case does not have to be encumbered by any processing 
             			overhead. 
             		</item>
             	</list> 
             	<para/>
             	Currently, the only difference between the two methods is that the exception is always logged 
             	in the latter case and conditionally logged in the former. 
             	<para/>
             	The handler processes messages by assessing several factors:
             	<list type="bullet">
             		<item>Has the thrown exception been logged?</item>
             		<item>If an inner exception is contained, has it been logged?</item>
             		<item>
             			Does the client want the exception to be logged regardless of whether it has 
             			been previously logged?
             		</item>
             		<item>What logging level needs to be set for the exception to be logged?</item>
             		<item>
             			Is the exception a framework/user defined exception or system exception that 
             			needs to be wrapped?
             		</item>
             	</list>
             	<para/>
             	Figure 1 shows an activity diagram that illustrates how the exception handler considers 
             	the above factors.
             	<para/>
             	<img src="exception_handler_activity_diagram.gif"/>
             	<br/>
             	<i>Figure 1: Exception Handler Activity Diagram</i>
             	<para/>
             	This class uses the <see cref="T:Hca.Common.Logger.HcaLogger"/> class to handle all logging 
             	concerns. However, in an extreme case where a log instance could not be acquired, this 
             	class logs messages to both the <c>EventLog</c> and <c>Console</c>. If the handler receives 
             	a denied security access situation when writing to the application's <c>EventLog</c>, it 
             	backs off to the system application log, which should always be present. 
             	<para/>
             	The overloaded handler methods enable the client to override the default behavior, including:  
             	<list type="bullet">
             		<item>Forcing the log of a caught exception</item>
             		<item>Changing the logging level</item>
             		<item>
             			Supplying an <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> to provide the desired message for a .NET SDK 
             			exception or to provide supplemental information to the caught exception. 
             		</item>
             	</list>
             	<para/>
             	Figure 2 shows the above-mentioned classes, which form the Exception framework.
             	<para/>
             	<img src="exception_class_diagram.gif"/>
             	<br/>
             	<i>Figure 2: Exception Framework Class Diagram</i>
             
             	<h2 class="dtH2">Usage</h2>
             	This section describes how to configure, create and handle exceptions using the classes 
             	that encompass the Exception Framework.
             
             	<h3 class="dtH3">Configuration</h3>
             	The Exception Framework defines its configuration information in the 
             	<see cref="T:Hca.Common.BaseException.ExceptionConfig"/> class. Table 2 details its properties.
             	<para/>
             	<i>Table 2: Exception Configuration Properties</i>
             	<br/>
             	<div class="tablediv">
             		<table class="dtTABLE" cellspacing="0" width="100%">
             			<tr valign="top">
             				<th width="25%">Property Name</th>
             				<th width="50%">Description</th>
             				<th width="15%">Required?</th>
             				<th width="15%">Default</th>
             			</tr>
             			<tr valign="top">
             				<td><see cref="P:Hca.Common.BaseException.ExceptionConfig.IncludeStackTrace"/></td>
             				<td>
             					Indicates whether a stack trace should be included when the exception is 
             					logged. This value is used as the default for all instances of an 
             					<see cref="T:Hca.Common.BaseException.HcaApplicationException"/> or derived 
             					class.
             				</td>
             				<td>No</td>
             				<td>false</td>
             			</tr>
             			<tr valign="top">
             				<td><see cref="P:Hca.Common.BaseException.ExceptionConfig.ContextName"/></td>
             				<td>
             					Indicates the name to be used when requesting exception messages from the 
             					resource manager.
             				</td>
             				<td>Yes</td>
             				<td>Must be specified</td>
             			</tr>
             			<tr valign="top">
             				<td><see cref="P:Hca.Common.BaseException.ExceptionConfig.HelpLink"/></td>
             				<td>
             					Indicates an URL to be used that provides additional help information about 
             					exceptions for this context. This value is used as the default for all 
             					instances of <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> 
             					or derived class.
             				</td>
             				<td>No</td>
             				<td>Unspecified</td>
             			</tr>
             		</table>
             	</div>
             	<para/>
             	These properties are used internal to the exception framework and the configuration class 
             	is embedded within the Common Assembly. As such as a client, you will never configure 
             	these values but instead can override the <see cref="P:Hca.Common.BaseException.ExceptionConfig.IncludeStackTrace"/> and 
             	<see cref="P:Hca.Common.BaseException.ExceptionConfig.HelpLink"/> properties by specifying new values when you 
             	instantiate an exception.
             	<para/>
             	Exceptions use message resources as detailed in the next section. To configure the message 
             	resource, the <see cref="T:Hca.Common.Resource.ResourceConfig"/> class is used to specify 
             	where to find a message for an exception. This configuration is ordered by their placement 
             	in the configuration file. The first <see cref="T:Hca.Common.Resource.ResourceConfig"/> has 
             	highest priority within a file (i.e. list semantics). Additionally, with multiple 
             	configuration files (e.g. one for <see cref="N:Hca.Common"/> and one for an application), the 
             	application file (i.e. lowest in the chain) takes priority over files specified earlier 
             	through <i>includes</i>. Consequently, an application can override an existing key's 
             	message by simply defining the key/value pair again in the application's resource 
             	(.resx) file. Please refer to the <see cref="N:Hca.Common.Resource"/> and 
             	<see cref="N:Hca.Common.Configuration"/> SDKs for details on defined resource files 
             	and configuration files.
             	<para/>
             	<p>The properties for resource configuration are described in the <see cref="N:Hca.Common.Resource"/>
             	SDK. It is recommended that messages for exceptions use the token <i>@Hca.Common.Resource.ResourceConfig.ExceptionMessageContextName@</i>
             	when defining a context where the exception messages should be held in the same bundle of messages that common 
             	keeps. Currently common replaces this token with the name "exception". However, this is an internal detail and 
             	subject to change. By using the token you can ensure that any change in common for this name will not impact 
             	your usage. There may also be instances where you want to separate your messages from those in common. In this
             	case you should define a different name and use the token capabilities in your application.</p>
             	<note>Refer to <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/> property in the 
             	<see cref="T:Hca.Common.Resource.ResourceConfig"/> when defining your configuration.</note>
             	<hcaExample desc="A ResourceConfig using the default context name token">
             	<code>
             <![CDATA[<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
             	<property name="ContextName" value="@Hca.Common.Resource.ResourceConfig.ExceptionMessageContextName@"/>
             	<property name="AsmName" value="Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=fd260fd4a2a56402"/>
             	<property name="BaseName" value="Hca.Common.EmbedResource.commonexcmsg"/>
             </config>]]>
             		</code>
             	</hcaExample>
             	<h3 class="dtH3">Message Resources</h3>
             	In order for exceptions to provide meaningful detail, messages must describe the condition 
             	and potential reason why a fault or anomaly occurred. This framework is designed to 
             	separate the actual message from the code so that the text can be dynamically loaded for a 
             	given context. In this way, cultural or application specific values can be returned without 
             	change to the actual application code.
             	<para/>
             	To achieve this freedom, the framework dynamically looks up exception messages through 
             	<see cref="T:Hca.Common.Resource.HcaResourceManager"/> found in the <see cref="N:Hca.Common.Resource"/> 
             	namespace. This includes the use of a resource key and corresponding <see langword="static"/> methods 
             	in an exception message class. Each <see langword="static"/> method uses the resource key that would be 
             	defined in a resource file that is either linked into the library assembly or linked as 
             	a satellite assembly. 
             	<note>
             	It is the responsibility of the creator of an exception class to create the default key 
             	and any associated messages that represent typical usage where a different message is 
             	needed to cover some alternate condition but the same exception concept. However, 
             	application developers may still define new keys within their application when new 
             	conditions occur that could not be anticipated by the creator of the exception class.
             	</note>
             	<para/>
             	For example, if an application represented the concept of item not found, keys could be 
             	created to represent different messages for specific usage (in this case, developers will 
             	want to provide a message to describe the concrete type that could not be found). In this 
             	way, one exception can handle many different needs, reducing the number of exceptions. In 
             	the resource file, a message key must be created where the fully qualified class name is 
             	the key and the value is a generic default message used if no specific key is provided or 
             	cannot be found. For <see cref="N:Hca.Common"/>, the class that holds the keys for all exception messages 
             	is <see cref="T:Hca.Common.BaseException.ExceptionMessage"/>. 
             	A <see langword="static"/> method exists for every key that corresponds to text messages defined in <c>commonexcmsg.resx</c>. 
             	By convention, this resource file is placed in the <c>EmbedResource</c> folder under the 
             	<c>root</c> namespace. If a culture specific version of this file is needed, it must be 
             	placed in the 
             	<code>
             build/&lt;project name&gt;/satelliteAsm/&lt;build&gt;/&lt;assembly name&gt;/&lt;culture&gt; 
             	</code>
             	directory of the <see cref="N:Hca.Common"/> project. The assembly name must be the base name of default 
             	dll (<c>Hca.DevBlocks.Common</c> in the case of <see cref="N:Hca.Common"/>) and the culture is that 
             	culture's standard abbreviation as a directory (e.g. es for Spanish). If the satellite 
             	assembly needs to be loaded into the GAC, it must be strong named. The resource file name 
             	would then be the same as the default resource name (<c>commonexcmsg</c> in the case of 
             	<see cref="N:Hca.Common"/>) but prefixed with the fully qualified name as defined by the default file's 
             	placement in the source directory (<c>Hca.Common.EmbedResource</c> in the case of 
             	<see cref="N:Hca.Common"/>). Any culture specific resource is automatically created as a satellite 
             	assembly and placed in the correct location by the build script. 
             	<para/>
             	<hcaExample desc="Exception Usage with Resource Keys">
             	<code>
             if(null == config)
             {
             	throw new HcaArgumentException(ExceptionMessage.ArgumentNull());
             }
             	</code>
             	</hcaExample>
             	<para/>
             	Applications that use this framework should define their own exception message class and resource 
             	file(s) for exception text. The same pattern described above must be followed by the 
             	application. An application has the option of defining a new message text for an existing 
             	key by specifying that new message in the application's specific resource file. Since the 
             	message key in the resource file is the same, the resource manager will prefer the new 
             	message over any message found in a dependent library as detailed to in the 
             	<see cref="N:Hca.Common.Configuration"/>. Consequently, when a key is specified in the code, 
             	the message returned is based on the current culture and application making the request. 
             
             	<h2 class="dtH2">Best Practices</h2>
             	<h3 class="dtH3">Creating Exceptions</h3>
             	The following are best practice for creating exceptions:
             	<list type="bullet">
             		<item>
             			A new exception should be created only if application code reacts differently to 
             			that new exception. To determine this, ask this question: would I provide special 
             			handling if that exception occurred or is the only difference a unique message for 
             			the situation. A new exception should be created only in the first situation. 
             			Otherwise, define a new message in a resource file that covers that situation.
             		</item>
             		<item>
             			Avoid creating wrappers for existing .NET exceptions within your application. If 
             			you feel that the exception needs to be communicated as an 
             			<see cref="T:Hca.Common.BaseException.IHcaException"/>, submit a JIRA issue for the 
             			exception component and describe why you need the exception wrapped. Your request 
             			will be considered and if acceptable added within <see cref="N:Hca.Common.BaseException"/> types.
             		</item>
             		<item>
             			When you create a .NET exception, but you want to provide a custom message driven 
             			from the resource file, use a custom <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> style class
             			to get that message. The custom class will return <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> 
             			which will handle calling <see cref="T:Hca.Common.Resource.HcaResourceManager"/> for you.
             			<br/>
             			<br/>
             			<hcaExample desc="Using ExceptionMessage for an Exception Message">
             			<code>
             catch(Exception e)
             {
             	throw new ConfigurationException(MyAppExceptionMessage.ErrorCreatingExampleConfig(), e);
             }
             			</code>
             			</hcaExample>
             		</item>
             		<item>
             			HCA user exceptions should inherit from <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> 
             			or one of its derived classes. This is not necessary when another framework's 
             			exception must be inherited. In this case, implement <see cref="T:Hca.Common.BaseException.IHcaException"/> 
             			using <see cref="T:Hca.Common.BaseException.HcaExceptionHelper"/>. (For an example, see 
             			<see cref="T:Hca.Common.BaseException.HcaArgumentException"/>.)
             		</item>
             		<item>
             			You must prefix a sub-class of a non-HCA exception with <i>Hca</i>, when it is just 
             			used to implement <see cref="T:Hca.Common.BaseException.IHcaException"/>. For example: 
             			<see cref="T:Hca.Common.BaseException.HcaArgumentException"/>.
             		</item>
             		<item>
             			HCA exceptions must provide a constructor for every constructor defined by their 
             			parent class. However, if you create an exception that requires one or more values 
             			to be specified for the exception to be used, this rule is relaxed to specifying 
             			constructors from the parent class that are meaningful.
             			<br/>
             			<br/>
             			<note>
             				Not providing a constructor for every parent constructor is not typical and 
             				will be looked at critically during a code review. Hence, ensure that your 
             				need can be justified. 
             			</note>
             		</item>
             		<item>
             			If you are throwing an exception that you know should never be logged, set the 
             			<see cref="P:Hca.Common.BaseException.IHcaException.LogException"/> property to 
             			<see langword="false"/> and this exception will only be logged 
             			by the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> if the <c>alwaysLog</c> 
             			parameter on the <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> method is <see langword="true"/>.
             			<br/>
             			<br/>
             			<hcaExample desc="Setting the LogException Property">
             			<code>
             aExc = new HcaApplicationException();
             aExc.LogException=false;
             retExc = (IHcaException)ExceptionHandler.HandleException(aExc, GetType());
             Assert.IsFalse(retExc.IsLogged); // This would yield true.
             			</code>
             			</hcaExample>
             		</item>
             	</list>
             
             	<h3 class="dtH3">Exception Resource Keys</h3>
             	The following are best practice for handling exception resource keys:
             	<list type="bullet">
             		<item>
             			When creating a new exception, create a message in the resource file (.resx) with 
             			the fully qualified name of the exception as the key. For example, the 
             			<see cref="T:Hca.Common.BaseException.HcaArgumentException"/> should have a key called 
             			<i><see cref="T:Hca.Common.BaseException.HcaArgumentException">Hca.Common.BaseException.HcaArgumentException</see></i> 
             			and its value is the default message if no other key is specified.
             			<br/>
             			<br/>
             			<hcaExample desc="Defining default exception messages in a resource file">
             			<code>
             <![CDATA[...
             <data name="Hca.Common.BaseException.HcaApplicationException">
             	<value>A General Problem has occurred with the application.</value>
             </data>
             <data name="Hca.Common.BaseException.HcaSystemException">
             	<value>A General Problem has occurred with the system.</value>
             </data>
             ...]]>
             			</code>
             			</hcaExample>
             		</item>
             		<item>
             			Define <see langword="static"/> methods in a class that correspond to the message keys. These methods will map the key to a 
             			resource key defined in a resource file.
             			<note>
             				It is recommended that the name of the class be 
             				<c>&lt;app name&gt;ExceptionMessage.cs</c> so that users can recognize 
             				which file contains this information.
             			</note>
             		</item>
             	</list>
             	<para/>
             	<p>
             	It is also important that you document the method with the details that a developer would need 
             	to know in order to use the method. In particular, the arguments needed and current message text 
             	might be helpful. However, keep in mind that when you update the message in the resource to 
             	also update the XML documentation so that it remains current.
             	</p>
             	<p>There are two ways to implement the message class within your application. The first is the recommended
             	form when your resource messages will use the same context as that used within common. In this case be sure
             	to use the <i>@Hca.Common.Resource.ResourceConfig.ExceptionMessageContextName@</i> token when defining your
             	resource config (See Example in Configuration section above). An example of this first usage is:</p>
             	<p>
             	<hcaExample desc="Defining static methods in an exception message class.">
             	<code><![CDATA[
             namespace MyNamespace
             {
            		public sealed class MyAppExceptionMessage
            		{
            			// constructor made private to prevent instantiation
            			private MyAppExceptionMessage() {}
            				
            			/// <summary>
            			/// <para>
            			/// This key is used when a Area Code is not proper for a North American 
            			/// phone number.
            			/// </para>
            			/// <para>
            			/// <b>Message:</b> "The area code format for a North American phone 
            			/// number must be of the form NXX where N indicates digits 2-9, and 
            			/// X indicates digits 0-9 and can not be X11 or X9X or 37X or 96X."
            			/// </para>
            			/// </summary>
            			public static ExceptionMessage AreaCodeFormatForNorthAmericaInvalid()
            			{
             			return new ExceptionMessage(MethodBase.GetCurrentMethod().Name);
            			}
             
            			/// <summary>
            			/// <para>Used to indicate that a property is not readable.</para>
            			/// <para><b>Message:</b> "Property [{0}] is not readable."</para>
            			/// </summary>
            			/// <param name="propertyName">The name of the property that could not be read.</param>
            			public static ExceptionMessage PropertyNotReadable(string propertyName)
            			{
             			return new ExceptionMessage(MethodBase.GetCurrentMethod().Name, propertyName);
            			}
            		}
             }]]>
             	</code>
             	</hcaExample>
             	</p>
             	<p>The second form is only needed if you want to use a different context for your exception resource messages.
             	In this case you must define the message class from ResourceMessage so that you can specify the context that
             	messages are loaded from. In addition, when you define the <see cref="T:Hca.Common.Resource.ResourceConfig"/>,
             	you should use a token for the context name. The following example shows this alternate usage.</p>
             	<note>You would place the exception message context in a configuration property that is either defined
             	within an application specific configuration object or is simply a name/value pair in the 
             	<see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> class. This example shows the first form.</note>
             	<hcaExample desc="Defining static methods in an exception message class.">
             	<code><![CDATA[
            		The configuration definition might be like this. Notice how both places where the context name is defined use the
             	token value so that they will be consistent.
            <tokenDefault name="Hca.MyApp.ExceptionResourceContext" value="exception"/>
            <config type="Hca.MyApp.MyAppConfig, MyAssemblyName, Version=1.1.0.0, Culture=neutral, PublicKeyToken=fd260fd4a2a56402" readOnly="true">
            		<property name="ExceptionMessageContext" value="@Hca.MyApp.ExceptionResourceContext@" />
            </config>
            <config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            		<property name="ContextName" value="@Hca.MyApp.ExceptionResourceContext@" />
            		<property name="BaseName" value="Hca.MyApp.EmbedResource.ExceptionMessage" />
            		<property name="AsmName" value="MyAssemblyName, Version=1.1.0.0, Culture=neutral, PublicKeyToken=fd260fd4a2a56402" />
            </config>
             	The message class would be defined like:
             namespace MyNamespace
             {
            		public sealed class MyAppExceptionMessage : ResourceMessage
            		{
            			private static string exceptionMessageContext = "exception";
            			/// Static constructor to load exception message resource context.
            			static MyAppExceptionMessage()
            			{
            				MyAppConfig config = (MyAppConfig)ConfigFactory.Instance.GetConfig(typeof(MyAppConfig));
            				exceptionMessageContext = config.ExceptionMessageContext;
            			}
            			///<summary>Create an exception message.</summary>
            			/// <param name="name">The name used within the resource to retrieve.</param>
            			/// <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
            			public MyAppExceptionMessage(string name, params object[] formatArgs) : this(true, name, formatArgs)
            			{
            			}
            			
            			///<summary>Create an exception message.</summary>
            			/// <param name="formatProvider">A provide to use when forming the message from the resource.</param>
            			/// <param name="name">The name used within the resource to retrieve.</param>
            			/// <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
            			public MyAppExceptionMessage(IFormatProvider formatProvider, string name, params object[] formatArgs)
            				: this(formatProvider, null, true, name, formatArgs)
            			{
            			}	
            			
            			///<summary>Create an exception message.</summary>
            			/// <param name="exceptionIfMissing">If <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            			/// <param name="name">The name used within the resource to retrieve.</param>
            			/// <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
            			public MyAppExceptionMessage(bool exceptionIfMissing, string name, params object[] formatArgs)
            				: this(null, null, exceptionIfMissing, name, formatArgs)
            			{
            			}	
            			
            			///<summary>Create an exception message.</summary>
            			/// <param name="formatProvider">A provide to use when forming the message from the resource.</param>
            			/// <param name="culture">A culture to apply when forming the message from the resource.</param>
            			/// <param name="exceptionIfMissing">If <see langword="true"/> an exception will be thrown if the resource is missing.</param>
            			/// <param name="name">The name used within the resource to retrieve.</param>
            			/// <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
            			public MyAppExceptionMessage(IFormatProvider formatProvider, CultureInfo culture, bool exceptionIfMissing, 
            				string name, params object[] formatArgs)
            				: base(formatProvider, culture, exceptionIfMissing, MyAppExceptionMessage.ExceptionMessageContext, 
            					name, formatArgs)
            			{
            			}	
            			
            			///<summary>Return the context to use for retrieving exception messages.</summary>
            			public static string ExceptionMessageContext
            			{
            				get {return exceptionMessageContext;}
            			}
            			
            			/// <summary>
            			/// <para>
            			/// Description of usage.
            			/// </para>
            			/// <para>
            			/// <b>Message:</b> "The message text"
            			/// </para>
            			/// </summary>
            			public static MyAppExceptionMessage MyAppSpecificMessage()
            			{
             			return new MyAppExceptionMessage("keyInResourceBundle");
            			}
            			// Define other messages...
            		}
             }]]>
             	</code>
             	</hcaExample>
             	<p>
             	Users are also directed to review the <see cref="N:Hca.Common.Resource"/> SDK for information on working with 
             	resource keys and resource message classes.</p>
             	<h2 class="dtH2">Exception Handling</h2>
             	Exception handling captures and stores as much information as possible before the system is no longer able to 
             	collect such information. Consequently, exceptions should be handled as close to the source as possible. The 
             	longer an exception is deferred for handling, the greater the risk that the system may fail before the information 
             	can be obtained. However, this practice does not fully help you to know when to handle an exception versus rethrow 
             	it for some other layer to handle. This is especially true when dealing with expected (i.e. checked) exceptions. 
             	Consequently, the following points can help you distinguish when to handle an exception and when to let it go 
             	up to the caller.
             	<list type="bullet">
             		<item>
             			Private methods within a class should not handle an exception. Instead, it should 
             			pass to the calling method up the invocation stack. The message that returns may 
             			vary according to the public method that is invoked. Consequently, the private 
             			method has no way of picking a consistently correct message for the situation.
             			<hcaNote>
             				Exceptions to this rule occur when the private method reacts differently to 
             				different exceptions. In this case, it should catch the exception and react 
             				accordingly.
             			</hcaNote>
             		</item>
             		<item>
             			If a method needs to throw an exception that is more specific than the current, 
             			caught exception, create the new exception that passes the caught exception as the 
             			inner exception and then invoke the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>. 
             			If you also desire this new exception to be logged with the current caught exception, 
             			use the overload form of the <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> 
             			that allows the <c>AlwaysLog</c> parameter to be set.
             			<br/>
             			<br/>
             			<hcaExample desc="Recasting a caught exception">
             				<code>
             try
             {
             	// work
             }
             catch(Exception exc)
             {
             	throw ExceptionHandler.HandleException(
             		new PersistenceException( 
             			PersistenceExceptionMessage.SomeError(), exc), GetType());
             }
             				</code>
             			</hcaExample>
             		</item>
             		<item>
             			When you are handling an exception, simply throw the result of the 
             			<see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)">ExceptionHandler.HandleException</see> method. 
             			This will:
             			<list type="bullet">
             				<item>
             					If it is an HCA based exception, it will return the caught exception, type 
             					unchanged. However, since a new throw is being issued, the current stack 
             					trace will be truncated in the new throw to the point of that throw. Since 
             					the handler will have already logged the message, this is usually not of 
             					any concern unless the exception is explicitly logged a second time. Even 
             					in this case the detail will be discernible in the log. However, if you 
             					desire to maintain the current trace you can accomplish that with a little 
             					more code as such:
             					<br/>
             					<br/>
             					<hcaExample desc="Handling an IHcaException and rethrowing to maintain current stack trace">
             						<code>
             ...
             try
             {
             }
             catch (System.Exception exc)
             {
             	if (exc is IHcaException)
             	{
             		ExceptionHandler.HandleException(exc, GetType());
             		throw;
             	}
             	throw ExceptionHandler.HandleException(exc, GetType());
             }
             						</code>
             					</hcaExample>
             				</item>
             				<item>
             					Or, if it is from the .NET SDK or another third party library, it will 
             					wrap the exception. The wrapped exception will always be an HCA derived 
             					exception either <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> 
             					or <see cref="T:Hca.Common.BaseException.HcaSystemException"/> based on the 
             					derivation of the caught exception.
             				</item>
             			</list>
             		</item>
             		<item>
             			Refer to the API help for details on overloads of the handler that allow for 
             			alternate message keys.
             			<br/>
             			<br/>
             			<hcaExample desc="Normal Exception Handling">
             				<code>
             try
             {
             	// work
             }
             catch(Exception exc)
             {
             	throw ExceptionHandler.HandleException(exc, GetType());
             }
             				</code>
             			</hcaExample>
             		</item>
             	</list> 
             	<para/>
             	In general, public methods of a class should define <c>try/catch/finally</c> blocks and handle 
             	exceptions as follows:
             	<list type="bullet">
             		<item>
             			All known exceptions (i.e., those listed in the documentation of the called method) 
             			should be caught, and handled with <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>. 
             			They should be re-thrown if there is no resolution. All public methods throwing 
             			originating exceptions within their class should clearly state them in their method's 
             			documentation.
             			<note>
             				Remember that the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> will 
             				not change HCA-based exceptions. Consequently, 
             				throwing <see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> 
             				will return an <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> 
             				for native exceptions or the specific HCA exception.
             			</note>
             		</item>
             		<item>
             			If special handling is required for a specific exception, exceptions should be caught 
             			in descending order of specificity (i.e., the most derived exception in an inheritance 
             			chain should be caught first).
             			<br/>
             			<br/>
             			<hcaExample desc="Handling exceptions by type">
             				<code>
             try
             {
             	// work
             	File.Delete(fileName);
             }
             catch (UnauthorizedAccessException exc)
             {
             	log.Warn("User [{0}] not authorized to delete file [{1}]", userName, fileName);
             	throw ExceptionHandler.HandleException(exc, GetType());	
             }
             catch (System.IO.FileNotFoundException exc)
             {
             	throw ExceptionHandler.HandleException(
             		new ItemNotFoundException(
             			MyAppExceptionMessage.MissingItemKey(), exc), GetType()); 
             }
             catch (System.Exception exc)
             {
             	// This uses a replaceable parameter in the exception message.
             	throw ExceptionHandler.HandleException(exc, GetType(),
             		MyAppExceptionMessage.ItemCantDelete(fileName), HcaLogger.LogLevel.Warn, false);
             }
             				</code>
             			</hcaExample>
             		</item>
             		<item>
             			Public methods of classes that encapsulate a business process (i.e., a class 
             			exposed to a presentation tier or exposed as a service) must always return an 
             			<see cref="T:Hca.Common.BaseException.IHcaException"/> exception. The components 
             			at boundary areas, such as layers or tiers, should not throw low-level exceptions 
             			like <see cref="T:System.IO.IOException"/>. This can be accomplished by always using 
             			the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> class through its 
             			<see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleException(System.Exception,System.Type)"/> or 
             			<see cref="M:Hca.Common.BaseException.ExceptionHandler.HandleExceptionAtBoundary(System.Exception,System.Type)"/> method. You should also 
             			look carefully at whether you can recast a system exception to a more useful 
             			business exception. For example, if a <see cref="T:System.IO.FileNotFoundException"/> 
             			could be expected by an operation that was to return report output, you should consider 
             			using an <see cref="T:Hca.Common.BaseException.ItemNotFoundException"/> (making the 
             			<see cref="T:System.IO.FileNotFoundException"/> as the cause) with the message 
             			indicating what item was not found since this exception is at the same level of 
             			abstraction as the operation.
             			<note>
             				This rule does not apply to non-service or non-tier public methods. These 
             				methods may throw any exception.
             			</note>
             		</item>
             		<item>
             			Data type, model and value object classes should not define exception handling in 
             			their methods unless they handle a system exception for which an HCA specific 
             			exception is more appropriate. For example, properties of one of these classes 
             			should simply set or get the value unless a system exception, like 
             			<see cref="T:System.ArgumentException"/> or <see cref="T:System.ArgumentNullException"/> 
             			is expected (i.e., if validation methods or update methods are responsible for 
             			detecting invalid values, they should throw an (<see cref="T:Hca.Common.BaseException.HcaArgumentException"/>) 
             			exception as part of their contract). The rationale for this practice is that these 
             			types are usually part of some larger business class or process, which has the 
             			context of the operation and can return an appropriate exception for the situation. 
             			Additionally, though minimal, some overhead is incurred. This can accumulate over 
             			long method call chains. Consequently, this practice minimizes the proliferation of 
             			exception handling calls and minimizes any performance concerns.
             		</item>
             		<item>
             			It is important to stress that resources (file handles, database connections, sockets, 
             			etc) should always be cleaned up in the finally block.
             		</item>
             	</list>
             
             	<h2 class="dtH2">Examples</h2>
             	This section provides examples on configuration, resource specification, exception 
             	creation, and exception handling. These examples are for illustration only and should not 
             	be cut-and-pasted directly into application code. Instead, the patterns exhibited should 
             	be understood and applied so that it becomes part of the developer's standard practice.
             	<para/>
             	As developers develop their own examples, they should be published in the development team's 
             	collaboration tool. The best of these will be included in future versions of this 
             	guide. Any questions of usage should always be posted in the forums and perceived bugs or 
             	feature requests posted to the JIRA site.
             
             	<h3 class="dtH3">Resource Configuration</h3>
             	These examples illustrate how to create and configure message resources for use with the 
             	<see cref="N:Hca.Common.BaseException"/> framework. When creating a new exception resource bundle, the application 
             	must first consider which existing message bundles from other libraries need to be included. The configuration 
             	framework implicitly includes its configuration. Consequently, the messages in the <c>commonexcmsg.resx</c> file 
             	are available for use in the application. You have the option to override the existing message text with a new 
             	message by defining another resource file and adding a <c>ResourceConfig</c> entry in an application 
             	configuration file (e.g. your <c>app.config</c> file). For each new message defined, you must add a 
             	<see langword="static"/> method in an exception message resource class (Refer to previous discussion for options). 
             	The name of this method should convey the condition that the exception message relates and it is preferred that it 
             	corresponds to the actual resource key name. The following example shows an entry from the 
             	<see cref="T:Hca.Common.BaseException.ExceptionMessage"/> class found in <see cref="N:Hca.Common"/>.
             	<para/>
             	<para/>
             	Define a descriptive resource key name in a  resource message file (i.e., the resx file) and 
             	define a message adequate for the key. This example illustrates what the corresponding resource key value would 
             	look like. 
             	<para/>
             	<hcaExample desc="Resource Key Entry">
             		<code>
             <![CDATA[<data name="MachineNameNotLoaded">
             	<value>The Machine Name can not be loaded from the environment for the thrown exception.</value>
             </data>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	The <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> uses the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> class which loads 
             	the resource message files by finding a <see cref="T:Hca.Common.Resource.ResourceConfig"/> in one of your 
             	application configuration files such as the <c>app.config</c> file. This example illustrates 
             	using a resource from an assembly located in the GAC (<see cref="N:Hca.Common"/> in this case). 
             	<para/>
             	<hcaExample desc="ResourceConfig for external exception message">
             		<code>
             <![CDATA[<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
             	<property name="ContextName" value="@Hca.Common.Resource.ResourceConfig.ExceptionMessageContextName@"/>
             	<property name="AsmName" value="Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=fd260fd4a2a56402"/>
             	<property name="BaseName" value="Hca.Common.EmbedResource.commonexcmsg"/>
             </config>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	This example illustrates using a resource embedded in a local assembly.
             	<hcaExample desc="ResourceConfig for local exception message">
             		<code>
              <![CDATA[<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
             	<property name="ContextName" value="@Hca.Common.Resource.ResourceConfig.ExceptionMessageContextName@"/>
             	<property name="AsmName" value="MyAssemblyName"/>
             	<property name="BaseName" value="MyNamespace.EmbedResource.exceptions"/>
             </config>]]>
             		</code>
             	</hcaExample>
             	This example shows best practice if you want to define a new context for your messages. You can use the default 
             	token	method shown here or leave the default token out and define the value of the token in you build or 
             	environmental configuration.
             	<hcaExample desc="Defining aResourceConfig with a new message context">
             		<code>
            	 <tokenDefault name="Hca.MyApplication.ExceptionMessageContextName" value="mycontextname"/>
              <![CDATA[<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
             	<property name="ContextName" value="@Hca.MyApplication.ExceptionMessageContextName@"/>
             	<property name="AsmName" value="MyAssemblyName"/>
             	<property name="BaseName" value="MyNamespace.EmbedResource.exceptions"/>
             </config>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	Note that the name of the assembly must be specified where the resource is contained. If this 
             	is an assembly that is strongly named, it must be fully qualified (with the version, culture, 
             	and public key). The order of the entries in a file is the order messages are searched and 
             	returned. Consequently, if a second <see cref="T:Hca.Common.Resource.ResourceConfig"/> is 
             	defined after the next example, any message that was repeated in the second definition 
             	would be ignored if it was also defined in the first entry. However, the ordering is slightly 
             	changed when multiple configuration files are used. In this case, the configuration file 
             	included or defined last (lowest level) keys would always take precedence over the messages 
             	defined by an included (higher level) configuration file.
             	<para/>
             	This example shows an include line from the <c>hcaConfigFactory</c> section of an 
             	<c>app.config</c> or <c>web.config</c> that includes an additional configuration file named 
             	<c>appresource.config</c>.
             	<para/>
             	<hcaExample desc="Including a config for inclusion of other exception messages">
             		<code>
             <![CDATA[<include filename="appresource.config"/>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	This example shows two configuration files: <c>config0.config</c> and <c>config1.config</c>. 
             	<c>Config0.config</c> defines two <see cref="T:Hca.Common.Resource.ResourceConfig"/> definitions 
             	for exception messages, <c>exceptionMsg1</c> and <c>exceptionMsg2</c>. <c>Config1.config</c> 
             	also defines two <see cref="T:Hca.Common.Resource.ResourceConfig"/> definitions for 
             	<c>exceptionMsg3</c> and <c>exceptionMsg4</c>. When <see cref="T:Hca.Common.Configuration.ConfigFactory"/> 
             	loads, it processes the <c>config1.config</c> class first and then processes the include 
             	directive that loads the <c>config0.config</c> definitions. Consequently, the order of 
             	exception message files that the <see cref="T:System.Resources.ResourceManager"/> encounters 
             	is: <c>exceptionMsg3</c>, <c>exceptionMsg4</c>, <c>exceptionMsg1</c>, and <c>exceptionMsg2</c>. 
             	Therefore, <c>exceptionMsg3</c> will provide the value of a key asked for by a client if 
             	present followed by <c>exceptionMsg4</c>, then <c>exceptionMsg1</c> and finally 
             	<c>exceptionMsg2</c>.
             	<para/>
             	<hcaExample desc="Multiple Configuration Files with Exception Resources">
             	<para/>
             	<hcaExample desc="config0.config">
             		<code>
             <![CDATA[<config type="Hca.Common.Config.ResourceConfig" >
             	...
             	value = "exceptionMsg1"
             	...
             </config>
             
             <config type="Hca.Common.Config.ResourceConfig" >
             	...
             	value = "exceptionMsg2"
             	...
             </config>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	<hcaExample desc="config1.config">
             		<code>
             <![CDATA[<include filename="config0.xml"/>
             <config type="Hca.Common.Config.ResourceConfig" >
             	...
             	value = "exceptionMsg3"
             	...
             </config>
             			
             <config type="Hca.Common.Config.ResourceConfig" >
             	...
             	value = "exceptionMsg4"
             	...
             </config>]]>
             		</code>
             	</hcaExample>
             	<para/>
             	</hcaExample>
             	<para/>
             	Messages defined in the configuration file can be straight text or include replaceable 
             	parameters that may be given values at runtime. The standard token replacement found in 
             	the format-based methods of classes such as <c>String.Format()</c> and <c>Console.Write()</c> 
             	is supported for message definition. These message tokens are replaced with values as 
             	passed by the <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> overloaded methods. This example 
             	illustrates defining a tokenized exception message in a resource file. Note that the 
             	convention used places the value within square brackets. This is recommended as it 
             	distinguishes the value from surrounding spaces when the value is an empty string.
             	<para/>
             	<hcaExample desc="Specifying a replaceable parameter in a resource message">
             		<code>
             <![CDATA[<data name="ProvidedDateNotValid">
             	<value>The date provided is not valid: [{0}].</value>
             </data>]]>
             		</code>
             	</hcaExample>
             
             	<h3 class="dtH3">Exception Creation</h3>
             	A new user exception should inherit from <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> 
             	or one of its derived classes. This example shows the creation of a derived class and how the 
             	constructors should be defined. Note that all exceptions must be marked as <c>Serializable</c> 
             	and that the de-serialization constructor must be explicitly implemented.
             	<para/>
             	<hcaExample desc="Exception Creation">
             		<code>
             [Serializable]
             public class HcaMyException : HcaApplicationException
             {
             	public HcaMyException() : this(null, null)
             
             	public HcaMyException(ResourceMessage msg) : this(msg, null)
             
             	public HcaMyException(Exception cause) : this(null, cause)
             
             	public HcaMyException(ResourceMessage msg, Exception cause) : base(msg, cause) { }
             				
             	public HcaMyException(SerializationInfo info, StreamingContext context ) : base( info, context ) { }
             
             	// ...
             }
             		</code>
             	</hcaExample>
             	<para/>
             	Given this definition, a mandatory key must be added to the resource exception message file 
             	as shown in example 17. Note that the name of the key is the fully qualified 
             	name of the exception.
             	<para/>
             	<hcaExample desc="Defining Default Exception Message">
             		<code>
             <![CDATA[<data name="Hca.Common.BaseException.HcaArgumentException">
             	<value>
             		An invalid Argument has been supplied to the request. Please provide the correct 
             		values and retry your request.
             	</value>
             </data>]]>
             		</code>
             	</hcaExample>
             
             	<h3 class="dtH3">Exception Instantiation</h3>
             	The following examples show how an HCA derived exception is used for the various overloaded 
             	constructors.
             	<para/>
             	<hcaExample desc="Exception Instantiation">
             		<code>
             // Default 
             HcaApplicationException newExc = new HcaApplicationException();
             			
             // With a exception message
             HcaApplicationException newExc = 
             	new HcaApplicationException(ExceptionMessage.LoadAppDomain());
             			
             // With a exception message and Argument
             HcaApplicationException newExc = 
             	new HcaApplicationException(ExceptionMessage.PhoneNaFormat("123-333-4444"));
             				
             // With a exception message, Cause and Argument
             ArgumentException cause = new ArgumentException("Dummy Message");
             HcaApplicationException newExc = 
             	new HcaApplicationException(ExceptionMessage.PhoneNaFormat("123-333-4444"), cause);
             				
             // Throwing a .NET exception with a custom message
             InvalidOperationException newExc = new InvalidOperationException(MyAppExceptionMessage.MyCustomMessage().ToString());
             		</code>
             	</hcaExample>
             
             	<h3 class="dtH3">Exception Handling</h3>
             	In most cases, <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> can be used in a 
             	very straightforward manner. The following examples show usage from basic to advance.
             	<para/>
             	<hcaExample desc="Exception Handling">
             		<code>
             // Normal Case
             try
             {
             }
             catch(Exception exc)
             {
             	throw ExceptionHandler.HandleException(exc, GetType());
             }
             			
             // Tell Handler to log the exception even if already logged.
             try
             {
             }
             catch(Exception exc)
             {
             	throw ExceptionHandler.HandleException(exc, GetType(), true);
             }
             			
             // Override the exception's log level and use the passed level for logging
             try
             {
             }
             catch(Exception exc)
             {
             	// Log at warn level instead of current level which by default is Error
             	throw ExceptionHandler.HandleException(exc, GetType(), HcaLogger.LogLevel.Warn);
             }
             			
             // Tell handler to use the passed key and argument to add supplemental information
             try
             {
             }
             catch(Exception exc)
             {
             	// Use the key and argument passed to supplement logged information if
             	// an IHcaException or as the message of the wrapped exception if a 
             	// .NET exception
             	throw ExceptionHandler.HandleException(exc, 
             		GetType(), ExceptionMessage.PhoneNaFormat("123-333-4444"));
             }
             			
             // Catching and recasting an exception
             try
             {
             	// an exception is thrown from a call
             }
             catch(HcaApplicationException exc)
             {
             	// create a new exception that provides more specific exception semantics
             	throw ExceptionHandler.HandleException(new InvalidDataException(
             		ExceptionMessage.PhoneNaFormat("123-333-4444"), exc), GetType());
             }
             catch(Exception exc)
             {
             	// Normal case for any other
             	throw ExceptionHandler.HandleException(exc, GetType());
             }
             			
             // Rethrow an exception
             try
             {
             	// work
             }
             catch(ConcurrentUpdateException exc)
             {
             	// Do something else like send a notice and then rethrow
             	throw;
             }
             
             // Maintain stack trace for an Hca base exception
             try
             {
             }
             catch(System.Exception exc)
             {
             	if (exc is IHcaException)
             	{
             		ExceptionHandler.HandleException(exc, GetType());
             		throw;
             	}
             	throw ExceptionHandler.HandleException(exc, GetType());
             }
             		</code>
             	</hcaExample>
             </summary>
        </member>
        <member name="T:Hca.Common.BaseException.ValidationError">
            <summary>
            This class contains the details of why an object would fail validation. 
            </summary>
            <remarks>
            <para>This class encapsulates the source, item and reason why an object will fail validation. This is
            useful to clients that wish to know what problems will occur if the object is validated.</para>
            </remarks>
        </member>
        <member name="F:Hca.Common.BaseException.ValidationError.instanceId">
            <summary>
            Holds a guid to identify the runtime instance of the object.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.#ctor">
            <overloads>
            Initializes a new instance of a <see cref="T:Hca.Common.BaseException.ValidationError"/> object.
            </overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.#ctor(System.Type,System.String,System.Object,System.String)">
            <summary>
            Constructor that takes all arguments.
            </summary>
            <param name="sourceClassType">The type of the class that contained the invalid item</param>
            <param name="itemName">The name of the item that is invalid</param>
            <param name="itemValue">The value of the item that is invalid</param>
            <param name="reason">A message that describes the reason the item is invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.#ctor(System.Type,System.String,System.Object,Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes all arguments.
            </summary>
            <param name="sourceClassType">The type of the class that contained the invalid item</param>
            <param name="itemName">The name of the item that is invalid</param>
            <param name="itemValue">The value of the item that is invalid</param>
            <param name="reason">A message that describes the reason the item is invalid.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.SetReason(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Sets the reason that the item is invalid using a <see cref="T:Hca.Common.Resource.ResourceMessage"/>.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly the same values.
            </remarks>
            <returns>A HashCode that considers all the object's values.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.ToString">
            <summary>
            Override to provide more readable version of this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.Equals(System.Object)">
            <summary>
            Method to test equality of one ValidationError to another.
            </summary>
            <remarks>
            This method uses a compare utility that checks all fields for equality including fields in any parent class as 
            long as that parent class is a user defined class and not a .Net Framework class (value semantics equality). 
            Further, any composite types are drilled into and checked for equality. Derived classes SHOULD NOT override 
            this method unless they have special value semantics that a straight comparison would not handle.
            </remarks>
            <param name="inObject">The object to compare against</param>
            <returns><see langword="true"/> if this object and the passed object have the same value</returns>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.op_Equality(Hca.Common.BaseException.ValidationError,Hca.Common.BaseException.ValidationError)">
            <summary>
            Overloads the == operator
            </summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationError.op_Inequality(Hca.Common.BaseException.ValidationError,Hca.Common.BaseException.ValidationError)">
            <summary>
            Overloads the != operator
            </summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects do not have the same value.</returns>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.InstanceId">
            <summary>
            Identifies the runtime instance of the object.
            </summary>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.InstanceIdentity">
            <summary>
            Returns the instance ID for <see cref="T:Hca.Common.BaseException.ValidationError"/>
            </summary>
            <returns>string of the id</returns>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.SourceClassName">
            <summary>
            Get or Set the class name for which the invalid item resides.
            </summary>
            <remarks>
            If not set, <see cref="F:System.String.Empty"/> is returned.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.ItemName">
            <summary>
            Get or Set the name of the item that is invalid.
            </summary>
            <remarks>
            For example, a property or field name.
            If not set, <see cref="F:System.String.Empty"/> is returned.
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.Reason">
            <summary>
            Get or Set the reason that the item is invalid.
            </summary>
            <remarks>
            <para>If taken from an <see cref="T:Hca.Common.BaseException.ExceptionMessage"/> or 
            <see cref="T:Hca.Common.Resource.ResourceMessage"/>, use <see cref="M:Hca.Common.BaseException.ValidationError.SetReason(Hca.Common.Resource.ResourceMessage)"/> to set.</para>
            <para>If not set, <see cref="F:System.String.Empty"/> is returned.</para>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationError.ItemValue">
            <summary>
            Get or Set the value of the item that was invalid.
            </summary>
            <remarks>If meaningful to the error, the value that was supplied can be set with this property.</remarks>
        </member>
        <member name="T:Hca.Common.BaseException.ValidationException">
            <summary>
            This exception should be thrown when validation checks on a <see cref="T:Hca.Common.BaseType.ValueObjectBase"/> type
            fail a check for required or field value assertions.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.#ctor(Hca.Common.BaseException.ValidationError[])">
            <summary>
            Creates a new instance of the ValidationException class
            </summary>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.#ctor(Hca.Common.BaseException.ValidationError[],Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes the message for the exception.
            </summary>
            <param name="errors">The error list for this exception</param>
            <param name="msg">The message key to display</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.#ctor(Hca.Common.BaseException.ValidationError[],System.Exception)">
            <summary>
            Constructor that takes the cause for this exception
            </summary>
            <param name="errors">The error list for this exception</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.#ctor(Hca.Common.BaseException.ValidationError[],Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Constructor that takes the message and cause.
            </summary>
            <param name="errors">The error list for this exception</param>
            <param name="msg">The message to display</param>
            <param name="cause">The Exception that caused this exception</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used for deserialization of the exception ValidationException class.
            </summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="M:Hca.Common.BaseException.ValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override the <see cref="M:Hca.Common.BaseException.ValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> method to serialize custom values.</summary>
            <param name="info">Represents the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="P:Hca.Common.BaseException.ValidationException.ErrorList">
            <summary>
            Returns an array of errors that caused this validation exception.
            </summary>
        </member>
        <member name="T:Hca.Common.BaseType.ModelBase">
            <summary>
            This object is a class that is the base for all Model objects that are within
            the system.  Its purpose is to track object identity for both Persistence
            and runtime identification. It also is used to maintain an object's version id.
            </summary>
            <threadsafety static="true" instance="false" /> 
        </member>
        <member name="T:Hca.Common.BaseType.ObjectBase">
            <summary>
            <p>
            This is the base object in the Hca Framework chain. All objects in the framework should inherit from this object.
            This class overrides the methods from the .Net "Object" class to enhance them.  Most importantly, it provides a 
            true value for value-based equality and a verbose <see cref="M:Hca.Common.BaseType.ObjectBase.ToString"/> method.</p>
            </summary>
            <remarks>
            <p>
            <see cref="T:Hca.Common.BaseType.ObjectBase"/> uses <see cref="P:Hca.Common.Configuration.CommonConfig.ExcludeNamespacesPrefixedWith"/> property to define 
            which namespaces by default the equality and hash generation will use when called. This class uses 
            <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> and <see cref="T:Hca.Common.Utility.ValueComparator"/> to define its hashcode and equality.</p>
            This class does not listen to <see cref="E:Hca.Common.Configuration.ConfigFactory.Refreshed"/> event to update its namespace exclusion list.
            </remarks>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="F:Hca.Common.BaseType.ObjectBase.instanceId">
            <summary>
            Holds a guid to identify the runtime instance of the object.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.#cctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all
            of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly
            the same values.
            </remarks>
            <returns>The HashCode of the object's concatenated values.</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.Clone">
            <summary>
            At this level just return the value created by object's <see cref="M:System.Object.MemberwiseClone"/> (shallow copy
            semantics). Note that the owner object is not cloned since it could lead
            to recursion looping. This is ok in the case where the clone is used as a 
            snapshot of the existing object for printing or viewing. However, if this 
            operation is being used to create a new instance, the owner should be reset 
            with the new parent created outside this operation so the correct 
            reference is valued.
            </summary>
            <remarks>
            If a shallow copy isn't appropriate for an object, then this method can be 
            overridden using the <see cref="T:System.ICloneable"/> interface.
            </remarks>
            <example>
            <code>
            		public class MyClass : ObjectBase, ICloneable{
            			...
            			public override object Clone(){
            				MyClass cls = new MyClass();
            				... // modify properties and fields
            				return cls;
            			}
            		}
            </code>
            </example>
            <returns>The cloned object</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)">
             <summary>
             Method to test equality of one object to another.  Equality tests should include all attributes that contribute 
             to what distinguishes one instance of an object to another. 
             </summary>
             <remarks>
             This method uses the <see cref="T:Hca.Common.Utility.ValueComparator"/> utility that checks all fields for equality including 
             fields in any parent class as long as that parent class is a user defined class and 
             not a .Net Framework class (value semantics equality). 
             Further, any composite types are drilled into and checked for equality. Derived classes SHOULD NOT override 
             this method unless they have special value semantics that a straight comparison would not handle.
             This functionality can be overridden in a derived class by implementing the <see cref="T:System.IComparable"/> interface.
             </remarks>
             <example>
             <code>
            public class MyDerivedClass : ObjectBase, IComparable 
            {
            ...
            	public int CompareTo(object obj) { ... }	
            }
             </code>
            		or:
             <code>
            public class MyDerivedClass : ObjectBase 
            {
            	...
            	public MyDataClass data;
            }
            public class MyDataClass : IComparable 
            {
            ...
            	public int CompareTo(object obj) { ... }	
            }
            	</code>
             </example>
             <param name="inObject">The object to compare against</param>
             <returns><see langword="true"/> if this object and the passed object have the same value</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.op_Equality(Hca.Common.BaseType.ObjectBase,Hca.Common.BaseType.ObjectBase)">
            <summary>
            Overloads the == operator
            </summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.op_Inequality(Hca.Common.BaseType.ObjectBase,Hca.Common.BaseType.ObjectBase)">
            <summary>
            Overloads the != operator
            </summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ObjectBase.ToString">
            <summary>
            This method provides a string view of all public properties.
            </summary>
            <remarks>
            This is convenient for debugging.
            </remarks>
            <returns>A string that is a fully recursive dump of the object's values.</returns>
        </member>
        <member name="P:Hca.Common.BaseType.ObjectBase.InstanceId">
            <summary>
            Identifies the runtime instance of the object.
            </summary>
        </member>
        <member name="P:Hca.Common.BaseType.ObjectBase.InstanceIdentity">
            <summary>
            Returns the instance ID for <see cref="T:Hca.Common.BaseType.ObjectBase"/>
            </summary>
            <returns>string of the id</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ModelBase.#ctor">
            <summary>
            Protected constructor.
            </summary>
        </member>
        <member name="M:Hca.Common.BaseType.ModelBase.SetObjectId(Hca.Common.NullableValueType.nulong)">
            <summary>
            Sets the value of <c>objectId</c>.
            </summary>
            <remarks>
            Entity objects are expected to derive from <see cref="T:Hca.Common.BaseType.ModelBase"/> (or one
            of its subclasses) and handle the setting of the value.
            </remarks>
            <param name="value">the new value for objectId</param>
        </member>
        <member name="M:Hca.Common.BaseType.ModelBase.SetVersionId(Hca.Common.NullableValueType.nulong)">
            <summary>
            Sets the value of <c>versionId</c>.
            </summary>
            <remarks>
            Entity objects are expected to derive from <see cref="T:Hca.Common.BaseType.ModelBase"/> (or one
            of its subclasses) and handle the setting of the value.
            </remarks>
            <param name="value">the new value for objectId</param>
        </member>
        <member name="P:Hca.Common.BaseType.ModelBase.ObjectId">
            <summary>
            Persistence object identifier
            </summary>
        </member>
        <member name="P:Hca.Common.BaseType.ModelBase.VersionId">
            <summary>
            Version Identifier for this object. It is intended to be primarily used
            with optimistic locking but could be used for versioning of persistent
            objects outside the locking context.
            </summary>
            <remarks>
            <para>Optimistic locking is intended to allow notification to a client that instance data loaded for an object 
            instance has changed since the last time it was loaded. Generally, this requires that the data store of the instance
            manages a version id field which it can update each time the object is stored. Relational stored data can provide
            this by defining a column for the version id (typically a numeric(19,0)) and using a database trigger to increment
            the version anytime a row is changed. Use of other tools such as a Object-Relational Mapping engine might 
            eliminate the need for a trigger given that all updates happen through that engine.</para>
            </remarks>
        </member>
        <member name="P:Hca.Common.BaseType.ModelBase.OwningObject">
            <summary>
            Used to identify the object that owns this object.
            </summary>
        </member>
        <member name="T:Hca.Common.BaseType.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	This SDK documentation describe the classes found in the <see cref="N:Hca.Common.BaseType"/> namespace of the <see cref="N:Hca.Common"/> 
            	framework. These classes form a foundation for building model-based multi-tier applications and 
            	provide canonical representations that ensure that needed functionality is present to using 
            	applications.
            
            	<h3 class="dtH3">References</h3>
            	The following works are referenced in this SDK:
            	<para/>
            	<i>Table 1: Referenced Works</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="10%">Label</th>
            				<th width="60%">Title</th>
            				<th width="30%">Reference</th>
            			</tr>
            			<tr>
            				<td>[GOF]</td>
            				<td>Design Patterns: Elements of Reusable Object-Oriented Software</td>
            				<td>Erich Gamma, et. al., Addison Wesley, 1994.</td>
            			</tr>
            			<tr>
            				<td>[ESPMN]</td>
            				<td>Enterprise Solution Patterns Using Microsoft .NET</td>
            				<td>Microsoft 2003</td>
            			</tr>
            			<tr>
            				<td>[PEAA]</td>
            				<td>Patterns of Enterprise Application Architecture</td>
            				<td>Martin Fowler 2003</td>
            			</tr>
            		</table>
            	</div>
            
            	<h3 class="dtH3">Requirements</h3>
            	The following requirements governed the development of the classes in the <see cref="N:Hca.Common.BaseType"/> 
            	namespace.
            	<para/>
            	<list type="bullet">
            		<item>
            			Provide an <see cref="T:Hca.Common.BaseType.ObjectBase"/> class that provides a canonical 
            			implementation for deriving most classes within the HCA development environment.
            		</item>
            		<item>
            			Provide a single implementation of value-based equality such that derived classes 
            			provide consistent <see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/> 
            			and <see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode"/>.
            		</item>
            		<item>
            			Provide a single implementation of <see cref="M:Hca.Common.BaseType.ObjectBase.ToString"/> such that derived classes have 
            			a consistent string representation.
            		</item>
            		<item>Provide for object identity consistently.</item>
            		<item>
            			Provide a model base class that adds semantics for persistent identity, versioning, 
            			and ownership.
            		</item>
            		<item>
            			Provide a base class for transfer/value objects that are passed between tiers or 
            			layers in an application.
            		</item>
            	</list>
            
            	<h3 class="dtH3">Tenets</h3>
            	<list type="bullet">
            		<item>
            			All <see cref="N:Hca.Common.DataType"/> classes must inherit from 
            			<see cref="T:Hca.Common.BaseType.ObjectBase"/>. Other classes may inherit from 
            			<see cref="T:Hca.Common.BaseType.ObjectBase"/> if it provides value.
            		</item>
            		<item>
            			In general, Service or Manager type classes do not need to inherit from 
            			<see cref="T:Hca.Common.BaseType.ObjectBase"/> since they typically do not represent 
            			objects that need to be compared, serialized, or cloned.
            		</item>
            		<item>
            			All Domain classes (i.e., classes that are formed to represent concepts in the 
            			problem domain) must inherit from <see cref="T:Hca.Common.BaseType.ModelBase"/>.
            		</item>
            		<item>
            			All Transfer/Value (i.e., classes used to pass data between tiers or layers) classes 
            			must inherit from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>.
            		</item>
            		<item>Derived classes should not override <c>Equals</c> or <see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode"/>.</item>
            		<item>
            			When valuing the parent side of a bi-directional relationship for a domain object, 
            			use the <see cref="P:Hca.Common.BaseType.ModelBase.OwningObject"/> property of <see cref="T:Hca.Common.BaseType.ModelBase"/> to 
            			value that relationship.
            		</item>
            	</list>
            
            	<h2 class="dtH2">Design</h2>
            	It is common that frameworks provide an <i>ObjectBase</i> class for usage. This framework 
            	provides three <i>base</i> level classes that a class designer can choose to inherit. The first, 
            	<see cref="T:Hca.Common.BaseType.ObjectBase"/>, provides common method implementations that 
            	historically are implemented very differently by developers if left to individual class designers. 
            	<see cref="T:Hca.Common.BaseType.ObjectBase"/> is designed to be thin in terms of state and does not 
            	pose a problem when using transformation schemes such as XSLT in a presentation tier. Four methods 
            	are overridden by <see cref="T:Hca.Common.BaseType.ObjectBase"/>: 
            	<list type="bullet">
            		<item><see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode"/></item>
            		<item><see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/></item>
            		<item><see cref="M:Hca.Common.BaseType.ObjectBase.Clone"/></item>
            		<item><see cref="M:Hca.Common.BaseType.ObjectBase.ToString"/></item>
            	</list>
            	<para/>
            	All but <see cref="M:Hca.Common.BaseType.ObjectBase.Clone"/> use reflection to interrogate the state 
            	of an object to either equate or render the values of that object.
            	<para/>
            	<see cref="T:Hca.Common.BaseType.ModelBase"/> extends <see cref="T:Hca.Common.BaseType.ObjectBase"/> 
            	and provides state information to allow persistent identity, versioning, and ownership concepts, 
            	which are all essential when designing domain classes.
            	<para/>
            	<see cref="T:Hca.Common.BaseType.ValueObjectBase"/> extends <see cref="T:Hca.Common.BaseType.ModelBase"/> 
            	and provides the object-side implementation of optimistic locking and adds essential behaviors needed 
            	to comply with the Value/Transfer Object pattern [ESPMN][PEAA]. In particular, the concepts of 
            	validation and update must be defined and consequently ensures consistent implementations for these 
            	behaviors for all value objects.
            	<para/>
            	<see cref="T:Hca.Common.BaseType.ValueObjectBase"/>'s implementation of optimistic locking uses a flag set 
            	from the configuration. If set as <see langword="true"/>, the <see cref="P:Hca.Common.BaseType.ModelBase.VersionId">VersionIds</see> are 
            	compared when the <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object)"/> 
            	methods are invoked. If the object being compared with the current object is not of the same version, the 
            	code throws <see cref="T:Hca.Common.BaseException.ConcurrentObjectUpdateException"/>.
            
            	<h2 class="dtH2">Usage</h2>
            	<h3 class="dtH3">Deriving from ObjectBase</h3>
            	In most cases, types deriving from <see cref="T:Hca.Common.BaseType.ObjectBase"/> require no special 
            	handling. Overriding <see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/>, however, may be an exception. 
            	If you define a type that inherits from <see cref="T:Hca.Common.BaseType.ObjectBase"/> and 
            	desire to add special equality semantics, it is 
            	highly recommended that, when possible, you implement the <see cref="T:System.IComparable"/> interface. Since 
            	<see cref="T:Hca.Common.BaseType.ObjectBase"/>'s equality is implemented in terms of  
            	<see cref="T:Hca.Common.Utility.ValueComparator"/> class, <see cref="T:System.IComparable"/> marked classes 
            	will use the <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation 
            	instead of the normal <see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/>. However, if you have a 
            	case that you cannot abide by the contract of <see cref="T:System.IComparable"/>, you can override 
            	<see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/> with the caveat that you also provide the corresponding operator overloads 
            	for <c>==</c>, <c>!=</c>, and <see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode"/>. This should be rare and evaluated closely.
            	Typically, many classes derive from <see cref="T:Hca.Common.BaseType.ObjectBase"/> as their base class. 
            	Several exceptions occur with two prevalent alternate base classes described in the next two sections. 
            	Additionally, distributed service classes (e.g., COM+) may require special treatment so that 
            	<see cref="T:Hca.Common.BaseType.ObjectBase"/> is not an appropriate base class.
            
            	<h3 class="dtH3">ModelBase</h3>
            	The usage of <see cref="T:Hca.Common.BaseType.ModelBase"/> as a class is primarily as a derivation base 
            	for other classes. However, if you have a single tiered application that uses object persistence, then 
            	it may be reasonable to derive your domain object directly from this class.
            	<para/>
            	When dealing with parent/child relationships where the parent's reference needs to be set on 
            	the child, use the <see cref="P:Hca.Common.BaseType.ModelBase.OwningObject"/> property to set this relationship. By following this 
            	recommendation, you can perform operations on the owner objects by just having 
            	<see cref="T:Hca.Common.BaseType.ModelBase"/> classes. Further, if a persistence engine is used, 
            	the mapping of the bi-directional relationship is simplified. If you desire a specific method named for 
            	the relationship, just define it in terms of the <see cref="P:Hca.Common.BaseType.ModelBase.OwningObject"/> property 
            	and you still have the above advantage while having a concrete relationship name.
            
            	<h3 class="dtH3">ValueObjectBase</h3>
            	<see cref="T:Hca.Common.BaseType.ValueObjectBase"/> forms the base for objects transferred across tiers. 
            	Derived classes are responsible for defining a concrete implementation of the 
            	<see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object)">UpdateFrom(object, bool)</see> 
            	method. This method should apply changes to the target object from the source object such 
            	that if the passed <c>ignoreNulls</c> parameter is <see langword="true"/>, properties of the source that are <see langword="null"/> 
            	are not valued against properties of the target object.
            	<para/>
            	<list type="bullet">
            		<item>
            			If the <c>ignoreNulls</c> parameter is <see langword="false"/>, <see langword="null"/> will replace the values of 
            			current properties where the source object's property is <see langword="null"/>.
            		</item>
            		<item>
            			In general, the <c>ignoreNulls</c> parameter should be <see langword="false"/>.
            		</item>
            		<item>
            			The typical exception to this is if you have one or more external sources that 
            			update parts of the same object. In this case, it is very typical that the desired 
            			behavior is to value the target object's property if the source object's property 
            			is valued but ignore it if <see langword="null"/>.
            		</item>
            	</list>
            	<para/>
            	Derived classes should mark mandatory fields that must be present during validation with the 
            	<see cref="T:Hca.Common.RequiredAttribute">[Required]</see> attribute. <see cref="T:Hca.Common.BaseType.ValueObjectBase"/> classes may optionally 
            	implement the <see langword="virtual"/> method <see cref="M:Hca.Common.BaseType.ValueObjectBase.GetCustomValidationErrors"/> 
            	if they have the need to validate field values are within a range of acceptable values or to perform cross-field checks. 
            	Instead of throwing exceptions with this method, derived classes should add 
            	a <see cref="T:Hca.Common.BaseException.ValidationError"/> to the returned array for every validation failure.
            	<para/> 
            	<see cref="M:Hca.Common.BaseType.ValueObjectBase.GetCustomValidationErrors"/> will be 
            	called by <see cref="M:Hca.Common.BaseType.ValueObjectBase.GetValidationErrors"/> in addition to performing required 
            	field checks to obtain a list of all validation failures for a transfer object. Normally users would want to throw 
            	the results of this list by calling <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/> to ascertain 
            	the validity of transfer objects before use.
            	<para/>
            	Finally, if you have an inheritance chain of value objects, ensure that each class provides 
            	an override of <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object)">ValueObjectBase.UpdateFrom</see> and optionally 
            	<see cref="M:Hca.Common.BaseType.ValueObjectBase.GetCustomValidationErrors"/>. 
            	These overrides must ensure that they call their base class' implementation of these methods.
            
            	<h3 class="dtH3">Modeling Considerations</h3>
            	Here are a few guidelines for deciding which base type to extend when modeling your classes.
            	<para/>
            	<list type="bullet">
            		<item>
            			If you are defining a normal class that is used internal of your application and 
            			does not represent a domain (model) object or updatable value, inherit from 
            			<see cref="T:Hca.Common.BaseType.ObjectBase"/>.
            		</item>
            		<item>
            			If you are modeling a domain object, which must be transferred across layers or a 
            			tier, define a value object that inherits from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/> 
            			for the transfer part and an entity class that inherits from the transfer part.
            		</item>
            		<item>
            			If you have a need to transfer some view of a value and or entity object, create 
            			an immutable class that inherits from <see cref="T:Hca.Common.BaseType.ObjectBase"/>. Even 
            			though this class is often called an immutable transfer object, <see cref="T:Hca.Common.BaseType.ValueObjectBase"/> 
            			is intended only for mutable usage (hence the <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object)"/> 
            			and <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/> methods). 
            		</item>
            		<item>
            			If you have a .NET or third party library for which you must add an extension class, 
            			derive from the class that is necessary to add the extension. If the extension does 
            			not require inheritance from a class in the library, choose <see cref="T:Hca.Common.BaseType.ObjectBase"/> instead.
            		</item>
            	</list>
            	<para/>
            	The following example may help:
            	<para/>
            	Assume we are modeling a <c>Person</c> with the following requirements:
            	<para/>
            	<list type="number">
            		<item><c>Person</c> must be updated by a client user interface.</item>
            		<item>
            			Multiple <c>Person</c> objects can be searched over with the need to show a terse listing of candidate 
            			matches based on the search.
            		</item>
            		<item>
            			<c>Person</c> maintains relationships to other classes that are updated 
            			through other calls exposed on a service layer. For example, assume that 
            			<c>Person</c> has a relationship to an organization. 
            		</item>
            	</list>
            	<para/>
            	The following classes would represent a reasonable usage of the classes found in the base 
            	package.
            	<para/>
            	Define a <c>Person</c> class that inherits from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>. 
            	This will be the mutable transfer object that is passed to the user interface for updating the 
            	<c>Person</c> object.
            	<para/>
            	Define a <c>PersonEntity</c> class that inherits from the <c>Person</c> class. This class 
            	will be the subject of any persistence. It should hold the relationship to the 
            	<c>Organization</c> class and provide factory methods for creating the <c>Person</c> class.
            	<para/>
            	Define a <c>PersonHeader</c> class that inherits from <see cref="T:Hca.Common.BaseType.ObjectBase"/>. This class should 
            	have a constructor that takes the <c>PersonEntity</c> class and populates the header with 
            	the values from that <c>PersonEntity</c>.
            	<para/>
            	The usage of such a hierarchy is further discussed in the next section.
            
            	<h3 class="dtH3">Usage by Service Layer Implementations</h3>
            	It is recommended that business applications implement a Domain Model[PEAA]-based 
            	middle-tier using the <i>Domain Model/Entity class inherit Value Object</i> pattern for 
            	implementation. 
            	<hcaNote>
            		This pattern is a variation of how to represent business entities as domain objects 
            		where value objects are also being used.
            	</hcaNote>
            	In this pattern, the value object is passed to your presentation tier 
            	from the service layer for rendering. Defining a <c>Make&lt;ValueObject&gt;</c> method on the 
            	Entity class, which provides a factory method [GOF] for the value object that creates 
            	the value object. By having the Entity inherit from the Value Object, the properties of 
            	the model object do not need to be repeated again in the entity speeding development and 
            	ensuring consistency. 
            	<para/>
            	A typical pattern of interaction includes:
            	<para/>
            	<list type="bullet">
            		<item>A value/transfer object is created from a retrieved entity.</item>
            		<item>The value object is passed to the presentation tier.</item>
            		<item>It is marked up by the user.</item>
            		<item>Sent back to the service tier where it is applied as an update to the entity.</item>
            		<item>Finally, the entity is persisted to the datastore.</item>
            	</list>
            	<para/>
            	There are several approaches to how an object might be made to persist. Of particular 
            	interest is the use of object-relational storage engines to transparently store the state 
            	of an object and its relationships to a database. However, at this point in time, such a 
            	tool has not been established within the HCA development environment and is not an immediate 
            	solution for persistence. However, by using the entity as the subject of storage, a 
            	developer can encapsulate CRUD type code in the entity such that when a tool is present, 
            	the CRUD code is essentially removed in preference to the persistence engine.
            	<para/>
            	Another consideration for developers is to determine when to use the validation methods 
            	present	on the value objects. We strongly recommend that validation is deferred until a 
            	submittal of a complete business transaction is requested. This typically corresponds to 
            	a service method on your service interface. Often an object may span multiple views within 
            	a user interface or the semantics of the application allow invalid data to be saved for 
            	later processing. In this case, we may need to allow this incomplete information to 
            	proceed from one action to the next without failure due to invalid values or missing 
            	mandatory data. Only when the request is complete would we 
            	call the <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/> method 
            	on the value object to detect bad or missing data. By planning for this in the framework 
            	up front, any application type should be supportable based on its needs.
            
            	<h3 class="dtH3">Configuration</h3>
            	The only class in the <see cref="N:Hca.Common.BaseType"/> namespace that uses configuration information is 
            	<see cref="T:Hca.Common.BaseType.ValueObjectBase"/>. It 
            	uses the
            	<see cref="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking">CommonConfig.UseOptimisticLocking</see> 
            	property to determine whether optimistic locking is enabled. Assigning a value to 
            	<see cref="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking"/> in the 
            	configuration XML for your application sets it for all 
            	<see cref="T:Hca.Common.BaseType.ValueObjectBase"/> types for an application domain. The 
            	property is set to <see langword="true"/> by default so explicit configuration is not required.
            
            	<h2 class="dtH2">Examples</h2>
            	<h3 class="dtH3">ValueObjectBase Inheritance</h3>
            	Example 1 shows the creation of a concrete value object.
            	<para/>
            	<hcaExample desc="Example 1: ValueObjectBase Inheritance">
            		<code>
            <![CDATA[public class Person : ValueObjectBase
            {
            	[Required]
            	private string name;
            		
            	public string Name
            	{
            		get {return name;}
            		set {name = SystemUtility.NullOrTrimString(value);}
            	}
            
            	/// <summary>
            	/// Updates the current object with the passed source object.
            	/// </summary>
            	/// <param name="source">The object to update values from</param>
            	/// <param name="ignoreNulls"><see cref="System.Boolean"/> indicating whether <see langword="null"/> values are 
            	/// included in update.</param>
            	/// <remarks>
            	/// Updates the object using values on the source object. If <paramref name="ignoreNulls"/> 
            	/// is <see langword="true"/>, <see langword="null"/> values are ignored and are not copied. 
            	/// The <see cref="Hca.Common.BaseType.ModelBase.ObjectId"/> is not affected by this method.
            	/// </remarks>
            	/// <exception cref="HcaArgumentException">Thrown when source is <see langword="null"/> or not of the correct type.</exception>
            	public override void UpdateFrom(object source, bool ignoreNulls)
            	{	
            		Type copyType = typeof(Person);
            		
            		// see if source is the right type.
            		Person updObj = source as Person;
            		if ( null == updObj )
            		{
            			throw new HcaArgumentException(ExceptionMessage.TypeUnexpected(source, GetType(), "source")); 
            		}
            		
            		// If this is class in an inheritance chain of ValueObjectBase objects, call the base class' UpdateFrom
            		// base.UpdateFrom( source, ignoreNulls);
            		
            		// Use PropertyUtility
            		PropertyUtility.CopyProperties(this, copyType, source, copyType, 
            			ignoreNulls ? PropertyUtility.NullHandling.ExcludeSourceNulls : PropertyUtility.NullHandling.Normal,
            			PropertyUtility.CurrentClassAllInstanceMemberBinding);
            	}
            		
            	/// <summary>
            	/// Gets any validation errors for return to the client.
            	/// </summary>
            	/// <remarks>
            	/// <para>Returns an array of <see cref="Hca.Common.BaseException.ValidationError"/> 
            	/// objects that represent validation failures for this object's current state.</para>
            	/// </remarks>
            	protected override ValidationError[] GetCustomValidationErrors()
            	{
            		ArrayList errors = new ArrayList();
            		// Perform any custom field validation here and add any errors to the errors arrayList
            		if("Nobody" == this.Name)
            		{
            			errors.Add(new ValidationError(typeof(Person), "Name", Person.Name, "Nobody is an invalid name."));
            		}
            		
            		return (ValidationError[])errors.ToArray(typeof(ValidationError));
            	}
            }]]>
            		</code>
            	</hcaExample>
            	<para/>
            	Example 2 illustrates how to define a property to set a bi-directional relationship using the 
            	<see cref="P:Hca.Common.BaseType.ModelBase.OwningObject"/> property.
            	<hcaExample desc="Example 2:  Using OwningObject in a Derived class">
            		<code>
            public class Child : ModelBase
            {
            	...
            	public Person Parent
            	{
            		// Using OwningObject from ModelBase for this relationship
            		get { return OwningObject as Person; }
            		set { OwningObject = value; }
            	}
            	...
            }
            		</code>
            	</hcaExample>
            </summary>
        </member>
        <member name="T:Hca.Common.BaseType.ValueObjectBase">
            <summary>
            <para>
            This class is an <see langword="abstract"/> class that is the base for all objects that are implemented to value the Transfer/Value 
            Object pattern. Its main purpose is to enforce compliance to implement methods needed by the system to handle 
            value objects.
            This class also reads a configurable property <see cref="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking"/>
            which if <see langword="true"/>, version checking will be done. Otherwise, no version checks and hence, no optimistic locking 
            occurs.</para>
            </summary>
            <threadsafety static="true" instance="false"/> 
            <remarks>
            <para>
            Refer to individual methods for usage and considerations.
            </para>
            </remarks>
        </member>
        <member name="F:Hca.Common.BaseType.ValueObjectBase.isOptimisticLockingOn">
            <summary>
            If <see langword="true"/>, optimistic locking will be enabled.
            default: <see langword="false"/>
            </summary>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.#cctor">
            <summary>
            Turns on or off Optimistic Locking for the entire application by reading 
            <see cref="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking"/>.
            </summary>
            <remarks>
            If the <see cref="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking"/> changes in the config file, the change 
            will be ignored by this class. It doesn't make sense to classes created with mixed optimistic locking settings. 
            The application will have to be restarted for optimistic locking change to take place.
            </remarks>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)">
            <overloads>
            <summary>
            This method updates the property values on this object from a given object. 
            </summary>
            <remarks>
            <para>Optimistic locking at this level only detects "dirty" updates. A dirty update is one where the
            data to be updated (current object in database) has been changed at a point in time after the values 
            were pulled for the current update (the updating object). Use of optimistic locking ensures that data 
            will only be updated if it was the same when last read (think in terms of a repeatable read isolation level
            for a single row).</para>
            <para>Since this class inherits from <see cref="T:Hca.Common.BaseType.ModelBase"/>, the <see cref="P:Hca.Common.BaseType.ModelBase.OwningObject"/> 
            is a property that can be accessed and set. However, since <see cref="T:Hca.Common.BaseType.ModelBase"/> does not have a 
            concept of <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>, this property is not updated via the <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>.
            In addition, since this property represents a relationship to another "parent" object, it would (in most cases)
            be incorrect to just copy the reference. Instead, an implementer should manage this relationship through a 
            controller that has access and disclosure of the relationship. This controller may be at the service boundary 
            or possibly at a persistence layer based on the architectural pattern being implemented.</para>
            </remarks>
            </overloads>
            <summary>
            This overload is <see langword="abstract"/> and required to be implemented by a derived class to provide update behavior.
            </summary>
            <remarks>
            <para>This method should not change any object id contained. If any property is <see langword="null"/>, the current value 
            is replaced with <see langword="null"/> if the ignoreNulls flag is <see langword="false"/>. 
            If your class derives from a class that has a concrete implementation of <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>, 
            be sure to call its implementation of <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> (i.e., base.UpdateFrom()).</para>
            <para>If you define a copy constructor (i.e., a constructor that takes the same class type), consider 
            defining a private method that acts like the <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> but is callable from both the copy 
            constructor and <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>.</para>
            </remarks>
            <example>
            <para>
            There two general ways to implement <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>. 
            The first uses the <see cref="T:Hca.Common.Utility.PropertyUtility"/> to do the copying and is 
            sufficient for all cases where the values to update have both get and set implementations. The default version
            of <see cref="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object)"/> copies the current object's class public
            instance members. This means no private, static, or inherited members are copied. However, you can change this
            behavior by using an overload that takes the BindingFlags which is what controls what is copied. 
            </para>
            <note>If you inherit from a class that inherits from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>, 
            you must remember to call this parent's <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>. When using the 
            <see cref="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object)"/> method, unless the 
            class is <see langword="sealed"/>, you must use the form that 
            takes the target and source types so that proper handling occurs for intermediate classes (i.e chains such as 
            ClassA inherits from Class B inherits from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>). The reason for this is that if you allow a class to 
            be derived from the current class, the implementation of <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> must only copy the properties of the current
            type and not any of its parents. To make this happen, you must 
            use the form of the <see cref="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object)"/> that takes the 
            type. As can be seen in the example, for <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> usage, the type of target and source must be the same.</note>
            <para>The second form is for when you must handle special cases where you need to deal with fields directly
            due to them not being exposed directly via properties. In this case, you must write more code but you have
            full flexibility to handle your special condition.</para>
            Example 1 shows the first case (preferred) and Example2 shows the second.
            <para/>
            Example 1a: 
            <code>
            class MyClass : MyBaseClass
            {
            ...
            	public override void UpdateFrom( object source, bool ignoreNulls)
            	{
            		Type copyType = typeof(MyClass);
            		// see if source is the right type.
            		MyClass detail = source as MyClass;
            		if ( null == detail )
            		{
            			throw new HcaArgumentException(ExceptionMessage.TypeUnexpected(source, GetType(), "source")); 
            		}
            		// Call the base class' Update From if any
            		base.UpdateFrom( source, ignoreNulls);
            		// Use PropertyUtility
            		PropertyUtility.CopyProperties(this, copyType, source, copyType, 
            			ignoreNulls ? PropertyUtility.NullHandling.ExcludeSourceNulls : PropertyUtility.NullHandling.Normal);
            	}
            ...
            }
            </code>
            This is the same as one but with the specification of binding flags where we want to include the current class
            private members too.
            <para/>
            Example 1b: 
            <code>
            class MyClass : MyBaseClass
            {
            ...
            	public override void UpdateFrom( object source, bool ignoreNulls)
            	{
            		Type copyType = typeof(MyClass);
            		// see if source is the right type.
            		MyClass detail = source as MyClass;
            		if ( null == detail )
            		{
            			throw new HcaArgumentException(ExceptionMessage.TypeUnexpected(source, GetType(), "source")); 
            		}
            		// Call the base class' Update From if any
            		base.UpdateFrom( source, ignoreNulls);
            		// Use PropertyUtility
            		PropertyUtility.CopyProperties(this, copyType, source, copyType, 
            			ignoreNulls ? PropertyUtility.NullHandling.ExcludeSourceNulls : PropertyUtility.NullHandling.Normal,
            				PropertyUtility.CurrentClassAllInstanceMemberBinding);
            	}
            ...
            }
            </code>
            This example shows how to roll your own for full control. Note how the ignoreNulls is handled.
            <para/>
            Example 2:
            <code>
            public class MyClass : ValueObjectBase
            {
            	private string myAttr;
            	...
            	
            	public string MyAttr
            	{
            		get
            		{
            			return myAttr;
            		}
            	}
            	...
            	public override void UpdateFrom(object source, bool ignoreNulls)
            	{
            		// see if source is the right type.
            		MyClass detail = source as MyClass;
            		if ( null == detail )
            		{
            			throw new HcaArgumentException(ExceptionMessage.TypeUnexpected(source, GetType(), "source")); 
            		}
            		if (null != detail.MyAttr)
            		{
            			this.myAttr = detail.myAttr;
            		}
            		else
            		{
            			if (!ignoreNulls)
            			{
            				this.myAttr = null;
            			}
            		}
            	}
            	...
            }
            </code>
            This final example shows how to implement when you have a copy constructor and <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> method.
            <para/>
            Example 3:
            <code>
            public class MyClass : ValueObjectBase
            {
            	...
            	public MyClass(MyClass refObject) : base()
            	{
            		Populate(refObject, false);
            	}
            	...
            	public override void UpdateFrom(object source, bool ignoreNulls)
            	{
            		// see if source is the right type.
            		MyClass detail = source as MyClass;
            		if ( null == detail )
            		{
            			throw new HcaArgumentException(ExceptionMessage.TypeUnexpected(source, GetType(), "source")); 
            		}
            		Populate(source, ignoreNulls);
            	}
            	private void Populate(MyClass refObject, bool ignoreNulls)
            	{
            		Type copyType = typeof(MyClass);
            		// Use PropertyUtility
            		PropertyUtility.CopyProperties(this, copyType, source, copyType, 
            			ignoreNulls ? PropertyUtility.NullHandling.ExcludeSourceNulls : PropertyUtility.NullHandling.Normal);
            	}
            }
            </code>
            </example>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if the source is <see langword="null"/> or of the wrong type.</exception>
            <param name="source">The object to copy to this object</param>
            <param name="ignoreNulls">If <see langword="true"/> <see langword="null"/> values in the source are not 
            assigned to the destination object.</param>
            <seealso cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object)">
            <summary>
            This overload updates the properties of an class with whatever value is specified in the source class passed
            to this method. This method is normally called by client service layer code and only takes the source of 
            the update.
            </summary>
            <remarks>
            <para>
            Usage:
            This method should not be hidden by derived classes. Instead use the <see langword="abstract"/> 
            <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> method to define what it means to update your object.</para>
            </remarks>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if the source is <see langword="null"/> or of the wrong type.</exception>
            <exception cref="T:Hca.Common.BaseException.ConcurrentObjectUpdateException">Thrown if update on object occurred after another update.</exception>
            <param name="source">The object to copy to this object</param>
            <seealso cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.UpdateFromValues(System.Object)">
            <summary>
            This method updates the target (current) object from the passed source class for any properties in the 
            source that are not <see langword="null"/>.
            </summary>
            <remarks>
            <para>
            This method is intended for use when an external source needs to update the object but does not have full 
            disclosure or have the entire state of the object. In this case, the update must only update values from the
            source object to the target (current) object which have values. If a property is <see langword="null"/>, it will be ignored in
            the update.</para>
            <para>
            This method should not be hidden by derived classes. Instead use the <see langword="abstract"/> 
            <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/> method to define what it means to update your object.</para>
            </remarks>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if the source is <see langword="null"/> or of the wrong type.</exception>
            <exception cref="T:Hca.Common.BaseException.ConcurrentObjectUpdateException">Thrown if update on object occurred after another update.</exception>
            <param name="source">The object to copy to this object</param>
            <seealso cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"></seealso>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.GetMissingRequiredFieldNames">
            <summary>
            This method returns a list of field names that were marked required but were missing values.
            </summary>
            <returns>An array of field names or empty array if none.</returns>
            <exception cref="T:System.Security.SecurityException">If fields are not accessible for required check.</exception>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.ValidateRequired">
            <summary>
            This method checks for fields marked with the <see cref="T:Hca.Common.RequiredAttribute"/> and validates that the field is
            set with a value. If not an <see cref="T:Hca.Common.BaseException.InvalidDataException"/> exception is thrown. 
            </summary>
            <remarks>
            <para>
            The intent here is that a value is mandatory if it represents a value that would invalidate the concept of 
            the object if persisted. A typical checkpoint is to consider whether you would define the mapped column of 
            the attribute in a relational database as "not null". If you answer yes, then you should check that value 
            in this method for not being <see langword="null"/>.</para>
            <para>
            Since properties are derivative from a field, only fields are checked. If you need to do a cross field
            validation mandatory check, use the <see cref="M:Hca.Common.BaseType.ValueObjectBase.GetCustomValidationErrors"/> method to enforce this need.
            </para>
            <note>If a <see cref="T:System.Security.SecurityException"/> is thrown, it is up to the client whether it should swallow this
            exception or send it up the chain of invocation.</note>
            Usage:
            Call this method just before you persist this object to a datastore.
            </remarks>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">Thrown if validation fails.</exception>
            <exception cref="T:System.Security.SecurityException">If fields are not accessible for required check.</exception>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll">
            <summary>
             This method throws all validation errors returned by <see cref="M:Hca.Common.BaseType.ValueObjectBase.GetValidationErrors"/>, if any.
            </summary>
            <remarks>
            <p>
            This method is typically called before any processing on the target object begins. The general
            pattern of use is that a transfer object is passed into a service method where it is to be applied
            to an entity managed by the service layer.</p>
            <p>Any <see cref="T:Hca.Common.BaseException.ValidationException"/> thrown will contain all errors due to missing mandatory values
            and invalid or out of range values. It is up to the client to determine how to represent these problems
            to a user.</p>
            </remarks>
            <example>
            This example show typical usage of this method. Note use of <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/> and <see cref="M:Hca.Common.BaseType.ValueObjectBase.UpdateFrom(System.Object,System.Boolean)"/>. This
            code is only an example and will vary based on the persistence technique and tools used to 
            handled persistence.
            <code>
            public class MyValueObject : ValueObjectBase
            {
            	...
            }
            public class MyService : IMyService
            {
            	...
            	public void ProcessTransaction(MyValueObject updObject)
            	{
            		if (null == updObject)
            		{
            			throw new HcaArgumentException(ExceptionMessage.ArgumentNull("updObject"));
            		}
            		// call to validate update object!
            		updObject.ValidateAll();
            		
            		// Retrieve Entity via the persistence layer...
            		MyEntityObject currentObj = PersistenceLayer.LoadEntity(updObject.ObjectId);
            		
            		// Process update which might include rules checks and/or use of a state machine
            		...
            		// which would eventually lead to update
            		currentObj.UpdateFrom(updObject);
            		
            		// And saving it back
            		PersistenceLayer.SaveEntity(currentObj);
            		...
            	}
            }
            </code>
            </example>
            <exception cref="T:Hca.Common.BaseException.ValidationException">Thrown if validation fails.</exception>
            <exception cref="T:System.Security.SecurityException">If fields are not accessible for required check.</exception>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.GetCustomValidationErrors">
            <summary>
            Populate any validation errors for return to the client
            </summary>
            <remarks>
            <para>Value/Transfer objects can only validate that the data they contain within their context
            is appropriate for use for processing (in a transaction). Hence, the type of checks typical are
            those that validate field values are within range of the acceptable values for that field. More
            complex checks might include validation that a field is valued correctly given some other field
            in the current object. However, it is not advisable and discouraged to add checks that embed
            business rules within the value/transfer object. Instead these rules should be enforced through
            an intermediary called by the service layer that is processing this object. Typical intermediaries
            include state machines and/or rule agents.</para>
            <para>Derived class should run through their normal validations and instead of throwing exceptions, 
            return a <see cref="T:Hca.Common.BaseException.ValidationError"/> for each validation failure.</para>
            </remarks>
            <returns><see cref="T:Hca.Common.BaseException.ValidationError"/> objects.</returns>
        </member>
        <member name="M:Hca.Common.BaseType.ValueObjectBase.GetValidationErrors">
            <summary>
            Return a list of <see cref="T:Hca.Common.BaseException.ValidationError"/> objects that describe what is invalid about
            this object.
            </summary>
            <remarks>
            <para>This will return all validation problems including missing required values, range checks, 
            and contextual bad value checks (i.e. as if <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/> was called).</para>
            <para>This method is used by <see cref="M:Hca.Common.BaseType.ValueObjectBase.ValidateAll"/>, but is also useful when one object 
            aggregates others and wishes to report on their validity along with its own.</para>
            </remarks>
            <returns>A list of errors or empty array if none.</returns>
        </member>
        <member name="P:Hca.Common.BaseType.ValueObjectBase.IsOptimisticLockingOn">
            <summary>
            If <see langword="true"/>, optimistic locking will be enabled.
            default: <see langword="false"/>
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.IObjectBuilder">
            <summary>Abstracts functionality to create and initialize objects from an XML representation.</summary>
        </member>
        <member name="M:Hca.Common.Builder.IObjectBuilder.GetObjectType(System.Xml.XmlNode)">
            <summary>Returns the type object that describes the type defined in an XML configuration file.</summary>
            <param name="objectNode">A node that contains a type attribute (object or property).</param>
            <returns>The type object if the type attribute represents a legitimate type otherwise <see langword="null"/>.</returns>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when an exception is thrown during the initialization of the type class.</exception>
        </member>
        <member name="M:Hca.Common.Builder.IObjectBuilder.Build(System.Xml.XmlNode)">
            <overloads>Constructs an object from an XML Element</overloads>
            
            <summary>Constructs an object from an XML Element with no value filtering.</summary>
            <param name="element">The XML node that defines the object to construct</param>
            <returns>An instantiated and initialized object of the type defined in the XML.</returns>
        </member>
        <member name="M:Hca.Common.Builder.IObjectBuilder.Build(System.Xml.XmlNode,Hca.Common.Builder.TokenFilter)">
            <summary>Constructs an object from an XML Element, filtering values for token expansion.</summary>
            <param name="source">The XML node that defines the object to construct</param>
            <param name="tokenFilter">The filter to use for token expansion.</param>
            <returns>An instantiated and initialized object of the type defined in the XML.</returns>
        </member>
        <member name="P:Hca.Common.Builder.IObjectBuilder.SchemaNamespace">
            <summary>The URI of the schema namespace.</summary>
        </member>
        <member name="T:Hca.Common.Builder.ObjectBuilder">
            <summary>
            Provides functionality to create and initialize objects from an XML representation.
            </summary>
            <remarks>
            	The XML schema that <see cref="T:Hca.Common.Builder.ObjectBuilder"/> uses is defined in the file 
            	<c>ObjectBuilder.xsd.</c> This file is embedded within the common assembly. The resource name 
            	for this file is <c>Hca.Common.Builder.EmbedFile.ObjectBuilder.xsd</c>. The target namespace URI is 
            	<a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Builder/2.0/ObjectBuilder.xsd">http://hcaschema.hca.corpad.net/Common/Builder/2.0/ObjectBuilder.xsd</a>. 
            		
            	<para/>
            	The following table shows the attributes that are associated with each 
            	<see cref="T:Hca.Common.Builder.ObjectBuilder"/> element. Some attributes are required and these are 
            	shown without any decoration around the attribute name. Some attributes are optional and these are 
            	shown with brackets around the attribute name. Default values are shown in parenthesis, e.g. <c>[attributeName](defaultValue)</c>.
            	<para/>
            	<i>ObjectBuilder Elements and Attributes</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="10%">Element</th>
            				<th width="30%">Attributes</th>
            				<th width="60%">Usage</th>
            			</tr>
            			<tr valign="top">
            				<td>object</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>[type](System.String)</term>
            							<description>The type of name of the object.</description>
            						</item>
            						<item>
            							<term>[value]</term>
            							<description>
            								The value of the object. This string must be able to be parsed by 
            								the specified type.
            							</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					Used to define primitive or complex type objects. If type is not specified, 
            					then the <see cref="T:Hca.Common.Builder.ObjectBuilder"/> defaults to the type of the 
            					member being assigned to, or the base type of the collection being assigned to. If 
            					<see cref="T:Hca.Common.Builder.ObjectBuilder"/> cannot discover a type by any of 
            					these methods, then the type of <see cref="T:System.String"/> is assumed. The element 
            					can contain the following elements: <c>object</c>, <c>property</c>, <c>propertyList</c>, 
            					<c>propertyDictionary</c>, and <c>ctorArg</c>. The element also allows mixed content 
            					meaning that text or CDATA character can be placed inside the element and this will be 
            					assumed to be equivalent in meaning to the value attribute. 
            					<hcaNote>
            						It is an error to both set the value attribute and define mixed content.
            					</hcaNote>
            					<hcaNote>
            						An object element with a child object element is considered an array.
            					</hcaNote>
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>ctorArg</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>[type](System.String)</term>
            							<description>The type of name of the object.</description>
            						</item>
            						<item>
            							<term>[value]</term>
            							<description>
            								The value of the object. This string must be able to be parsed by 
            								the specified type.
            							</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					A complex object may optionally contain one or more <c>ctorArg</c> element. The <c>ctorArg</c> 
            					elements represent the type and order of the parameters of the constructor that should be invoked to 
            					initialize the object.
            					<hcaNote type="tip">If no <c>ctorArg</c> elements appear, <see cref="T:Hca.Common.Builder.ObjectBuilder"/> will attempt 
            					to find a default (zero-parameter) constructor.</hcaNote>
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>property</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>name</term>
            							<description>The name of the property.</description>
            						</item>
            						<item>
            							<term>[type]</term>
            							<description>The type name of the object.</description>
            						</item>
            						<item>
            							<term>[value]</term>
            							<description>The value of the object.</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					Represents a property on the object. Properties behave similarly to objects 
            					except that they are named, and can only appear within an object element. 
            					If the type is not specified, the framework will attempt to determine the type 
            					based on the property being assigned to. If the framework cannot determine 
            					the type by any other means, the type of <see cref="T:System.String"/> is assumed.
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>propertyList</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>name</term>
            							<description>The name of the property.</description>
            						</item>
            						<item>
            							<term>[type]</term>
            							<description>The type of the collection (<see cref="T:System.Collections.IList"/>).</description>
            						</item>
            						<item>
            							<term>[defaultValueType]</term>
            							<description>The element base type.</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					Property lists are properties that implement the <see cref="T:System.Collections.IList"/> interface. The 
            					list element contains an optional <c>constructor</c> element and one or more 
            					<c>object</c> child elements that make up the elements in the collection. 
            					The <c>object</c> items must either be of the value type specified or be 
            					assignable to that type.
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>propertyDictionary</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>name</term>
            							<description>The name of the property.</description>
            						</item>
            						<item>
            							<term>[type]</term>
            							<description>
            								The type of the collection (<see cref="T:System.Collections.IDictionary"/>).
            							</description>
            						</item>
            						<item>
            							<term>[defaultKeyType]</term>
            							<description>The type of keys in the collection.</description>
            						</item>
            						<item>
            							<term>[defaultValueType]</term>
            							<description>The type of the values in the collection.</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					Similar to the property list, property dictionary collections must inherit 
            					from <see cref="T:System.Collections.IDictionary"/> and contain optional <c>constructor</c> 
            					element and one or more <c>item</c> child elements that make up the element in the 
            					collection. Keys and values in the child elements must be of or assignable to the 
            					corresponding types defined for the collection.
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>item</td>
            				<td>
            					<list type="definition">
            						<item>
            							<term>[key]</term>
            							<description>The key for this map item.</description>
            						</item>
            						<item>
            							<term>[value]</term>
            							<description>The value for this map item.</description>
            						</item>
            					</list>
            				</td>
            				<td>
            					Represents an item in property dictionary. It may contain child <c>key</c> 
            					and <c>value</c> elements.
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>key</td>
            				<td>See <c>object</c></td>
            				<td>
            					Child of an <c>item</c> element that represents the key of the item. It is 
            					semantically equivalent to the <c>object</c> element.
            				</td>
            			</tr>
            			<tr valign="top">
            				<td>value</td>
            				<td>See <c>object</c></td>
            				<td>
            					Child of an <c>item</c> element that represents the value of the item. It 
            					is semantically equivalent to the <c>object</c> element.
            				</td>
            			</tr>
            		</table>
            	</div>
            	<para/>
            	The type for <c>object</c>, <c>property</c>, <c>propertyList</c>, or <c>propertyDictionary</c> 
            	item value is determined by the following rules:
            	<list type="number">
            		<item>
            			<term>Declared types take precedence.</term>
            		</item>
            		<item>
            			<term>
            				If element is <c>property</c> then use parent object's corresponding named 
            				property type.
            			</term>
            		</item>
            		<item>
            			<term>If element is inside <c>propertyList</c>, then use the <c>defaultValueType</c>.</term>
            		</item>
            		<item>
            			<term>
            				If element is inside <c>propertyDictionary</c>, then use <c>defaultValueType</c> or 
            				<c>defaultKeyType</c>.
            			</term>
            		</item>
            		<item>
            			<term>If the type is still <see langword="null"/>, use <see cref="T:System.String"/>.</term>
            		</item>
            	</list>
            	<para/>
            	A comprehensive <see cref="T:Hca.Common.Builder.ObjectBuilder"/> test configuration file is 
            	shipped with <see cref="N:Hca.Common"/> in its <c>bin</c> folder under its installation location. This file 
            	demonstrates almost all scenarios usages with object builder 2 against its schema.
            
            	<h4 class="dtH4">Specifying types in ObjectBuilder XML</h4>
            	Almost all the elements in the <see cref="T:Hca.Common.Builder.ObjectBuilder"/> XML schema have 
            	one or more type attributes that specify the type of the object or the type of its contained 
            	members or elements. In all cases, the framework adheres to the .NET standard for specifying 
            	types by strings. In general, type names must be fully qualified, for example:
            	<code>
            TopNamespace.SubNameSpace.ClassName,MyAssembly
            	</code>
            	<para/>
            	Types that are defined within shared assemblies loaded from the GAC must specify the assembly strong 
            	name in the type string to ensure the proper assembly and type are loaded:
            	<code>
            System.Collections.Specialized.StringCollection, System, Version=1.0.0.0, 
            Culture=neutral, PublicKeyToken=b77a5c561934e089"
            	</code>
            	<para/>
            	A partially qualified name is sufficient if the type is defined within <c>mscorlib.dll</c> or 
            	<c>Hca.DevBlocks.Common.dll</c>. However, it is always acceptable to specify the 
            	fully qualified name of a type.
            	<para/>
            	.NET also allows for application-wide definition of short-name to strong-name aliases, 
            	using the <c>&lt;<see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfqualifyassemblyelement.htm">qualifyAssembly</see>&gt;</c> configuration element.
            	<para/>
            	<i>Specifying Types in ObjectBuilder</i>
            	<br/>
            	<list type="table">
            		<item>
            			<term><c>type="Hca.Common.Service.ServiceConfig"</c></term>
            			<term>Okay - <see cref="T:Hca.Common.Service.ServiceConfig"/> is defined in <c>Hca_DevBlocks_Common.dll</c>.</term>
            		</item>
            		<item>
            			<term><c>type="System.String"</c></term>
            			<term>Okay - <see cref="T:System.String"/> is defined in <c>mscorlib.dll</c>.</term>
            		</item>
            		<item>
            			<term><c>type="System.Collections.Specialized.StringCollection"</c></term>
            			<term>Insufficient - <see cref="T:System.Collections.Specialized.StringCollection"/> is defined in <c>system.dll</c> and must be fully qualified. (See details above.)</term>
            		</item>
            	</list>
            	<para/>
            	For more information on fully qualified type names in .NET please refer to <see cref="M:System.Type.GetType(System.String)"/>.
            </remarks>
        </member>
        <member name="F:Hca.Common.Builder.ObjectBuilder.OBJECT_SCHEMA_NAMESPACE">
            <summary>
            The URI of the schema namespace that <see cref="T:Hca.Common.Builder.ObjectBuilder"/> enforces.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ObjectBuilder.tokenFilter">
            <summary>Holds the token filter, if any, to be used during a given invocation of <see cref="M:Hca.Common.Builder.ObjectBuilder.Build(System.Xml.XmlNode)"/>.</summary>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CreateObject(System.Type,System.Xml.XmlNode)">
            <summary>
            Constructs an object from an object XML node.
            </summary>
            <param name="baseType">The base type of the object to create. </param>
            <param name="source">The XML element that contains the definition of the object.</param> 
            <returns>A new instance of the specified object type initialized with the values contained 
            within the specified XML element.</returns>
            <remarks>If type is not explicitly specified in the <see cref="T:System.Xml.XmlNode"/>, the type 
            specified in the <paramref name="baseType"/> parameter is used, otherwise the type string is assumed</remarks>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CreateCtor(System.Xml.XmlNode,System.Type,System.Object[]@,System.Boolean)">
            <summary>
            Create a ctor for an XML node.
            </summary>
            <param name="source">XML node that contains the ctor element</param>
            <param name="productType">Type to reflect for the ctor</param>
            <param name="ctorArgs">arguments for the ctor</param>
            <param name="errOnNull">should we error if the ctor is not found?</param>
            <returns>ctor</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.ParseObject(System.Type,System.String)">
            <summary>
            Parses a string value into a value type
            </summary>
            <param name="targetType">The type to parse the value into</param>
            <param name="sourceValue">The string value to parse</param>
            <returns>A value type object assigned the parsed value</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CopyProperties(System.Xml.XmlNodeList,System.Object)">
            <summary>
            Parses the &lt;property&gt; elements within a config element and assigns the values to the 
            corresponding properties on the target object
            </summary>
            <param name="properties">The nodelist that contains the &lt;property&gt; element</param>
            <param name="target">The target object on which to assign the property values</param>
            <exception cref="T:System.ArgumentException">Thrown when an invalid configuration option is encountered</exception>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CopyListProperties(System.Xml.XmlNodeList,System.Object)">
            <summary>
            Parses the list elements within a config element and assigns the values to the corresponding properties on the target object
            </summary>
            <remarks>
            The list type is defaulted to an <see cref="T:System.Collections.ArrayList"/>. The <c>defaultValueType</c> defaults to type <c>string</c>.
            </remarks>
            <param name="lists">The nodelist that contains the &lt;propertyList&gt; element</param>
            <param name="target">The target object on which to assign the property values</param>
            <exception cref="T:System.ArgumentException">Thrown when an invalid configuration 
            option is encountered</exception>  
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CopyDictionaryProperties(System.Xml.XmlNodeList,System.Object)">
            <summary>
            Parses the dictionary elements within a config element and assigns the values to the corresponding properties on the target object
            </summary>
            <remarks>
            The list type is defaulted to an <see cref="T:System.Collections.Hashtable"/>. The <c>defaultValueType</c> and
            <c>defaultKeyType</c> default to type <c>string</c>.
            </remarks>
            <param name="maps">The node that contains the &lt;propertyDictionary&gt; element</param>
            <param name="target">The target object on which to assign the property values</param>
            <exception cref="T:System.ArgumentException">Thrown when an invalid configuration 
            option is encountered</exception>  
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.DetermineValue(System.Xml.XmlNode,System.String)">
            <summary>
            Determine value for an element through its "value" attribute
            or its mixed value via text or CDATA.
            </summary>
            <remarks>
            An XML node will be processed until a child element is reached.
            </remarks>
            <param name="propNode">XML node to examine</param>
            <param name="attributeName">attribute value to check for its value</param>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.GetConstructorArgs(System.Xml.XmlNode,System.Type[]@)">
            <summary>
            Gets the objects that represent the arguments to the constructor of an object element
            </summary>
            <param name="ctorNode">The ctor <see cref="T:System.Xml.XmlNode"/></param>
            <param name="ctorSigs">The signatures of the arguments</param>
            <returns>An array of objects representing the arguments to the constructor</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.CreateArray(System.Type,System.Xml.XmlNode)">
            <summary>
            Constructs an object array from an object array XML element
            </summary>
            <param name="baseType">The type of array to create.</param>
            <param name="source">The XmlElement to process</param>
            <remarks>
            The array type will be defined if the source defines it
            or a base type is supplied, or finally object will be used as a default.
            </remarks>
            <returns>An array of objects defined by the XML node</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.GetObjectType(System.Xml.XmlNode)">
            <summary>
            Returns the type object that describes the type defined in an XML configuration file
            </summary>
            <param name="objectNode">A node that contains a type attribute (object or property)</param>
            <returns>The type object if the type attribute represents a legitimate type otherwise <see langword="null"/></returns>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when an exception is thrown during 
            the initialization of the type class</exception>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.GetObjectType(System.Xml.XmlNode,System.Type)">
            <summary>
            Returns the type object that describes the type defined in an XML configuration file.
            If object indicates an array then the type of its inner objects will be found and returned.
            </summary>
            <param name="objectNode">A node that contains a type attribute (object or property)</param>
            <param name="defaultType">The default type to use if it is not specified by node.</param>
            <returns>The type object if the type attribute represents a legitimate type otherwise null</returns> 
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when an exception is thrown during the 
            initialization of the type class</exception>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.IsArray(System.Xml.XmlNode)">
            <summary>
            Returns the type array that describes the type defined in an XML configuration file
            </summary>
            <param name="objectNode">An array node that may contain a type attribute (array)</param>
            <remarks>
            The type array if the type attribute represents a legitimate type otherwise it will look at the 
            children objects for its implied type.
            </remarks>
            <returns>The array type</returns>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when an exception is thrown during 
            the initialization of the type class</exception>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.GetTypeOfAttribute(System.Xml.XmlNode,System.String,System.Type)">
            <summary>
            Determines the type for a named attribute. If no attribute is found, then the defaultType is returned.
            </summary>
            <param name="sourceNode">The node to analyze</param>
            <param name="attributeName">name of attribute to get type of</param>
            <param name="defaultType">default type to use if attribute is not found</param>
            <returns>The type determined from the node</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.GetAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Retrieve the named attribute from a node.
            </summary>
            <param name="sourceNode">source to look for the attribute</param>
            <param name="name">name of attribute</param>
            <returns>attribute</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.Build(System.Xml.XmlNode)">
            <overloads>Constructs an object from an XML Element</overloads>
            
            <summary>
            Constructs an object from an XML Element without filtering values.
            </summary>
            <param name="source">The XML node that defines the object to construct</param>
            <remarks>
            object, property, propertyList or propertyDictionary item value type is determined as follows:
            <list type="bullets">
            <item>Declared types take precedent. If not declared, then the following rules are in effect.</item>
            <item>property: property's reflected type</item>
            <item>propertyList: defaultValueType which defaults to object</item>
            <item>propertyDictionary: defaultKeyType or defaultValueType which defaults respectively to string and object</item>
            <item>default: object</item>
            </list>
            </remarks>
            <returns>An instantiated and initialized object of the type defined in the XML</returns>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilder.Build(System.Xml.XmlNode,Hca.Common.Builder.TokenFilter)">
            <summary>
            Constructs an object from an XML Element, filtering values for token expansion.
            </summary>
            <param name="source">The XML node that defines the object to construct</param>
            <param name="tokenFilter">The filter to use for token expansion.</param>
            <remarks><see cref="M:Hca.Common.Builder.ObjectBuilder.Build(System.Xml.XmlNode)"/></remarks>
            <returns>An instantiated and initialized object of the type defined in the XML</returns>
        </member>
        <member name="P:Hca.Common.Builder.ObjectBuilder.SchemaNamespace">
            <summary>
            The URI of the schema namespace that defines the XML elements that <see cref="T:Hca.Common.Builder.ObjectBuilder"/> understands
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ObjectBuilderXsdDescriptor">
            <summary>Describes <i>EmbedFile.ObjectBuilder.xsd</i> for programmatic consumption.</summary>
        </member>
        <member name="T:Hca.Common.XsdDescriptorBase">
            <summary>A base implementation of <see cref="P:Hca.Common.IXsdDescriptor.ReferencedXsds"/> that assists in implementing <see cref="P:Hca.Common.IXsdDescriptor.ReferencedXsds"/>.</summary>
        </member>
        <member name="T:Hca.Common.IXsdDescriptor">
            <summary>Describes an XML schema (XSD file) for programmatic consumption.</summary>
            <remarks>This base interface provides functionality necessary for getting and using an instance of <see cref="T:System.Xml.Schema.XmlSchema"/>. Specializations of this interface may provide additional information about a given schema, such as XPaths, or element and attribute names. The intent is to localize all executable schema details and minimize the dispersion of hard-coded strings throughout code.</remarks>
            <example>For an example of the intended specialization, see <see cref="T:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor"/>.</example>
        </member>
        <member name="M:Hca.Common.IXsdDescriptor.GetSchemas">
            <summary>Retrieves all the schema information necessary to validate an XML document written against the schema that this descriptor represents.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the primary XML schema represented by this descriptor, as well as any other schemas referenced by the primary schema.</returns>
        </member>
        <member name="P:Hca.Common.IXsdDescriptor.NamespaceUri">
            <summary>Gets the Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.IXsdDescriptor.ReferencedXsds">
            <summary>Gets a list of the schemas referenced by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="M:Hca.Common.XsdDescriptorBase.GetSchemas">
            <summary>Retrieves all the schema information necessary to validate an XML document written against the schema that this descriptor represents.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the primary XML schema represented by this descriptor, as well as any other schemas referenced by the primary schema.</returns>
        </member>
        <member name="M:Hca.Common.XsdDescriptorBase.GetSchema(System.Reflection.Assembly,System.String)">
            <overloads>Provides an internal implementation of <see cref="M:Hca.Common.XsdDescriptorBase.GetSchemas"/> that automatically includes all schemas from <see cref="P:Hca.Common.XsdDescriptorBase.ReferencedXsds"/> and builds the local schema based on <see cref="P:Hca.Common.XsdDescriptorBase.NamespaceUri"/> and provided file information.</overloads>
            <summary>Provides an internal implementation of <see cref="M:Hca.Common.XsdDescriptorBase.GetSchemas"/> that automatically includes all schemas from <see cref="P:Hca.Common.XsdDescriptorBase.ReferencedXsds"/> and builds the local schema based on <see cref="P:Hca.Common.XsdDescriptorBase.NamespaceUri"/> and provided embedded resource file information.</summary>
            <param name="asm">The <see cref="T:System.Reflection.Assembly"/> containing the embedded resource file.</param>
            <param name="resourceName">The name of the resource within <i>asm</i>.</param>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the schema this descriptor represents, as well as all the schemas it references.</returns>
        </member>
        <member name="M:Hca.Common.XsdDescriptorBase.GetReferencedSchemas">
            <summary>Retrieves the schemas represented by the elements of <see cref="P:Hca.Common.XsdDescriptorBase.ReferencedXsds"/>.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the schemas referenced by the XML schema that this descriptor represents.</returns>
        </member>
        <member name="P:Hca.Common.XsdDescriptorBase.NamespaceUri">
            <summary>(Inherited from <see cref="T:Hca.Common.IXsdDescriptor"/>.) Gets the Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.XsdDescriptorBase.ReferencedXsds">
            <summary>(Inherited from <see cref="T:Hca.Common.IXsdDescriptor"/>.) Gets a list of the schemas referenced by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="F:Hca.Common.Builder.ObjectBuilderXsdDescriptor.SCHEMA_RESOURCE_NAME">
            <summary>The name of the embedded resource containing the .XSD file.</summary>
        </member>
        <member name="F:Hca.Common.Builder.ObjectBuilderXsdDescriptor.SCHEMA_NAMESPACE_URI">
            <summary>The Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="F:Hca.Common.Builder.ObjectBuilderXsdDescriptor.schemas">
            <summary>Holds the cached result of <see cref="M:Hca.Common.Builder.ObjectBuilderXsdDescriptor.GetSchemas"/>.</summary>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilderXsdDescriptor.#ctor">
            <summary>Private constructor supports / enforces singleton pattern.</summary>
        </member>
        <member name="M:Hca.Common.Builder.ObjectBuilderXsdDescriptor.GetSchemas">
            <summary>Retrieves all the schema information necessary to validate an XML document written against the schema that this descriptor represents.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the primary XML schema represented by this descriptor, as well as any other schemas referenced by the primary schema.</returns>
        </member>
        <member name="P:Hca.Common.Builder.ObjectBuilderXsdDescriptor.Instance">
            <summary>Gets the singleton instance of <see cref="T:Hca.Common.Builder.ObjectBuilderXsdDescriptor"/>.</summary>
        </member>
        <member name="P:Hca.Common.Builder.ObjectBuilderXsdDescriptor.NamespaceUri">
            <summary>Gets the Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.Builder.ObjectBuilderXsdDescriptor.ReferencedXsds">
            <summary>Gets a list of the schemas referenced by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="T:Hca.Common.Builder.Token">
            <summary>Specifies a name/value pair to be used in string token expansion.</summary>
        </member>
        <member name="F:Hca.Common.Builder.Token.name">
            <summary>Holds the token name for which to search.</summary>
        </member>
        <member name="F:Hca.Common.Builder.Token.value">
            <summary>Holds the value with which occurrences of this token should be replaced.</summary>
        </member>
        <member name="M:Hca.Common.Builder.Token.#ctor(System.String,System.String)">
            <summary>Initializes an instance.</summary>
            <param name="name">The token name for which to search</param>
            <param name="value">The value with which occurrences of this token should be replaced.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="name"/> is <see langword="null"/> or empty.</exception>
        </member>
        <member name="M:Hca.Common.Builder.Token.Equals(System.Object)">
            <summary>
            Provides value semantic equality check.
            Refer to <see cref="M:System.Object.Equals(System.Object)"/> for additional details
            </summary>
            <param name="obj">The object to equate</param>
            <returns><see langword="true"/> if this and the passed object are value semantic equal</returns>
        </member>
        <member name="M:Hca.Common.Builder.Token.GetHashCode">
            <summary>
            Provides a hash value based on all fields that contribute to value semantic equality.
            Refer to <see cref="M:System.Object.GetHashCode"/> for additional details
            </summary>
            <returns>A hash code value for this object.</returns>
        </member>
        <member name="M:Hca.Common.Builder.Token.op_Equality(Hca.Common.Builder.Token,Hca.Common.Builder.Token)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="obj1">First object to equate.</param>
            <param name="obj2">Second object to equate.</param>
            <returns><see langword="true"/> if both objects equate the same based on value semantics.</returns>
        </member>
        <member name="M:Hca.Common.Builder.Token.op_Inequality(Hca.Common.Builder.Token,Hca.Common.Builder.Token)">
            <summary>
            Operator overload for InEquality.
            </summary>
            <param name="obj1">First object to equate</param>
            <param name="obj2">Second object to equate</param>
            <returns><see langword="true"/> if obj1 does not equate equal to obj2 using value semantics</returns>
        </member>
        <member name="P:Hca.Common.Builder.Token.Name">
            <summary>Gets the token name for which to search.</summary>
        </member>
        <member name="P:Hca.Common.Builder.Token.Value">
            <summary>Gets the value with which occurrences of this token should be replaced.</summary>
        </member>
        <member name="T:Hca.Common.Builder.TokenCollection">
            <summary>Maintains a strongly-typed list of <see cref="T:Hca.Common.Builder.Token"/>s.</summary>
            <remarks>The class exists primarily for its <see cref="M:Hca.Common.Builder.TokenCollection.Contains(System.String)"/> method, which takes a token name that can be either delimited or not.</remarks>
        </member>
        <member name="F:Hca.Common.Builder.TokenCollection.tokenDelimiter">
            <summary>Holds the token delimiter character for this instance.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenCollection.tokensByName">
            <summary>Holds the list of delimited tokens indexed by <see cref="P:Hca.Common.Builder.Token.Name"/>.</summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.#ctor">
            <summary>Initializes an instance with the default delimiter character.</summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.#ctor(System.Char)">
            <summary>Initializes an instance with the specified delimiter character.</summary>
            <param name="tokenDelimiter">The token delimiter character for this instance.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.Add(Hca.Common.Builder.Token)">
            <overloads>Adds a token definition to the list.</overloads>
            <summary>Adds a token definition to the list without overriding any existing tokens with the same name.</summary>
            <param name="value">The new token definition.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="value"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.Add(Hca.Common.Builder.Token,System.Boolean)">
            <summary>Adds a token definition to the list, optionally overriding any instance with this name that has already been added.</summary>
            <param name="value">The new token definition.</param>
            <param name="allowReplacement">Whether to replace any existing known token with the same name.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="allowReplacement"/> is <see langword="false"/> and <paramref name="value"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.AddRange(Hca.Common.Builder.Token[])">
            <overloads>Adds a series of token definitions to the list.</overloads>
            
            <summary>Adds an array of token definitions to the list without replacing any existing tokens with the same name.</summary>
            <param name="values">The new token definition.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="values"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.AddRange(Hca.Common.Builder.Token[],System.Boolean)">
            <summary>Adds an array of token definitions to the list, optionally overriding any instance with this name that has already been added.</summary>
            <param name="values">The new token definitions.</param>
            <param name="allowReplacement">Whether to replace any existing known token with the same name.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="allowReplacement"/> is <see langword="false"/> and <paramref name="values"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.AddRange(Hca.Common.Builder.TokenCollection)">
            <overloads>Adds the contents of another instance to this list.</overloads>
            <summary>Adds the contents of another instance to this list without replacing any existing tokens with the same name.</summary>
            <param name="values">The new token definition.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="values"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.AddRange(Hca.Common.Builder.TokenCollection,System.Boolean)">
            <summary>Adds the contents of another instance to this list, optionally overriding any instance with this name that has already been added.</summary>
            <param name="values">The new token definitions.</param>
            <param name="allowReplacement">Whether to replace any existing known token with the same name.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="allowReplacement"/> is <see langword="false"/> 
            and <paramref name="values"/>.<see cref="P:Hca.Common.Builder.Token.Name"/> contains <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.Clear">
            <summary>
            Removes all items from the collection.
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.Contains(System.String)">
            <summary>Searches the collection for a <see cref="T:Hca.Common.Builder.Token"/> with the specified name.</summary>
            <param name="tokenName">The token name for which to search.</param>
            <returns><see langword="true"/> if a token with the specified name exists in the collection; 
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.OnAdded(Hca.Common.Builder.Token)">
            <summary>Raises the <see cref="E:Hca.Common.Builder.TokenCollection.Added"/> event.</summary>
            <param name="token">The <see cref="P:Hca.Common.Builder.TokenEventArgs.Token"/> value for this event's <see cref="T:Hca.Common.Builder.TokenEventArgs"/>.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenCollection.GetEnumerator">
            <summary>Returns an enumerator that can iterate through the collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="E:Hca.Common.Builder.TokenCollection.Added">
            <summary>Raised when an <see cref="M:Hca.Common.Builder.TokenCollection.Add(Hca.Common.Builder.Token)"/> or <see cref="M:Hca.Common.Builder.TokenCollection.AddRange(Hca.Common.Builder.Token[])"/> has just been performed.</summary>
        </member>
        <member name="P:Hca.Common.Builder.TokenCollection.Item(System.String)">
            <summary>Searches the collection for a <see cref="T:Hca.Common.Builder.Token"/> with the specified name.</summary>
            <param name="tokenName">The token name for which to search.</param>
            <returns>A token with the specified name if one exists in the collection; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="T:Hca.Common.Builder.TokenEventArgs">
            <summary>Abstracts the values passed with an event that effects a <see cref="P:Hca.Common.Builder.TokenEventArgs.Token"/>.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenEventArgs.token">
            <summary>Holds the affected <see cref="P:Hca.Common.Builder.TokenEventArgs.Token"/>.</summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenEventArgs.#ctor(Hca.Common.Builder.Token)">
            <summary>Initializes an instance.</summary>
            <param name="token">The affected <see cref="P:Hca.Common.Builder.TokenEventArgs.Token"/>.</param>
        </member>
        <member name="P:Hca.Common.Builder.TokenEventArgs.Token">
            <summary>Gets the affected <see cref="P:Hca.Common.Builder.TokenEventArgs.Token"/>.</summary>
        </member>
        <member name="T:Hca.Common.Builder.TokenFilter">
            <summary>Used to replace delimited tokens in a string with their expanded values.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenFilter.DEFAULT_TOKEN_DELIMITER">
            <summary>The default delimiter character.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenFilter.tokenDelimiter">
            <summary>Holds the token delimiter character for this instance.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenFilter.knownTokens">
            <summary>Holds the list of delimited tokens known to this instance.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenFilter.processedTokens">
            <summary>Holds the list of tokens after token replacement is performed.</summary>
        </member>
        <member name="F:Hca.Common.Builder.TokenFilter.handleInterdependencies">
            <summary>Holds the interdependency handling for this instance.</summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor">
            <overloads>Initializes an instance.</overloads>
            
            <summary>Initializes an instance with no known token definitions and the default delimiter character and no interdependency handling.</summary>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(Hca.Common.Builder.Token[])">
            <summary>Initializes an instance with the specified list of known token definitions and the default delimiter character and no interdependency handling.</summary>
            <param name="knownTokens">The list of tokens known to this instance.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(System.Char)">
            <summary>Initializes an instance with no known token definitions and a custom delimiter character and no interdependency handling.</summary>
            <param name="tokenDelimiter">The token delimiter character for this instance.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(System.Boolean)">
            <summary>Initializes an instance with no known token definitions and the default delimiter character and the specified interdependency handling.</summary>
            <param name="handleInterdependencies">Indicate whether tokens should be replaced in token values.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(Hca.Common.Builder.Token[],System.Char)">
            <summary>Initializes an instance with the specified list of known token definitions and a custom delimiter character and no interdependency handling.</summary>
            <param name="knownTokens">The list of tokens known to this instance.</param>
            <param name="tokenDelimiter">The token delimiter character for this instance.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(Hca.Common.Builder.Token[],System.Boolean)">
            <summary>Initializes an instance with the specified list of known token definitions and the default delimiter character and the specified interdependency handling.</summary>
            <param name="knownTokens">The list of tokens known to this instance.</param>
            <param name="handleInterdependencies">Indicate whether tokens should be replaced in token values.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(System.Char,System.Boolean)">
            <summary>Initializes an instance with no known token definitions and a custom delimiter character and the specified interdependency handling.</summary>
            <param name="tokenDelimiter">The token delimiter character for this instance.</param>
            <param name="handleInterdependencies">Indicate whether tokens should be replaced in token values.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.#ctor(Hca.Common.Builder.Token[],System.Char,System.Boolean)">
            <summary>Initializes an instance with the specified list of known token definitions and a custom 
            delimiter character and the specified interdependency handling.</summary>
            <param name="knownTokens">The list of tokens known to this instance.</param>
            <param name="tokenDelimiter">The token delimiter character for this instance.</param>
            <param name="handleInterdependencies">Indicate whether tokens should be replaced in token values.</param>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.ReplaceKnownTokens(System.String)">
            <summary>Searches a given string for occurrences of this instance's known tokens and replaces them with their expanded values.</summary>
            <param name="input">The string in which to replace tokens.</param>
            <returns>The input string with all occurrences of this instance's known tokens replaced with their expanded values.</returns>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.DelimitTokenName(System.String)">
            <overloads>Prefixes and suffixes a token name with a delimiter character, 
            if the name is not already delimited.</overloads>
            <summary>Prefixes and suffixes a token name with this instance's delimiter character, if the name is not already delimited.</summary>
            <param name="tokenName">The token name.</param>
            <returns><paramref name="tokenName"/> prefixed and suffixed with this instance's delimiter character.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="tokenName"/> is empty or <see langword="null"/> or 
            contains a non-delimiting instance of <see cref="P:Hca.Common.Builder.TokenFilter.TokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.ReplaceToken(System.String,System.String,System.String)">
            <overloads>Searches a given string for occurrences of a specified token and replaces them with the expanded value.</overloads>
            
            <summary>Searches a given string for occurrences of a specified token (identified by <see cref="P:Hca.Common.Builder.TokenFilter.DefaultTokenDelimiter"/>) and replaces them with the expanded value.</summary>
            <param name="input">The string in which to replace tokens.</param>
            <param name="tokenName">The name of the token for which to search.</param>
            <param name="tokenValue">The value with which to replace occurrences of the token.</param>
            <returns>The input string with all occurrences of the specified token replaced with the expanded values.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="tokenName"/> is <see langword="null"/> or empty, or if it contains <see cref="P:Hca.Common.Builder.TokenFilter.DefaultTokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.ReplaceToken(System.String,System.String,System.String,System.Char)">
            <summary>Searches a given string for occurrences of a specified token (identified by a specified delimiter character) and replaces them with the expanded value.</summary>
            <param name="input">The string in which to replace tokens.</param>
            <param name="tokenName">The name of the token for which to search.</param>
            <param name="tokenValue">The value with which to replace occurrences of the token.</param>
            <param name="tokenDelimiter">The token delimiter character.</param>
            <returns>The input string with all occurrences of the specified token replaced with the expanded values.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="tokenName"/> is <see langword="null"/> or empty, or if it contains <paramref name="tokenDelimiter"/>.</exception>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.ReplaceDelimitedToken(System.String,System.String,System.String)">
            <summary>Searches a given string for occurrences of a specified token and replaces them with the expanded value.</summary>
            <param name="input">The string in which to replace tokens.</param>
            <param name="delimitedTokenName">The name of the token for which to search, prefixed and suffixed with a delimiter character.</param>
            <param name="tokenValue">The value with which to replace occurrences of the token.</param>
            <returns>The input string with all occurrences of the specified token replaced with the expanded values.</returns>
        </member>
        <member name="M:Hca.Common.Builder.TokenFilter.DelimitTokenName(System.String,System.Char)">
            <summary>Prefixes and suffixes a token name with a given delimiter character.</summary>
            <param name="tokenName">The token name.</param>
            <param name="delimiter">The token delimiter character.</param>
            <returns><paramref name="tokenName"/> prefixed and suffixed with this instance's delimiter character.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="tokenName"/> is 
            empty or <see langword="null"/> or contains a non-delimiting instance of <paramref name="delimiter"/>.</exception>
        </member>
        <member name="P:Hca.Common.Builder.TokenFilter.DefaultTokenDelimiter">
            <summary>Gets the default delimiter character.</summary>
        </member>
        <member name="P:Hca.Common.Builder.TokenFilter.TokenDelimiter">
            <summary>Gets this instance's delimiter character.</summary>
        </member>
        <member name="P:Hca.Common.Builder.TokenFilter.KnownTokens">
            <summary>Gets the list of delimited tokens known to this instance.</summary>
        </member>
        <member name="T:Hca.Common.Builder.TokenFilter.TokenEventHandler">
            <summary>Abstracts the handling of an event that effects a <see cref="T:Hca.Common.Builder.Token"/>.</summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringBuilder">
             <summary>
             <p>Assists in implementing <c>ToString()</c> methods.</p>
             </summary>
             <threadsafety static="true" instance="false"/>
             
             <remarks>
             <p>This class enables a good and consistent <c>ToString()</c> to be built for any
             class or object. This class aims to simplify the process by:</p>
             <ul>
              <li>handling all types consistently</li>
              <li>handling nulls consistently</li>
              <li>outputting arrays and multi-dimensional arrays</li>
              <li>enabling the detail level to be controlled for objects</li>
              <li>handling class hierarchies</li>
             </ul>
            
             <p>To use this class write code as follows:</p>
            
             <code>
             public class Person {
               string name;
               int age;
               bool isSmoker;
             
               ...
             
               public override string ToString() {
                 return new ToStringBuilder(this).
                   Append(name, "name").
                   Append(age, "age").
                   Append(isSmoker, "smoker").
                   ToString();
               }
             }
             </code>
            
             <p>This will produce a ToString of the format:
             <code>Person@7f54[name=Stephen,age=29,smoker=False]</code>
             The hash code following the @ symbol is represented in hex.
             Field values are represented in base 10.
             </p>
             
             <p>To add the base class <c>ToString</c>, use <see cref="M:Hca.Common.Builder.ToStringBuilder.AppendSuper(System.String)"/>.
             <code>
             public class Person {
               string name;
               int age;
               bool isSmoker;
             
               ...
             
               public override string ToString() {
                 return new ToStringBuilder(this).
                   Append(name, "name").
                   Append(age, "age").
                   Append(isSmoker, "smoker").
                   AppendSuper(new ToStringBuilder().Append(base).ToString()).
                   ToString();
               }
             }
             </code>
             To append the <c>toString</c> from an object that is delegated
             to (or any other object), use <see cref="M:Hca.Common.Builder.ToStringBuilder.AppendToString(System.String)"/>.</p>
             <code>
             public class Person {
               string name;
               int age;
               bool isSmoker;
               SomeComplexType complexType;
             
               ...
             
               public override string ToString() {
               
                string tempToString = new ToStringBuilder().Append(complexType).ToString();
               
                 return new ToStringBuilder(this).
                   Append(name, "name").
                   Append(age, "age").
                   Append(isSmoker, "smoker").
                   Append(complexType).
                   AppendToString(tempToString).
                   ToString();
               }
             }
            </code>
             Alternatively, it is possible to use reflection to build a ToString.  
             This method of building a ToString is slower than the method show above.
             
             <p>A typical invocation for this method would look like:</p>
             
             <code>
             public String toString() 
             {
            		//Return all members of this to the first level of recursion.
                 return new ToStringBuilder().Append(this, ToStringStyle.DetailLevel.FullRecursiveDetail, 1).ToString();
             }    
             </code>
             <p>You can also use the builder to debug 3rd party objects:</p>
             
             <code>
             string myString = new ToStringBuilder().Append(anObject, ToStringStyle.DetailLevel.FullRecursiveDetail).ToString();
             </code>
             
             <p>The exact format of the <c>ToString</c> is determined by
             the <see cref="T:Hca.Common.Builder.ToStringStyle"/> passed into the constructor.</p>
             
             <code>
             string myString = new ToStringBuilder(ToStringStyle.TABBED_MULTI_LINE_STYLE).Append(anObject, ToStringStyle.DetailLevel.FullRecursiveDetail).ToString();
             
             string myString = new ToStringBuilder(ToStringStyle.MULTI_LINE_STYLE).Append(anObject, ToStringStyle.DetailLevel.FullRecursiveDetail).ToString();
             
             string myString = new ToStringBuilder(ToStringStyle.NO_FIELD_NAMES_STYLE).Append(anObject, ToStringStyle.DetailLevel.FullRecursiveDetail).ToString();
             </code>
             <p>
             This class was derived from the Apache Software Foundation's
             toStringBuilder.  </p>
             </remarks>	
        </member>
        <member name="F:Hca.Common.Builder.ToStringBuilder.buffer">
            Used to build the string.  This will be passed into the style.
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Builder.ToStringBuilder"/>.</overloads>
            <summary>
            Used to create a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> that will use the default style, create
            an internal <see cref="T:System.Text.StringBuilder"/>, not append object beginning and ending tags.  
            Not specifying a targetObject is useful if you are using the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> 
            detail level.
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.#ctor(System.Object)">
            <summary>
            Used to create a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> that will use the default style and create
            an internal <see cref="T:System.Text.StringBuilder"/>.  
            </summary>
            <param name="target">The object for which the ToString builder is building output</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.#ctor(Hca.Common.Builder.ToStringStyle)">
            <summary>
            Used to create a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> that will create it's own internal <see cref="T:System.Text.StringBuilder"/> and 
            not append object beginning and ending tags. 
            Not specifying a target object is useful if you are using the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> 
            detail level.
            </summary>
            <param name="style">The style that will be used</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.#ctor(System.Object,Hca.Common.Builder.ToStringStyle)">
            <summary>
            Used to create a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> that will create it's own internal <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="target">The object for which the ToString builder is building output</param>
            <param name="style">The style that will be used</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.#ctor(System.Object,Hca.Common.Builder.ToStringStyle,System.Text.StringBuilder)">
            <summary>
            Used to create a new string builder.
            </summary>
            <param name="target">The object for which the ToString builder is building output</param>
            <param name="style">The style that will be used</param>
            <param name="buffer">The <see cref="T:System.Text.StringBuilder"/> that 
            the <see cref="T:Hca.Common.Builder.ToStringBuilder"/> will append it's output.</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object)">
            <overloads>Appends an object to the output buffer using the current style.</overloads>
            
            <summary>
            Appends an object to the output buffer using the current style
            and the default detail level of <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullDetail"/>.
            </summary>
            <param name="target">The object to append to the buffer</param>
            <returns>Returns its self.</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="detailLevel">The level of detail to output</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Type)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="reflectUpToClass"/>
            parameter is used to specify which object in the chain to recurse up to. If the
            class is not found all object in the hierarchy will be returned.
            This is assuming that the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. 
            </summary>
            <param name="target">The object to append to the buffer.</param>
            <param name="detailLevel">The level of detail to output. </param>
            <param name="reflectUpToClass">The class to reflect up to.</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="recursionLevel"/> parameter
            is used to specify how far up the inheritance chain to recurse. This is assuming that the
            <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="detailLevel">The level of detail to output</param>
            <param name="recursionLevel">The number of levels to go up the inheritance chain.</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32,System.Type)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="reflectUpToClass"/>
            parameter is used to specify which object in the chain to recurse up to. If the
            class is not found all object in the hierarchy will be returned. The <paramref name="recursionLevel"/> 
            parameter is used to specify how far up the inheritance chain to recurse. This 
            is assuming that the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="detailLevel">The level of detail to output</param>
            <param name="recursionLevel">The number of levels to go up the inheritance chain</param>
            <param name="reflectUpToClass">The class to reflect up to</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,System.String)">
            <summary>
            Appends an object to the output buffer using the current style
            and the default detail level of <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullDetail"/>.  The parameter <paramref name="fieldName"/>
            is used to specify the name of the field to which the target object is assigned.
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="fieldName">Used to specify the name of the field to which the target object is assigned.</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,System.String,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The 
            parameter <paramref name="fieldName"/> is used to specify the name of the field 
            to which the target object is assigned. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="fieldName">Used to specify the name of the field to which the target object is assigned</param>
            <param name="detailLevel">The level of detail to output</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,System.String,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Type)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="reflectUpToClass"/>
            parameter is used to specify which object in the chain to recurse up to. If the
            class is not found all objects in the hierarchy will be returned.
            This is assuming that the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. 
            The parameter <paramref name="fieldName"/> is used to specify the name of the field 
            to which the target object is assigned. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="fieldName">Used to specify the name of the field to which the target object is assigned</param>
            <param name="detailLevel">The level of detail to output</param>
            <param name="reflectUpToClass">The class to reflect up to</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,System.String,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="recursionLevel"/> parameter
            is used to specify how far up the inheritance chain to recurse. This is assuming that the
            <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. 
            The parameter <paramref name="fieldName"/> is used to specify the name of the field to which the target object is assigned.  
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="fieldName">Used to specify the name of the field to which the target object is assigned</param>
            <param name="detailLevel">The level of detail to output</param>
            <param name="recursionLevel">The number of levels to go up the inheritance chain</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.Append(System.Object,System.String,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32,System.Type)">
            <summary>
            Appends <paramref name="target"/> to the output buffer using the current style
            and the detail level specified by the <paramref name="detailLevel"/> parameter. The <paramref name="reflectUpToClass"/>
            parameter is used to specify which object in the chain to recurse up to. If the
            class is not found all object in the hierarchy will be returned. The <paramref name="recursionLevel"/> 
            parameter is used to specify how far up the inheritance chain to recurse. This 
            is assuming that the <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> detail level was specified. The parameter 
            <paramref name="fieldName"/> is used to specify the name of the field to which the target object is assigned. 
            </summary>
            <param name="target">The object to append to the buffer</param>
            <param name="fieldName">Used to specify the name of the field to which the target object is assigned</param>
            <param name="detailLevel">The level of detail to output</param>
            <param name="recursionLevel">The number of levels to go up the inheritance chain</param>
            <param name="reflectUpToClass">"The class to reflect up to</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.AppendSuper(System.String)">
            <summary>
            This method appends the toString output from a base class.  If
            the to string output is not used, the input string will usually
            be ignored. This is decedent on the style used.
            </summary>
            <param name="value">ToString output from a base class</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.AppendToString(System.String)">
            <summary>
            Append the <c>ToString</c> from another object.
            <p>This method is useful where a class delegates most of the implementation of
            its properties to another class. You can then call <c>ToString()</c> on
            the other class and pass the result into this method.</p>
            </summary>
            <param name="value">The ToString from another object</param>
            <returns>Returns its self</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringBuilder.ToString">
            <summary>
            Returns the built <c>toString</c>.
            <p>This method appends the end of data indicator, and can only be called once.
            Use the property <see cref="P:Hca.Common.Builder.ToStringBuilder.Buffer"/> to get the current string state</p>
            </summary>
            <returns>Returns the completed string</returns>
        </member>
        <member name="P:Hca.Common.Builder.ToStringBuilder.DefaultStyle">
            <summary>
            Set or gets the default style for all <see cref="T:Hca.Common.Builder.ToStringBuilder"/> instances.  This should only be called during application startup
            otherwise the ToString output could be of mixed styles.  Once a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> is instantiate the property will not
            change the style that is used.  The <see cref="P:Hca.Common.Builder.ToStringBuilder.DefaultStyle"/> is used to set the style in the constructor 
            if a style is not specified.
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringBuilder.Buffer">
            <summary>
            Returns the <see cref="T:System.Text.StringBuilder"/> that is used internally.  Once an instance of 
            <see cref="T:Hca.Common.Builder.ToStringStyle"/> has been instantiated the internal buffer can not be changed.  
            However an existing <see cref="T:System.Text.StringBuilder"/> can be passed into 
            the <see cref="T:System.Text.StringBuilder"/>'s constructor.
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringBuilder.Style">
            <summary>
            Returns the <see cref="T:Hca.Common.Builder.ToStringStyle"/> that is used internally for formatting.  Once an 
            instance of <see cref="T:Hca.Common.Builder.ToStringStyle"/> has been instantiated the <see cref="T:Hca.Common.Builder.ToStringStyle"/> can not be changed.  
            However an existing <see cref="T:Hca.Common.Builder.ToStringStyle"/> can be passed into the <see cref="T:System.Text.StringBuilder"/>'s constructor.
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringBuilder.Target">
            <summary>
            This gets the object for which the ToString builder is building output.
            This is used mainly to set the ending and starting tags.
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringFormatter">
            <summary>
            <para>Implements <see cref="T:System.IFormattable"/> to allow for a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> to used more easily.</para>
            <para>See the <see cref="M:Hca.Common.Builder.ToStringFormatter.ToString(System.String,System.IFormatProvider)"/> method for usage information.</para>
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="F:Hca.Common.Builder.ToStringFormatter.targetObject">
            <summary>
            Logger for the class - This is commented out by default.  Uncomment if this class
            requires logging.  Also, if the logging functionality is not required in production,
            remember to comment this code out again before building for release.
            </summary>		
        </member>
        <member name="M:Hca.Common.Builder.ToStringFormatter.#ctor(System.Object)">
            <summary>
            Constructor for <see cref="T:Hca.Common.Builder.ToStringFormatter"/>.  
            </summary>
            <param name="target">The object that is to be converted into a string representation.</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringFormatter.ToString(System.String,System.IFormatProvider)">
            <summary>
            Implements the <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/> method to provide formatting using a <see cref="T:Hca.Common.Builder.ToStringBuilder"/>. 
            </summary>
            <remarks>
            <para>
            <see cref="M:Hca.Common.Builder.ToStringFormatter.ToString(System.String,System.IFormatProvider)"/> creates a new instance of a <see cref="T:Hca.Common.Builder.ToStringBuilder"/> that reflects the 
            formatting and detail tags specified. The object that is passed into the constructor of this object will be 
            converted to its string representation by the <see cref="T:Hca.Common.Builder.ToStringBuilder"/> and returned.
            </para>
            
            <para><b>Formatting code: </b></para>
            
            <para>
            <b><see cref="T:Hca.Common.Builder.ToStringBuilder"/> Styles:</b> 
            SM TABBED_MULTI_LINE_STYLE, sm MULTI_LINE_STYLE, sn NO_FIELD_NAMES_STYLE, ss SIMPLE_STYLE
            </para>
            <para>
            <b><see cref="T:Hca.Common.Builder.ToStringBuilder"/> Levels:</b> ds SummaryDetail, df FullDetail, dr FullRecursiveDetail
            </para>
            
            <para>To specify detail and formatting the style must be specified followed by the detail level.  Either may be omitted.</para>
            <para><b>Example:</b></para>
            <code>string str = String.Format("{0:[sm, dr]}", new ToStringFormatter(someObject));</code>
            
            <para>See <see cref="T:Hca.Common.Builder.ToStringBuilder"/> and <see cref="T:Hca.Common.Builder.ToStringStyle"/> 
            for the meaning of styles and detail levels.</para>
            </remarks>
            <param name="format">Formatting codes provided above.</param>
            <param name="formatProvider">Not used</param>
            <returns>A String containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle">
            <summary>
            <para>Controls <c>string</c> formatting for <see cref="T:Hca.Common.Builder.ToStringBuilder"/>.
            The main public interface is always via <see cref="T:Hca.Common.Builder.ToStringBuilder"/>.</para>
            </summary>
             
            <remarks>
            <para>These classes are intended to be used as Singletons.
            There is no need to instantiate a new style each time. A program 
            will generally use one of the predefined constants on this class.</para>
             
            <para>If required, a subclass can override as many or as few of the
            methods as it requires. All value types and reference types are handled
            to <see cref="T:Hca.Common.Builder.ToStringStyle"/>. Most have three levels of detail, 
            <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.SummaryDetail"/>, <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullDetail"/>,
            and <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/>. <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.SummaryDetail"/>, for the most part,
            will give terse output. For example it will not output the contents of
            an array but only give its size. <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullDetail"/> goes a step farther 
            and will output the members of an array and call the ToString on any other
            objects. <see cref="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail"/> will traverse the entire object graph using 
            recursion.  It is possible to set a class to stop traversing and/or the
            level at which to stop traversing the graph.  
            </para>
            </remarks>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.DEFAULT_STYLE">
            <summary>
            Default <see cref="T:Hca.Common.Builder.ToStringStyle"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.TABBED_MULTI_LINE_STYLE">
            <summary>
             Tabbed multi line <see cref="T:Hca.Common.Builder.ToStringStyle"/>.
            </summary>	
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.MULTI_LINE_STYLE">
            <summary>
             Multi line <see cref="T:Hca.Common.Builder.ToStringStyle"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.NO_FIELD_NAMES_STYLE">
            <summary>
            The no field names <see cref="T:Hca.Common.Builder.ToStringStyle"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.SIMPLE_STYLE">
            <summary>
            The simple <see cref="T:Hca.Common.Builder.ToStringStyle"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.useFieldNames">
            <summary>
             Whether to use the field names, the default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.useClassName">
            <summary>
            Whether to use the class name, the default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.useShortClassName">
            <summary>
            Whether to use short class names, the default is <see langword="false"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.useIdentityHashCode">
            <summary>
            Whether to use the identity hash code, the default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.contentStart">
            <summary>
            The content start <c>'['</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.contentEnd">
            <summary>
            The content end <c>']'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.fieldNameValueSeparator">
            <summary>
            The field name value separator <c>'='</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.fieldSeparatorAtStart">
            <summary>
            The field name value separator <c>'='</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.fieldSeparatorAtEnd">
            <summary>
            Whether the field separator should be added after any other fields.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.fieldSeparator">
            <summary>
             The field separator <c>','</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.arrayStart">
            <summary>
            The array start <c>'{'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.arraySeparator">
            <summary>
            The array separator <c>','</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.arrayContentDetail">
            <summary>
            The detail for array content.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.arrayEnd">
            <summary>
            The array end <c>'}'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.defaultDetailLevel">
            <summary>
            The value to use when <c>detailLevel</c> is <see langword="null"/>,
            the default value is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.nullText">
            <summary>
            The <see langword="null"/> text <c>'&lt;null&gt;'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.sizeStartText">
            <summary>
            The summary size text start <c>'size'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.sizeEndText">
            <summary>
            The summary size text start <c>'&gt;'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.summaryObjectStartText">
            <summary>
            The summary object text start <c>'&lt;'</c>
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.summaryObjectEndText">
            <summary>
            The summary object text start <c>'&gt;'</c>.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.tabCharacter">
            <summary>
            The summary object tabbing character <c>'  '</c>.
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type)">
            <overloads>Appends an object's string representation to the string buffer using the style of this object.</overloads>
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the object
            is not then the type will be inferred from the target.  If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> will be returned 
            allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but 
            the type does not match the target then type will be changed to the type of the target object.
            
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the target
            is not then the type will be inferred from the target.  If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> 
            will be returned allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but 
            the type does not match the target then type will be changed to the type of the target object.
            
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
            <param name="detailLevel">The level of detail about the object to append to the string</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Type)">
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the target
            is not then the type will be inferred from the <paramref name="target"/>.  
            If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> 
            will be returned allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but the type does not 
            match the target then type will be changed to 
            the type of the target object.
            </summary>
            
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
            <param name="detailLevel">The level of detail about the object to append to the string</param>
            <param name="reflectUpToClass">The object to stop at in the object graph</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32)">
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the target
            is not then the type will be inferred from the target.  If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> 
            will be returned allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but the 
            type does not match the target then type will be changed to 
            the type of the target object.
            
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
            <param name="detailLevel">The level of detail about the object to append to the string</param>
            <param name="maxRecursionLevel">
            The number of levels to traverse each object.  That is for each object that is encountered in the object graph;
            how many levels up the inheritance chain to traverse.
            </param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32,System.Type)">
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the target
            is not then the type will be inferred from the target.  If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> 
            will be returned allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but the 
            type does not match the target then type will be changed to 
            the type of the target object.
            
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if the recursion level is less than zero 
            or if <paramref name="buffer"/> is <see langword="null"/>.</exception>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
            <param name="detailLevel">		
            The number of levels to traverse each object.  That is for each object that is encountered in the object graph;
            how many levels up the inheritance chain to traverse.
            </param>
            <param name="maxRecursionLevel">The number of levels to traverse each object</param>
            <param name="reflectUpToClass">The object to stop at in the object graph</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendStart(System.Text.StringBuilder,System.Object)">
            <overloads>Appends the start of data indicator.</overloads>
            <summary>
            Appends to the <c>ToString</c> buffer the start of data indicator.
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="target">The target object to append to the string</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnd(System.Text.StringBuilder,System.Object)">
            <overloads>Appends the end of data indicator.</overloads>
            <summary>
            Appends to the <c>ToString</c> buffer the end of data indicator.
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="target">The target object to append to the string</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendSuper(System.Text.StringBuilder,System.String)">
            <overloads>Append to the <c>toString</c> the super class toString.</overloads>
            <summary>
            <para>Append to the <c>toString</c> buffer the super class toString.</para>
            
            <para><see langword="null"/> <paramref name="value"/> is ignored.</para>
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="value">a <c>super.ToString()</c></param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendToString(System.Text.StringBuilder,System.String)">
            <overloads>Append to toString another toString.</overloads>
            <summary>
            <para>Append to the buffer another toString.</para>
            
            <para><see langword="null"/> toString is ignored.</para>
            </summary>
            <param name="buffer"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="value">The additional <c>toString</c> to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendAsObjectToString(System.Text.StringBuilder,System.Object)">
            <overloads>Appends the objects short name along with its hash code</overloads>
            <summary>
            Appends the objects short name along with its hash code to the buffer
            </summary>
            <param name="buffer">the buffer to write to</param>
            <param name="target">Object whose name will be appended</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.Append(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32,System.Type)">
            <summary>
            Appends an object's string representation to the string buffer using the style of this object.
            
            The <paramref name="target"/> and <paramref name="targetType"/> parameters both allow <see langword="null"/> values.  
            If the target type is <see langword="null"/> and the target
            is not then the type will be inferred from the target.  If both are <see langword="null"/> then the null text will be appended.
            If the <paramref name="target"/> is <see langword="null"/> and not the type then <see langword="null"/> 
            will be returned allowing for a style to specify the type that is <see langword="null"/>.
            If <paramref name="target"/> and <paramref name="targetType"/> both have a value but the 
            type does not match the target then type will be changed to 
            the type of the target object.
            
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if the recursion level is less than zero or 
            if <c>buffer</c> is <see langword="null"/>.</exception>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field if there is one</param>
            <param name="target">The target object to append to the string</param>
            <param name="targetType">The type of the object. You can obtain this from the object.</param>
            <param name="detailLevel">		
            The number of levels to traverse each object.  That is for each object that is encountered in the object graph;
            how many levels up the inheritance chain to traverse.
            </param>
            <param name="maxRecursionLevel">The number of levels to traverse each object</param>
            <param name="reflectUpToClass">The object to stop at in the object graph</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendStart(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Object)">
            <summary>
            Appends to the <c>ToString</c> context the start of data indicator.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="target">The target object to append to the string</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnd(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Object)">
            <summary>
            Appends to the <c>ToString</c> context's buffer the end of data indicator.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="target">The target object to append to the string</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.RemoveLastFieldSeparator(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Remove the last field separator from the buffer.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.RemoveLastTabCharacter(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Remove the last tab separator from the buffer.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendSuper(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String)">
            <summary>
            <para>Append to the <c>toString</c> <paramref name="context"/>'s buffer the super class toString.</para>
            
            <para><see langword="null"/> <paramref name="value"/> is ignored.</para>
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="value">a <c>super.ToString()</c></param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendToString(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String)">
            <summary>
            <para>Append to the <paramref name="context"/>'s buffer another toString.</para>
            
            <para><see langword="null"/> <paramref name="value"/> is ignored.</para>
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="value">The additional <c>toString</c> to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendAsObjectToString(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Object)">
            <summary>
            Appends the objects short name along with its hash code to the <paramref name="context"/>'s buffer
            </summary>
            <param name="context">the buffer to write to</param>
            <param name="target">Object whose name will be appended</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendPrimitive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.ValueType,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends a primitive to the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="valueType">The object to append</param>
            <param name="detailLevel">The level of detail to display</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendString(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.String,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends a string to the <see cref="T:System.Text.StringBuilder"/>.  A string is treated like a primitive.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="value">The object string to append</param>
            <param name="detailLevel">The level of detail to display</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendPrimitiveRecursive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object)">
            <summary>
            Appends a primitive to the <see cref="T:System.Text.StringBuilder"/> to the recursive level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendPrimitiveDetail(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object)">
            <summary>
            Appends a primitive to the <see cref="T:System.Text.StringBuilder"/> to the detail level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendPrimitiveSummary(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object)">
            <summary>
            Appends a primitive to the <see cref="T:System.Text.StringBuilder"/> to the summary level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnumerable(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Collections.IEnumerable,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends an enumerable to the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an unexpected detail level is encountered.</exception>
            
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="detailLevel">The level of detail to display</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnumerableRecursive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Collections.IEnumerable)">
            <summary>
            Appends an enumerable to the <see cref="T:System.Text.StringBuilder"/> to the recursive level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnumerableDetail(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Collections.IEnumerable)">
            <summary>
            Appends an enumerable to the <see cref="T:System.Text.StringBuilder"/> to the detail level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendEnumerableSummary(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Collections.IEnumerable)">
            <summary>
            Appends an enumerable to the <see cref="T:System.Text.StringBuilder"/> to the summary level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendArray(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Array,Hca.Common.Builder.ToStringStyle.DetailLevel)">
            <summary>
            Appends an <see cref="T:System.Array"/> to the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an unexpected detail level is encountered.</exception>
            
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="detailLevel">The level of detail to display</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendArrayRecursive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Array)">
            <summary>
            Appends an <see cref="T:System.Array"/> to the <see cref="T:System.Text.StringBuilder"/> to the recursive level.
            For arrays that contain more than 100 items there lengths will only be displayed.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendArrayDetail(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Array)">
            <summary>
            Appends an <see cref="T:System.Array"/> to the <see cref="T:System.Text.StringBuilder"/> to the detail level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendArraySummary(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Array)">
            <summary>
            Appends an <see cref="T:System.Array"/> to the <see cref="T:System.Text.StringBuilder"/> to the summary level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendObject(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object,System.Type,Hca.Common.Builder.ToStringStyle.DetailLevel,System.Int32,System.Type)">
            <summary>
            Appends an Object to the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an unexpected detail level is encountered.</exception>
            
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="targetType">Type of the object to append</param>
            <param name="detailLevel">The level of detail to display</param>
            <param name="recursionLevel">How deep to go into the object</param>
            <param name="reflectUpToClass">The class to stop at</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendObjectSummary(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object,System.Type)">
            <summary>
            Appends an Object to the <see cref="T:System.Text.StringBuilder"/> to the detail summary.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="targetType">The type of the object</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendObjectDetail(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object,System.Type)">
            <summary>
            Appends an Object to the <see cref="T:System.Text.StringBuilder"/> to the detail level.
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="targetType">The type of the object</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendObjectRecursive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Object,System.Type,System.Int32,System.Type)">
            <summary>
            Appends an Object to the <see cref="T:System.Text.StringBuilder"/> using recursion.
            
            
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">Name of the field</param>
            <param name="target">The object to append</param>
            <param name="targetType">Type of object to append</param>
            <param name="maxRecursionLevel">How deep to go into the object</param>
            <param name="reflectUpToClass">The class to stop at</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendSummarySize(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String,System.Int32)">
            <summary>
            <para>Append to the <c>toString</c> a size summary.</para>
            
            <para>The size summary is used to summarize the contents of
            <c>Collections</c>, <c>Maps</c> and arrays.</para>
            
            <para>The output consists of a prefix, the passed in size
            and a suffix.</para>
            
            <para>The default format is <c>'&lt;size=n&gt;'</c>.</para>
            </summary>
            <param name="context"><see cref="T:System.Text.StringBuilder"/> to append to</param>
            <param name="fieldName">The name of the field</param>
            <param name="size">The size of the field</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendFieldEnd(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String)">
            <summary>
            Appends the field end character
            </summary>
            <param name="context">the buffer to write to</param>
            <param name="fieldName">The name of the field</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendNullText(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String)">
            <summary>
            Appends the null text character
            </summary>
            <param name="context">the buffer to write to</param>
            <param name="fieldName">The name of the field</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendFieldSeparator(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Appends the field separator string
            </summary>
            <param name="context">the buffer to write to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendFieldStart(Hca.Common.Builder.ToStringStyle.ToStringContext,System.String)">
            <summary>
            Appends the field start string
            </summary>
            <param name="context">the buffer to write to</param>
            <param name="fieldName">The name of the field</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendContentStart(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Appends the content start string
            </summary>
            <param name="context">the buffer to write to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendContentEnd(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Appends the content end string
            </summary>
            <param name="context">the buffer to write to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendNewLine(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Appends the new line string
            </summary>
            <param name="context">the buffer to write to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendLevelTabs(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Used to indent to the current recursion level
            </summary>
            <param name="context">the buffer to write to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AcceptField(System.Reflection.FieldInfo)">
            <summary>
            Returns whether or not to append the given <c>Field</c>.
            </summary>
            <param name="field">The field in question</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendClassName(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Object)">
            <summary>
            Append to the <c>toString</c> the class name.
            </summary>
            <param name="context">String to append to</param>
            <param name="target">Object to append to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.GetShortTypeName(System.Type)">
            <summary>
            Gets the short type name
            </summary>
            
            <exception cref="T:System.ArgumentNullException">Thrown if type is <see langword="null"/>.</exception>
            
            <param name="type">The type</param>
            <returns>name</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.GetLongTypeName(System.Type)">
            <summary>
            Gets the long type name
            </summary>
            
            <exception cref="T:System.ArgumentNullException">Thrown if type is <see langword="null"/>.</exception>
            
            <param name="type">The type</param>
            <returns>long name</returns>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendIdentityHashCode(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Object)">
            <summary>
            Append the object's hash code to the string.
            </summary>
            <remarks></remarks>
            <param name="context">String to append to</param>
            <param name="target">Object to get hash code from</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.AppendFieldsRecursive(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Type,System.Object,System.Int32,System.Type)">
            <summary>
            Used to traverse an object graph using recursion.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="target"/> is <see langword="null"/>.</exception>
            
            <param name="context">the buffer to write to</param>
            <param name="type">Type of the <paramref name="target"/></param>
            <param name="target">The object graph to traverse</param>
            <param name="maxRecursionLevel">To to which traverse</param>
            <param name="reflectUpToClass">The class to stop at</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.ProcessAppendFields(Hca.Common.Builder.ToStringStyle.ToStringContext,System.Reflection.MemberInfo[],System.Object,System.Type,System.Int32,System.Type)">
            <summary>
            Appends the fields of an object using recursion. All objects are fed back into the <see cref="M:Hca.Common.Builder.ToStringStyle.Append(System.Text.StringBuilder,System.String,System.Object,System.Type)"/> method.
            
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="target"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if there an security exception reflecting the object graph.</exception>
            
            <param name="context">String to append to</param>
            <param name="members">Members should be fields and properties.  All others will be ignored.</param>
            <param name="target">The object to append fields from</param>
            <param name="type">Type of object</param>
            <param name="maxRecursionLevel">how far down to go</param>
            <param name="reflectUpToClass">where to stop</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.GetObjectIdString(System.Object)">
            <summary>
            Gets a hash code for the object taking into account the instance id 
            of top.  If the target object derives from top then the top instance id will be
            returned; if not or it is <see langword="null"/> then the <see cref="T:System.Object"/> hash code is returned.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ArrayStart">
            <summary>
            <para>Sets the array start text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ArrayEnd">
            <summary>
            <para>Sets the array end text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ArraySeparator">
            <summary>
            <para>Sets the array separator text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para></summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ContentStart">
            <summary>
            <para>Sets the start content text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ContentEnd">
            <summary>
            <para>Sets the end content text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.FieldNameValueSeparator">
            <summary>
            <para>Sets the field value separator text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.FieldSeparator">
            <summary>
            <para>Sets the field separator text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.FieldSeparatorAtEnd">
            <summary>
            <para>Determines if a filed separator is placed at the end of a field.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.FieldSeparatorAtStart">
            <summary>
            <para>Determines if a filed separator is placed at the beginning of a field</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.NullText">
            <summary>
            <para>Sets the NullText text.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.DefaultDetailLevel">
            <summary>
            <para>Sets the default detail level</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.UseClassName">
            <summary>
            <para>Determines if class names will the displayed</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.UseShortClassName">
            <summary>
            <para>Keeps the assembly name from being added to a class name</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.UseIdentityHashCode">
            <summary>
            <para>Determines if hash codes will be displayed</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.UseFieldNames">
            <summary>
            Determines if filed names will be displayed
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ArrayContentDetail">
            <summary>
            Controls if array content is displayed
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.SizeStartText">
            <summary>
            <para>Sets the start text to output when a <c>Collection</c>,
            <c>Map</c> or array size is output.</para>
            <para>This is output before the size value.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.SizeEndText">
            <summary>
            <para>Sets the end text to output when a <c>Collection</c>,
            <c>Map</c> or array size is output.</para>
            <para>This is output after the size value.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.SummaryObjectStartText">
            <summary>
            <para>Sets the start text to output when an <c>Object</c> is
            output in summary mode.</para>
            <para>This is output before the size value.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.SummaryObjectEndText">
            <summary>
            <para>Sets the end text to output when an <c>Object</c> is
            output in summary mode.</para>
            <para>This is output after the size value.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.TabCharacter">
            <summary>
            <para>Sets the tab character to use for indenting.</para>
            <para><see langword="null"/> is accepted, but will be converted to an empty String.</para>
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.DetailLevel">
            <summary>
            Defines detail levels
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.DetailLevel.SummaryDetail">
            <summary>
            Only shows terse detail
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullDetail">
            <summary>
            Shows values in arrays but does not use reflection to traverse the object graph
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.DetailLevel.FullRecursiveDetail">
            <summary>
            Show complete detail by traversing the object graph with recursion.
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.DefaultToStringStyle">
            <summary>
            This is an inner class to ensure its immutability
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.DefaultToStringStyle.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.MultiLineToStringStyle">
            <summary>
            This is an inner class to ensure its immutability
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.TabbedMultiLineToStringStyle">
            <summary>
            This is an inner class to ensure its immutability
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.TabbedMultiLineToStringStyle.AppendFieldSeparator(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Append tabs when there is a field separator
            </summary>
            <param name="context">String to append to</param>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.TabbedMultiLineToStringStyle.AppendContentEnd(Hca.Common.Builder.ToStringStyle.ToStringContext)">
            <summary>
            Append tabs at content end
            </summary>
            <param name="context">String to append to</param>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.NoFieldNameToStringStyle">
            <summary>
            <see cref="T:Hca.Common.Builder.ToStringStyle"/> that does not print out the field names. This is an inner class to ensure its immutability
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.NoFieldNameToStringStyle.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.SimpleToStringStyle">
            <summary>
            <see cref="T:Hca.Common.Builder.ToStringStyle"/> that does not print out the class name, identity hash code, 
            content start or field name. This is an inner class to ensure its immutability
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.SimpleToStringStyle.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Hca.Common.Builder.ToStringStyle.ToStringContext">
            <summary>
            Tracks the status of a <see cref="T:Hca.Common.Builder.ToStringStyle"/> Append[...] call inside recursion.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.ToStringContext.buffer">
            <summary>
            Holds the <see cref="T:System.Text.StringBuilder"/> to which output is being appended.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.ToStringContext.visited">
            <summary>
            Holds the <see cref="T:Hca.Common.Utility.ObjectRegistry"/> tracking visited objects during traversal of the graph.
            </summary>
        </member>
        <member name="F:Hca.Common.Builder.ToStringStyle.ToStringContext.recursionLevel">
            <summary>
            Holds the current level of recursion.
            </summary>
        </member>
        <member name="M:Hca.Common.Builder.ToStringStyle.ToStringContext.#ctor(System.Text.StringBuilder)">
            <summary>
            Instantiates the <see cref="T:Hca.Common.Builder.ToStringStyle.ToStringContext"/> class.
            </summary>
            <param name="buffer">The <see cref="T:System.Text.StringBuilder"/> to which output is being appended.</param>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ToStringContext.Buffer">
            <summary>
            Gets the <see cref="T:System.Text.StringBuilder"/> to which output is being appended.
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ToStringContext.Visited">
            <summary>
            Gets the <see cref="T:Hca.Common.Utility.ObjectRegistry"/> tracking visited objects during traversal of the graph.
            </summary>
        </member>
        <member name="P:Hca.Common.Builder.ToStringStyle.ToStringContext.RecursionLevel">
            <summary>
            Gets or sets the current level of recursion.
            </summary>
        </member>
        <member name="T:Hca.Common.Collection.HashSet">
             <summary>
             Implements a <see cref="T:Hca.Common.ISet"/> based on a <see cref="T:System.Collections.Hashtable"/>.
             </summary>
             <remarks>
             <para>
             Performance of the <see cref="T:Hca.Common.Collection.HashSet"/> is efficient for most sized collections though its shows best performance in 
             comparison to other possible backing data structures for large sets. Iteration produces elements in no particular
             order. Use the <see cref="T:Hca.Common.Collection.SortedSet"/> if you need items ordered. Element order is also indeterminate for any of
             the various <see cref="T:Hca.Common.Collection.Set"/> mathematical operators.</para>
             <para>A <see cref="T:Hca.Common.Collection.HashSet"/> supports both heterogeneous and homogeneous collections. Since, sets are value based where the same
             value must not be allowed to be added, special hash and comparison is done to ensure that <b>ANY</b> object type
             added will only be added if its value is not the same. Hence, if you have object types that use special
             comparison or hashing and want to use that, you must specify this on construction. Note however, that if you
             take control, you are responsible for writing comprehensive hash code and comparison algorithms otherwise, you
             may have indeterminate results.</para>
             </remarks>
             <example>
             Example usage would be:
             <code>
            public class Rivers
            {
            	private static readonly HcaLogger log = HcaLogger.GetLogger(typeof(Rivers));	
            	[STAThread]
            	public static void Main(string[] args)
            	{
            		log.Info("Start Test");
            		log.Info("Scenario Three Example:");
            		ClubMember chuck = new ClubMember("Chuck Jones", new Date(1940, 3, 10), 1980);
            		ClubMember anne = new ClubMember("Anne Smith", new Date(1984, 6, 17), 2002);
            		ClubMember rick = new ClubMember("Jim Bishop", new Date(1985, 9, 30), 2004);
            		ClubMember kimberly = new ClubMember("Kimberly Baker", new Date(1975, 4, 20), 2000);
            		HashSet adultDemographic = new HashSet(new ClubMember[] {chuck, kimberly});
            		log.Info("Count Before add of duplicate is [{0}]", adultDemographic.Count);
            		adultDemographic.Add(chuck);
            		log.Info("Count After add of duplicate is [{0}]", adultDemographic.Count);
            		HashSet youthDemographic = new HashSet(new ClubMember[] {anne, rick});
            		HashSet tenPlusYearMembers = new HashSet(new ClubMember[]{chuck});
            		Set allMembers = adultDemographic | youthDemographic;
            		Print("All Members", allMembers);
            		Set lessThanTenYearMembers = allMembers - tenPlusYearMembers;
            		Print("Less than Ten Year Members", lessThanTenYearMembers);
            		Set adultMembersLessThanTenYears = adultDemographic &amp; lessThanTenYearMembers;
            		Print("Adult Members with less than ten years membership", adultMembersLessThanTenYears);
            		log.Info("End Test");
            	}
            	private static void Print(string title, Set elements)
            	{
            		log.Info(title);
            		foreach(object o in elements)
            		{
            			log.Info("\t {0}", o);
            		}
            		log.Info("");
            	}
            }
             
            private class ClubMember
            {
            	private string name;
            	private Date dateOfBirth;
            	private int memberSinceYear;
            	public ClubMember(string name, Date dob, int memberSince)
            	{
            		this.name = name;
            		this.dateOfBirth = dob;
            		this.memberSinceYear = memberSince;
            	}
            	public string Name
            	{
            		get { return name; }
            		set { name = SystemUtility.NullOrTrimString(value); }
            	}
            	public Date DateOfBirth
            	{
            		get { return dateOfBirth; }
            		set { dateOfBirth = value; }
            	}
            	public int MemberSinceYear
            	{
            		get { return memberSinceYear; }
            		set { memberSinceYear = value; }
            	}
            	public int YearsMember
            	{
            		get
            		{
            			Date now = new Date();
            			return now.Year - MemberSinceYear;
            		}
            	}
            	public override string ToString()
            	{
            		ToStringBuilder sb = new ToStringBuilder(this, ToStringStyle.TABBED_MULTI_LINE_STYLE);
            		sb.Append(Name, "Name");
            		sb.Append(DateOfBirth.ToString("yyyy-MM-dd"),  "DateOfBirth");
            		sb.Append(MemberSinceYear, "MemberSinceYear");
            		return sb.ToString();
            	}
            }
             </code>
             	Here is the output from running the example:
             <code><![CDATA[
            	2006-02-16 14:15:29,254 [3836] INFO  [Rivers] [(null)] <(null)> - Start Test
            	2006-02-16 14:15:29,301 [3836] INFO  [Rivers] [(null)] <(null)> - Scenario Three Example:
            	2006-02-16 14:15:29,473 [3836] INFO  [Rivers] [(null)] <(null)> - Count Before add of duplicate is [2]
            	2006-02-16 14:15:29,489 [3836] INFO  [Rivers] [(null)] <(null)> - Count After add of duplicate is [2]
            	2006-02-16 14:15:29,504 [3836] INFO  [Rivers] [(null)] <(null)> - All Members
            	2006-02-16 14:15:29,536 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@25[
            Name=Jim Bishop
            DateOfBirth=1985-09-30
            MemberSinceYear=2004]
            
            2006-02-16 14:15:29,536 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@22[
            Name=Kimberly Baker
            DateOfBirth=1975-04-20
            MemberSinceYear=2000]
            
            2006-02-16 14:15:29,536 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@24[
            Name=Anne Smith
            DateOfBirth=1984-06-17
            MemberSinceYear=2002]
            
            2006-02-16 14:15:29,536 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@21[
            Name=Chuck Jones
            DateOfBirth=1940-03-10
            MemberSinceYear=1980]
            
            2006-02-16 14:15:29,536 [3836] INFO  [Rivers] [(null)] <(null)> -
            2006-02-16 14:15:29,551 [3836] INFO  [Rivers] [(null)] <(null)> - Less than TenYear Members
            2006-02-16 14:15:29,583 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@25[
            Name=Jim Bishop
            DateOfBirth=1985-09-30
            MemberSinceYear=2004]
            
            2006-02-16 14:15:29,583 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@22[
            Name=Kimberly Baker
            DateOfBirth=1975-04-20
            MemberSinceYear=2000]
            
            2006-02-16 14:15:29,598 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@24[
            Name=Anne Smith
            DateOfBirth=1984-06-17
            MemberSinceYear=2002]
            
            2006-02-16 14:15:29,598 [3836] INFO  [Rivers] [(null)] <(null)> -
            2006-02-16 14:15:29,614 [3836] INFO  [Rivers] [(null)] <(null)> - Adult Members with less than ten years membership
            2006-02-16 14:15:29,614 [3836] INFO  [Rivers] [(null)] <(null)> -        Hca.SetDemo.Rivers+ClubMember@22[
            Name=Kimberly Baker
            DateOfBirth=1975-04-20
            MemberSinceYear=2000]
            
            2006-02-16 14:15:29,629 [3836] INFO  [Rivers] [(null)] <(null)> -
            2006-02-16 14:15:29,629 [3836] INFO  [Rivers] [(null)] <(null)> - End Test
            Press any key to continue
             ]]></code>
             </example>
        </member>
        <member name="T:Hca.Common.Collection.Set">
            <summary>
            A collection that contains no duplicate elements.  This class models the mathematical
            set abstraction, and is the base class for the other <see cref="T:Hca.Common.ISet"/> implementations in this library.
            </summary>
            <remarks>
            <para>The order of elements in a set is dependant on (a) the data-structure implementation, and (b) the 
            implementation of the various set methods, and thus is not specified here.</para>
            
            <para>None of the <see cref="T:Hca.Common.Collection.Set"/> implementations in this library are guaranteed to be 
            thread-safe in any way unless wrapped in a <see cref="T:Hca.Common.Collection.SynchronizedSet"/>.</para>
            
            <para>All but the <see cref="T:Hca.Common.Collection.SortedSet"/> (due to <see cref="T:System.Collections.IComparer"/> semantics) are heterogeneous sets. 
            Comparisons with heterogeneous sets can be compared as with any set.</para>
            
            <note>When a <see cref="T:Hca.Common.Collection.Set"/> is created via <c>Clone()</c>, a shallow copy occurs and hence the elements themselves 
            are <b>NOT</b> cloned. If this is not your expectation or need, use <see cref="M:Hca.Common.Utility.SystemUtility.DeepCopy(System.Object)"/>
            to also copy the elements.
            </note>
            
            <para>The following table summarizes the binary operations that are supported by the <see cref="T:Hca.Common.Collection.Set"/> class.</para>
            
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            		<term>Operator</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><c>Union()</c></term>
            		<term><c>|</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><c>InterSect()</c></term>
            		<term><c>&amp;</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><c>ExclusiveOr()</c></term>
            		<term><c>^</c></term>
            	</item>
            	<item>
            		<term>Minus</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><c>Minus()</c></term>
            		<term><c>-</c></term>
            	</item>
            </list>
            </remarks> 
        </member>
        <member name="T:Hca.Common.ISet">
            <summary>A collection that contains no duplicate elements. This interface models the mathematical set abstraction.</summary>
            <remarks>
            <para>The order of elements in a set is dependant on (a) the data-structure implementation, and (b) the 
            implementation of the various set methods, and thus is not specified here.</para>
            
            <para>All of the <see cref="T:Hca.Common.ISet"/> implementations in this library are derived from the <see cref="T:Hca.Common.Collection.Set"/> 
            abstract base class. No instances are guaranteed to be thread-safe in any way unless wrapped in a 
            <see cref="T:Hca.Common.Collection.SynchronizedSet"/>.</para>
            
            <para>The following table summarizes the binary set operations that are supported by the <see cref="T:Hca.Common.ISet"/> interface.</para>
            
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><see cref="M:Hca.Common.ISet.Union(Hca.Common.ISet)"/></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><see cref="M:Hca.Common.ISet.Intersect(Hca.Common.ISet)"/></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><see cref="M:Hca.Common.ISet.ExclusiveOr(Hca.Common.ISet)"/></term>
            	</item>
            	<item>
            		<term>Minus</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><see cref="M:Hca.Common.ISet.Minus(Hca.Common.ISet)"/></term>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:Hca.Common.ISet.Union(Hca.Common.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <see cref="M:System.ICloneable.Clone"/> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <see cref="T:Hca.Common.Collection.Set"/> containing the union of this <see cref="T:Hca.Common.Collection.Set"/> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Hca.Common.ISet.Intersect(Hca.Common.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <see cref="M:Hca.Common.ISet.Intersect(Hca.Common.ISet)"/> operation does not modify the input sets.  It returns
            a <see cref="M:System.ICloneable.Clone"/> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <paramref name="a"/>.</returns>
        </member>
        <member name="M:Hca.Common.ISet.Minus(Hca.Common.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <see cref="M:System.ICloneable.Clone"/>
            of this <see cref="T:Hca.Common.Collection.Set"/> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <paramref name="a"/> removed.</returns>
        </member>
        <member name="M:Hca.Common.ISet.ExclusiveOr(Hca.Common.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <see cref="M:System.ICloneable.Clone"/> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Hca.Common.ISet.Contains(System.Object)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><see langword="true"/> if this set contains the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.ISet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <see langword="true"/> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><see langword="true"/> if the set contains all the elements in the specified collection, <see langword="false"/> otherwise.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.ISet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><see langword="true"/> is the object was added, <see langword="false"/> if it was already present.</returns>
        </member>
        <member name="M:Hca.Common.ISet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><see langword="true"/> is the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.ISet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><see langword="true"/> if the set contained the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.ISet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><see langword="true"/> if the set was modified as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.ISet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><see langword="true"/> if this set changed as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.ISet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Hca.Common.ISet.CloneWritable">
            <summary>
            Return a writeable clone of this set.
            </summary>
            <remarks>This call is useful if you are dealing with an <see cref="T:Hca.Common.Collection.ImmutableSet"/> and need 
            the underlying basis set for an operation.</remarks>
            <returns>The clone of this set or its basis set if immutable.</returns>
        </member>
        <member name="M:Hca.Common.ISet.ToArray">
            <overloads>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array.
            </overloads>
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new <see cref="T:System.Object"/> array.
            </summary>
            <returns>An <see cref="T:System.Object"/> array containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
        </member>
        <member name="M:Hca.Common.ISet.ToArray(System.Type)">
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array of the specified type.
            </summary>
            <returns>An array of the specified type containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elementType"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidCastException">Thrown when an element of the <see cref="T:Hca.Common.ISet"/> cannot be cast to the specified type.</exception>
        </member>
        <member name="P:Hca.Common.ISet.IsEmpty">
            <summary>
            Returns <see langword="true"/> if the cardinality of the set is zero.
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.Set.op_ExclusiveOr(Hca.Common.Collection.Set,Hca.Common.Collection.Set)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<paramref name="a"/> if it is not <see langword="null"/>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null"/> if both sets are <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.ExclusiveOr(Hca.Common.ISet)"/> for full example.
            <code>
            ...
            ISet ab = a ^ b;
            ...
            </code>
            Yields the resultant set
            {"zero","one","four"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.op_Subtraction(Hca.Common.Collection.Set,Hca.Common.Collection.Set)">
            <summary>
            Performs a "minus" of set <paramref name="b"/> from set <paramref name="a"/>.  This returns a set of all
            the elements in set <paramref name="a"/>, removing the elements that are also in set <paramref name="b"/>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <paramref name="a"/> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>A - B</c> elements.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Minus(Hca.Common.ISet)"/> for full example.
            <code>
            ...
            ISet ab = a - b;
            ...
            </code>
            Yields the resultant set
            {"zero","four"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.op_BitwiseAnd(Hca.Common.Collection.Set,Hca.Common.Collection.Set)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <paramref name="a"/> and <paramref name="b"/>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<paramref name="a"/> if it is not <see langword="null"/>) containing the
            elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets.  <see langword="null"/> if both sets are <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet)"/> for full example.
            <code>
            ...
            ISet ab = a &amp; b;
            </code>
            Yields the resultant set
            {"two","three"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.op_BitwiseOr(Hca.Common.Collection.Set,Hca.Common.Collection.Set)">
            <summary>
            Performs a "union" of two sets, where all the elements in both are present.  That is, the element is included if 
            it is in either <paramref name="a"/> or <paramref name="b"/>. The return value is a <c>Clone()</c> 
            of one of the sets (<paramref name="a"/> if it is not <see langword="null"/>) with elements of the other set added in.  \
            Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.  <see langword="null"/> if both sets are <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Union(Hca.Common.ISet)"/> for full example.
            <code>
            ISet ab = a | b;
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Union(Hca.Common.ISet)">
            <overloads>
            Performs a "union" of two sets, where all the elements in both sets are present.  That is, 
            the element is included if it is in either set. Neither set is modified 
            during the operation.  The return value is a <c>Clone()</c> of a with the extra elements added in. The 
            elements themselves are <b>NOT</b> cloned and hence care should be taken if the expectation was for new elements
            to be created. 
            </overloads>
            <summary>
            Performs a "union" of the current set and passed set, returning a set of all the elements present in both sets.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <see cref="T:Hca.Common.Collection.Set"/> containing the union of this <see cref="T:Hca.Common.Collection.Set"/> 
            with the specified collection. Neither of the input objects is modified by the union.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed</exception>
            <example>
            <code>
            ...
            initValuesStringA = new ArrayList();
            initValuesStringA.Add( "zero" );
            initValuesStringA.Add( "one" );
            initValuesStringA.Add( "two" );
            initValuesStringA.Add( "three" );
            initValuesStringB = new ArrayList();
            initValuesStringB.Add( "two" );
            initValuesStringB.Add( "three" );
            initValuesStringB.Add( "four" );
            HashSet a = new HashSet(initValuesStringA);
            HashSet b = new HashSet(initValuesStringB);
            ISet ab = a.Union(b);
            </code>
            Yields the resultant set
            {"zero","one","two","three","four"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Union(Hca.Common.ISet,Hca.Common.ISet)">
            <summary>
            Performs a "union" of the two sets, returning a set of all the elements present in both sets. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Union(Hca.Common.ISet)"/>
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet)">
            <overloads>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <see cref="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet)"/> operation does not modify the input sets.  It returns
            a <c>Clone()</c> set with the appropriate elements removed.
            </overloads>
            <summary>
            Performs an "intersection" of this set against another set passed as an argument, 
            where only the elements that are present in both sets remain.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <paramref name="a"/>. Empty set if the intersection has no common elements</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed.</exception>
            <example>
            <code>
            ...
            initValuesStringA = new ArrayList();
            initValuesStringA.Add( "zero" );
            initValuesStringA.Add( "one" );
            initValuesStringA.Add( "two" );
            initValuesStringA.Add( "three" );
            initValuesStringB = new ArrayList();
            initValuesStringB.Add( "two" );
            initValuesStringB.Add( "three" );
            initValuesStringB.Add( "four" );
            HashSet a = new HashSet(initValuesStringA);
            HashSet b = new HashSet(initValuesStringB);
            ISet ab = a.Intersect(b);
            </code>
            Yields the resultant set
            {"two","three"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet,Hca.Common.ISet)">
            <summary>
            Performs an "intersection" of two sets passed as arguments, 
            where only the elements that are present in both sets <paramref name="a"/> and <paramref name="b"/> remain.
            The result object is a <c>Clone()</c> of (<paramref name="a"/> if it is 
            not <see langword="null"/>) containing the elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets, Empty Set if no shared elements.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet)"/> for full example.
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Minus(Hca.Common.ISet)">
            <overloads>
            Performs a "minus" of two sets.  This returns a set of all
            the elements in the first set, removing the elements that are also in the second set.
            </overloads>
            <summary>
            Performs a "minus" of set <paramref name="a"/> from this set.  This returns a set of all
            the elements in this set, removing the elements that are also in set <paramref name="a"/>.
            </summary>
            <remarks>
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <see cref="T:Hca.Common.Collection.Set"/> containing the elements from the operation.
            </remarks>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <paramref name="a"/> removed.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed</exception>
            <example>
            <code>
            ...
            initValuesStringA = new ArrayList();
            initValuesStringA.Add( "zero" );
            initValuesStringA.Add( "one" );
            initValuesStringA.Add( "two" );
            initValuesStringA.Add( "three" );
            initValuesStringB = new ArrayList();
            initValuesStringB.Add( "two" );
            initValuesStringB.Add( "three" );
            initValuesStringB.Add( "four" );
            HashSet a = new HashSet(initValuesStringA);
            HashSet b = new HashSet(initValuesStringB);
            ISet ab = a.Minus(b);
            </code>
            Yields the resultant set
            {"zero","four"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Minus(Hca.Common.ISet,Hca.Common.ISet)">
            <summary>
            Performs a "minus" of set <paramref name="b"/> from set <paramref name="a"/>.  This returns a set of all
            the elements in set <paramref name="a"/>, removing the elements that are also in set <paramref name="b"/>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <paramref name="a"/> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>a - b</c> elements.  <see langword="null"/> if <paramref name="a"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.Minus(Hca.Common.ISet)"/> for full example.
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.ExclusiveOr(Hca.Common.ISet)">
            <overloads>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </overloads>
            <summary>
            Returns a new cloned "exclusive-or" set (elements that are in one of the sets but not both)
            of this set against another set passed as an argument.
            </summary>
            <remarks>If all elements are in common, a zero <see cref="P:Hca.Common.Collection.Set.Count"/> set is returned.</remarks>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed</exception>
            <example>
            <code>
            ...
            initValuesStringA = new ArrayList();
            initValuesStringA.Add( "zero" );
            initValuesStringA.Add( "one" );
            initValuesStringA.Add( "two" );
            initValuesStringA.Add( "three" );
            initValuesStringB = new ArrayList();
            initValuesStringB.Add( "two" );
            initValuesStringB.Add( "three" );
            initValuesStringB.Add( "four" );
            HashSet a = new HashSet(initValuesStringA);
            HashSet b = new HashSet(initValuesStringB);
            ISet ab = a.ExclusiveOr(b);
            </code>
            Yields the resultant set
            {"zero","one","four"}
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.ExclusiveOr(Hca.Common.ISet,Hca.Common.ISet)">
            <summary>
            Returns a new cloned "exclusive-or" set (elements that are in one of the sets but not both)
            of two sets passed as arguments.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null"/> if both sets are <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed for either argument</exception>
            <example>
            <see cref="M:Hca.Common.Collection.Set.ExclusiveOr(Hca.Common.ISet)"/> for full example.
            </example>
        </member>
        <member name="M:Hca.Common.Collection.Set.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><see langword="true"/> is the object was added, <see langword="false"/> if it was already present.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><see langword="true"/> is the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.Set.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.Set.Contains(System.Object)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><see langword="true"/> if this set contains the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <see langword="true"/> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><see langword="true"/> if the set contains all the elements in the specified collection, 
            <see langword="false"/> otherwise.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.Set.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><see langword="true"/> if the set contained the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><see langword="true"/> if the set was modified as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.Set.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><see langword="true"/> if this set changed as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.Set.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <see cref="T:Hca.Common.Collection.Set"/> to an array.  The type of array needs
            to be compatible with the objects in the <see cref="T:Hca.Common.Collection.Set"/>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Hca.Common.Collection.Set.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <see cref="T:Hca.Common.Collection.Set"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> over the elements in the <see cref="T:Hca.Common.Collection.Set"/>.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.ToArray">
            <overloads>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array.
            </overloads>
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new <see cref="T:System.Object"/> array.
            </summary>
            <returns>An <see cref="T:System.Object"/> array containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.ToArray(System.Type)">
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array of the specified type.
            </summary>
            <returns>An array of the specified type containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elementType"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidCastException">Thrown when an element of the <see cref="T:Hca.Common.ISet"/> cannot be cast to the specified type.</exception>
        </member>
        <member name="M:Hca.Common.Collection.Set.Clone">
            <summary>
            Returns a clone of the <see cref="T:Hca.Common.Collection.Set"/> instance.  This will work for derived <see cref="T:Hca.Common.Collection.Set"/>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.CloneWritable">
            <summary>
            Returns a clone of the <see cref="T:Hca.Common.Collection.Set"/> instance which is writable.
            </summary>
            <remarks>This clone method works the same as the regular <see cref="M:Hca.Common.Collection.Set.Clone"/> for all cases but <see cref="T:Hca.Common.Collection.ImmutableSet"/>.
            In this case, the basis set (the set that is wrapped) is cloned and returned. This is useful in cases where 
            operations return a new set (e.g. <see cref="M:Hca.Common.Collection.Set.Union(Hca.Common.ISet)"/>, <see cref="M:Hca.Common.Collection.Set.Intersect(Hca.Common.ISet)"/>, <see cref="M:Hca.Common.Collection.Set.ExclusiveOr(Hca.Common.ISet)"/>, or 
            <see cref="M:Hca.Common.Collection.Set.Minus(Hca.Common.ISet)"/>) but one or both of the arguments are immutable.</remarks>
            <returns>A clone of this set or the basis set if <see cref="T:Hca.Common.Collection.ImmutableSet"/> or <see cref="T:Hca.Common.Collection.SynchronizedSet"/></returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.Equals(System.Object)">
            <summary>
            Override equals to indicate that two sets are equal if they are of the same type and
            have the same member values.
            </summary>
            <param name="obj">A <see cref="T:Hca.Common.Collection.Set"/> to compare</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Collection.Set.GetHashCode">
            <summary>
            We just use the version in <see cref="T:Hca.Common.BaseType.ObjectBase"/> since ^ of bit patterns is commutative.
            </summary>
            <returns>A hashcode value for this object</returns>
        </member>
        <member name="P:Hca.Common.Collection.Set.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.Set.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.Set.IsSynchronized">
            <summary>
            Returns <see langword="true"/> if the <see cref="T:Hca.Common.Collection.Set"/> is synchronized across threads.  Note that
            enumeration is inherently not thread-safe.  Use the <see cref="P:Hca.Common.Collection.Set.SyncRoot"/> to lock the
            object during enumeration.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.Set.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <see cref="T:System.Collections.IDictionary"/>,
            or anything that has a <see cref="P:Hca.Common.Collection.Set.SyncRoot"/>, return that object instead of "<c>this</c>".
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.#ctor">
            <overloads>Initializes a new instance of a <see cref="T:Hca.Common.Collection.HashSet"/>.</overloads>
            <summary>
            Default Ctor.
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new hash-based set and initializes it based on a collection of elements.
            </summary>
            <remarks>Uses the internal hash code provider and comparer the ensures value-based semantics for
            items in the set.</remarks>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates a new hash-based set with the given hash code provider and comparison provider.
            </summary>
            <remarks>If <see langword="null"/> is passed for either the provider or comparer, the internal default versions are used.
            It is STRONGLY advised to provide these in pairs since both algorithms are dependent on each other.</remarks>
            <param name="hashProvider">The hashcode provider for items added to the set.</param>
            <param name="comparisonProvider">The comparison provider for items added to the set.</param>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.#ctor(System.Collections.ICollection,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates a new hash-based set with the given initial values, hash code provider, and comparer.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="hashProvider">The hashcode provider for items added to the set.</param>
            <param name="comparisonProvider">The comparison provider for items added to the set.</param>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.Contains(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Contains(System.Object)"/>
            </summary>
            <remarks>
            An item is considered to be present if its value is present. Hence, if two different references of the same
            class have the same value and one of those instances is stored in a set, asking for the second reference
            will return <see langword="true"/>. 
            <note>
            <see langword="null"/> is a valid value and hence looking for <see langword="null"/> 
            is not the same as the <see cref="M:Hca.Common.Collection.HashSet.ContainsAll(System.Collections.ICollection)"/> call being 
            invoked with <see langword="null"/> collection.
            </note>
            </remarks>
            <param name="item">The item to check for membership in the set</param>
            <returns><see langword="true"/> if the item's value is contained in the set.</returns>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.ContainsAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>An Empty collection is treated as looking for the "empty set" and will always return <see langword="true"/>.</remarks>
            <param name="c">The collection to check</param>
            <returns><see langword="true"/> if all items are present.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If passed collection is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.Add(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Add(System.Object)"/>
            </summary>
            <param name="item">The item to add</param>
            <returns><see langword="true"/> if added, else already in collection.</returns>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.AddAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.AddAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>If the collection passed zero count no action is taken on the current set.</remarks>
            <param name="c">The collection to add from</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed.</exception>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.Remove(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Remove(System.Object)"/>
            </summary>
            <param name="item">The item to remove</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.RemoveAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>If the passed collection is empty no action is taken on the current set.</remarks>
            <param name="c">The collection of items to remove from current set.</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed.</exception>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.RetainAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.RetainAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>if the passed collection is empty, all members are removed.</remarks>
            <param name="c">The collection whose members will be retained.</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If <see langword="null"/> is passed.</exception>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.Clear">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Clear"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy the elements of this set to an existing array starting at a specified position.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The zero based offset where copying begins in the array</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If array passed is <see langword="null"/> or multidimensional, 
            or if array is to small to hold items</exception>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.GetEnumerator">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.GetEnumerator"/>
            </summary>
            <remarks>
            <para>The values of the enumeration are the objects that were placed into the set.
            The enumeration represents a snapshot of the contained objects at the point that the 
            enumeration is created. Hence, the enumeration returned is safe from modifications
            to the set made after the enumeration is returned.</para>
            </remarks>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> over the elements in the <see cref="T:Hca.Common.Collection.Set"/>.</returns>
        </member>
        <member name="P:Hca.Common.Collection.HashSet.LookupTable">
            <summary>
            Get the lookup table.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.HashSet.IsEmpty">
            <summary>
            Returns <see langword="true"/> if the set has no members.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.HashSet.Count">
            <summary>
            Returns the number of members in set(the cardinality)
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.HashSet.SyncRoot">
            <summary>
            Returns on object to lock on for this set.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.HashSet.IsSynchronized">
            <summary>
            Returns whether this set is synchronized.
            </summary>
        </member>
        <member name="T:Hca.Common.Collection.HashSet.SetCompareWrapper">
            <summary>
            This class provides a specialized comparator for handling the semantics we desire for placing items in a 
            set. 
            </summary>
            <remarks><p>Essentially, all we really want is for the equality check to use our value based comparator. However,
            since our only hook is via the comparer, we must implement the greater and less than checks. For our purposes,
            we really don't care about order since this is a set. Additionally since we want to support heterogenous 
            collections for a set, we don't want to get an exception due to wrong types. Hence, we just always return one
            to optimize usage.</p>
            <note>This comparer does not abide by the contract of <see cref="T:System.Collections.IComparer"/>.</note>
            </remarks>
        </member>
        <member name="M:Hca.Common.Collection.HashSet.SetCompareWrapper.Compare(System.Object,System.Object)">
            <summary>
            <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)"/>
            </summary>
            <param name="x">object instance one to compare</param>
            <param name="y">object instance two to compare</param>
            <returns>-1 if <paramref name="x"/> &lt; <paramref name="y"/>, 0 if <paramref name="x"/> == <paramref name="y"/>, 
            and 1 if <paramref name="x"/> &gt; <paramref name="y"/></returns>
        </member>
        <member name="T:Hca.Common.Collection.ImmutableSet">
            <summary>
            <p>Implements an immutable (read-only) <see cref="T:Hca.Common.Collection.Set"/> wrapper.</p>
            </summary>
            <remarks>
            <p>This wrapper provides a means to ensure that a given set can not be changed when accessed
            through this wrapper. As such, this class can only ensure that the underlying set will remain
            constant given no client gets access to that <c>basisSet</c>.</p>
            <p>Operations (Union, Intersection, Minus, Xor) will return <see cref="T:Hca.Common.Collection.Set"/>'s that are of the type of the
            wrapped set and are mutable. Hence, if you desire the resultant set of these operations to 
            be immutable, you must wrap it in a new <see cref="T:Hca.Common.Collection.ImmutableSet"/></p>
            </remarks>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.#ctor(Hca.Common.ISet)">
            <summary>
            Constructs an immutable (read-only) <see cref="T:Hca.Common.Collection.Set"/> wrapper.
            </summary>
            <param name="basisSet">The <see cref="T:Hca.Common.Collection.Set"/> that is wrapped.</param>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Add(System.Object)">
            <summary>
            <see cref="M:Hca.Common.ISet.Add(System.Object)"/>
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><see langword="true"/> is the object was added, <see langword="false"/> if it was already present.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.AddAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.ISet.AddAll(System.Collections.ICollection)"/>
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><see langword="true"/> is the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Clear">
            <summary>
            <see cref="M:Hca.Common.ISet.Clear"/>
            </summary>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Contains(System.Object)">
            <summary>
            <see cref="M:Hca.Common.ISet.Contains(System.Object)"/>
            </summary>
            <param name="o">The element to look for.</param>
            <returns><see langword="true"/> if this set contains the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.ISet.ContainsAll(System.Collections.ICollection)"/>
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><see langword="true"/> if the set contains all the elements in the specified collection, 
            <see langword="false"/> otherwise.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Remove(System.Object)">
            <summary>
            <see cref="M:Hca.Common.ISet.Remove(System.Object)"/>
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><see langword="true"/> if the set contained the specified element, <see langword="false"/> otherwise.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.ISet.RemoveAll(System.Collections.ICollection)"/>
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><see langword="true"/> if the set was modified as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.RetainAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.ImmutableSet.RetainAll(System.Collections.ICollection)"/>
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><see langword="true"/> if this set changed as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaNotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.ToArray">
            <overloads>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array.
            </overloads>
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new <see cref="T:System.Object"/> array.
            </summary>
            <returns>An <see cref="T:System.Object"/> array containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.ToArray(System.Type)">
            <summary>
            Copies the elements of the <see cref="T:Hca.Common.ISet"/> to a new array of the specified type.
            </summary>
            <returns>An array of the specified type containing copies of the elements of the <see cref="T:Hca.Common.ISet"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elementType"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidCastException">Thrown when an element of the <see cref="T:Hca.Common.ISet"/> cannot be cast to the specified type.</exception>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> over the elements in the <see cref="T:Hca.Common.Collection.Set"/>.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Clone">
            <summary>
            Returns a clone of the <see cref="T:Hca.Common.Collection.ImmutableSet"/> instance.  
            </summary>
            <remarks>This method creates a new <see cref="T:Hca.Common.Collection.ImmutableSet"/> wrapper over the same collection.</remarks>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.CloneWritable">
            <summary>
            Returns a clone of the basis set for which this immutable set wraps.
            </summary>
            <remarks>This call is useful if you are dealing with an <see cref="T:Hca.Common.Collection.ImmutableSet"/> and need 
            the underlying basis set for an operation.</remarks>
            <returns>The clone of this set or its basis set if immutable.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Union(Hca.Common.ISet)">
            <summary>
            <see cref="M:Hca.Common.ISet.Union(Hca.Common.ISet)"/>
            </summary>
            <remarks>The set returned is of the wrapped type and is not Immutable</remarks>
            <param name="a">A collection of elements.</param>
            <returns>A new <see cref="T:Hca.Common.Collection.Set"/> containing the union of 
            this <see cref="T:Hca.Common.Collection.Set"/> with the specified collection.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Intersect(Hca.Common.ISet)">
            <summary>
            <see cref="M:Hca.Common.ISet.Intersect(Hca.Common.ISet)"/>
            </summary>
            <remarks>The set returned is of the wrapped type and is not Immutable</remarks>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <paramref name="a"/>.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.Minus(Hca.Common.ISet)">
            <summary>
            <see cref="M:Hca.Common.ISet.Intersect(Hca.Common.ISet)"/>
            </summary>
            <remarks>The set returned is of the wrapped type and is not Immutable</remarks>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <paramref name="a"/> removed.</returns>
        </member>
        <member name="M:Hca.Common.Collection.ImmutableSet.ExclusiveOr(Hca.Common.ISet)">
            <summary>
            <see cref="M:Hca.Common.ISet.ExclusiveOr(Hca.Common.ISet)"/>
            </summary>
            <remarks>The set returned is of the wrapped type and is not Immutable</remarks>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="P:Hca.Common.Collection.ImmutableSet.BasisSet">
            <summary>
            The wrapped set
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.ImmutableSet.IsEmpty">
            <summary>
            <see cref="P:Hca.Common.ISet.IsEmpty"/>
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.ImmutableSet.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.ImmutableSet.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.ImmutableSet.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="T:Hca.Common.Collection.NamespaceDoc">
            <summary>
            	<p>
            	The System.Collections namespace in the .NET Framework provides a number of collection 
            	types that are extremely useful for manipulating data in memory. However, there is one 
            	type of collection that is conspicuously missing from <see cref="N:System.Collections"/>: the 
            	<c>Set</c>.
            	</p>
            	<p>
            	A <c>Set</c> is a collection that contains no duplicate elements, and where the order of
            	the elements may be arbitrary. It is modeled after the mathematical concept of a "set." 
            	</p>
            	<p>
            	With sets, adding elements, removing elements, and checking for the existence of an element is fast and simple. 
            	You can mix and match the elements in different sets using the supported mathematical set operators: union, 
            	intersection, exclusive-or, and minus. 
            	</p>
            	<p>
            	<c>Sets</c> come in handy when an <c>Array</c> or a <c>List</c> won't quite fit the bill. Arrays in .NET have a 
            	fixed length, making it tedious to add and remove elements. Lists allow you add new objects easily, but you can 
            	have numerous duplicate elements, which is undesirable for some types of problems. Searching Arrays or Lists for 
            	elements is just plain slow for large data sets, requiring a linear search. You could keep the array sorted and 
            	use a binary search, but that is often more trouble than it is worth (especially since this library, 
            	and the .NET Framework, provide better ways that are already written for you).
            	</p>
            </summary>
            <remarks>
            	<h2>General</h2>
            	<p>
            	This namespace provides two general implementations of a set: <see cref="T:Hca.Common.Collection.HashSet"/> 
            	and <see cref="T:Hca.Common.Collection.SortedSet"/>. A <see cref="T:Hca.Common.Collection.HashSet"/> uses a 
            	backing hashtable to manage items. Items are not ordered in a <see cref="T:Hca.Common.Collection.HashSet"/>. 
            	A <see cref="T:Hca.Common.Collection.HashSet"/> can hold both homogeneous 
            	and heterogeneous items. In contrast, a <see cref="T:Hca.Common.Collection.SortedSet"/> is ordered but requires that
            	all items to be of the same type (homogeneous) and implement <see cref="T:System.IComparable"/>. 
            	A <see cref="T:Hca.Common.Collection.SortedSet"/> is slower than 
            	the <see cref="T:Hca.Common.Collection.HashSet"/> primarily due to the need to sort the items for additions, and update indexing when
            	an item is removed. However, <see cref="M:Hca.Common.Collection.SortedSet.Contains(System.Object)">SortedSet.Contains</see> 
            	checks are as fast as <see cref="M:Hca.Common.Collection.HashSet.Contains(System.Object)">HashSet.Contains</see>.
            	</p>
            	<p>
            	In addition to the two set types, two special purpose sets are provided: 
            	<see cref="T:Hca.Common.Collection.ImmutableSet"/> and <see cref="T:Hca.Common.Collection.SynchronizedSet"/>. 
            	The <see cref="T:Hca.Common.Collection.ImmutableSet"/> is a wrapper that prevents modification of a set through its 
            	interface. This may be useful if you desire to return a set where you can ensure that the client can not modify 
            	that set.
            	The <see cref="T:Hca.Common.Collection.SynchronizedSet"/> provides thread-safe operation of a set.
            	</p>
            	<h2>Equality and Comparison</h2>
            	<p>
            	An element in a set is deemed the same if a current element in the set "equals"	the passed element. In terms of 
            	set theory, "equality" pertains to value-based equality. For example, 1 and 1 are equal regardless of whether held 
            	in a primitive or stored in different object instances. Since .Net only does value based semantics by default for 
            	value-types, care must be taken when using an object reference. Developers must consider two different scenarios of 
            	use when dealing with classes that use reference semantic equality: 1) Storage of the same value but considered 
            	different due to different object references and 2) Changes to a stored object where the value changes.
            	</p>
            	<p>
            	In the first case, per set semantics, we would expect a Set to find a current	object whose value equals the value 
            	of the object to add. Since this would not happen	normally, developers must either provide an alternative object 
            	when using hash-based	implementations of a Set or ensure that the hash code and equality return the same value
            	regardless of reference. As mentioned previously, the easiest path is to 
            	ensure your class inherits from <see cref="T:Hca.Common.BaseType.ObjectBase"/> 
            	or at least uses the <see cref="T:Hca.Common.Utility.ValueComparator"/> and <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> 
            	provided to implement <see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)"/> and <see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode"/>. 
            	</p>
            	<p>
            	In the second case, it is advised that you do not use the object as the key to any set operation. Further, if the goal 
            	is to store a persistent (i.e., an object with and ObjectId) object in a Set, use the ObjectId as a key such that you 
            	can replace	the existing value with the new if changed and using a hash-based implementation.
            	</p>
            	<p>
            	If you derive the object stored in a Set from <see cref="T:Hca.Common.BaseType.ObjectBase"/>, you many work with sets without concern of 
            	equality when adding values. However, as just discussed changes to those objects still must be considered.
            	</p>
            	<p>
            	Comparison is only a concern when using the <see cref="T:Hca.Common.Collection.SortedSet"/>. However, when used, developers must implement
            	their Object's <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation such that all values are considered in the type for equality when
            	used with the default Comparer built into the <see cref="T:Hca.Common.Collection.SortedSet"/>. The reason for this is that equality within a
            	set is based on the entire value of the item. If a comparer chooses to use only one part of the value, then the
            	equality check in the <see cref="M:System.IComparable.CompareTo(System.Object)"/> will not be the same as the comparison for equality done by the set. 
            	<em>Hence, if you need to define <see cref="M:System.IComparable.CompareTo(System.Object)"/> that only considers a subset of value in an object, also define
            	a comparer for the <see cref="T:Hca.Common.Collection.SortedSet"/> that is set on construction that also uses those subset of values to
            	determine equality.</em>
            	</p>
            	<note>
            	The constructors on <see cref="T:Hca.Common.Collection.HashSet"/> that take a 
            	<see cref="T:System.Collections.IHashCodeProvider"/> and <see cref="T:System.Collections.IComparer"/> should not normally be used except in
            	very special cases. When used, care must be taken that no duplicate values are allowed since this would break
            	the general contract and indeterminate results will occur from all operations (i.e., if you take control, 
            	correctness is up to <em>you</em>. 
            	</note>
            	<h2>Iteration</h2>
            	<p>
            		Iteration over a Set will always return the values and not some intermediate form from the underlying implementation
            		such as DictionaryEntry. This allows sets to be worked on generically from the <see cref="T:Hca.Common.ISet"/> interface. It also has a
            		side benefit that the enumeration will remain constant for the duration of iteration even when the base collection
            		the enumeration was created from changes.
            	</p>
            	<p>
            		You will see some interesting side effects with different <c>Set</c> implementations in this library, depending 
            		on the underlying search algorithm. For example, if you choose a sort-based <c>Set</c>, the elements will come out 
            		in sort order when you iterate using <c>foreach</c>. If you use a hash-based <c>Set</c>, the elements will come out 
            		in no particular order, but checking for inclusion will be fastest when dealing with large data sets. 
            	</p>
            </remarks>
            <example>		
            	<p>
            	<h2>Examples:</h2>
            		The following sample program demonstrates some of the features of sets:
            		<code>
            using System;
            using Hca.Common.Logger;
            using Hca.Common.Collection;
            namespace Hca.SetDemo
            {    
            	class Rivers
            	{
            		private static readonly HcaLogger log = HcaLogger.GetLogger(typeof(Rivers));	
            		[STAThread]
            		static void Main(string[] args)
            		{
            			//Use Arrays (which are ICollection objects) to quickly initialize.
            			Set arizona   
            				= new SortedSet(new string[] {"Colorado River"});
            			Set california
            				= new SortedSet(new string[] {"Colorado River", "Sacramento River"});
            			Set colorado
            				= new SortedSet(new string[] {"Arkansas River", "Colorado River", "Green River", "Rio Grande"});
            			Set kansas
            				= new SortedSet(new string[] {"Arkansas River", "Missouri River"});
            			Set nevada
            				= new SortedSet(new string[] {"Colorado River"});
            			Set newMexico
            				= new SortedSet(new string[] {"Rio Grande"});
            			Set utah
            				= new SortedSet(new string[] {"Colorado River", "Green River", "San Juan River"});
            			//Rivers by region.
            			Set southWest = colorado | newMexico | arizona | utah;
            			Set midWest = kansas;
            			Set west = california | nevada;
            			//All rivers (at least for the demo).
            			Set all = southWest | midWest | west;
            			Print("All rivers:", all);
            			Print("Rivers in the southwest:", southWest);
            			Print("Rivers in the west:", west);
            			Print("Rivers in the midwest:", midWest);
            
            			//Use the '-' operator to subtract the rivers in Colorado from 
            			//the set of all rivers.
            			Print("Of all rivers, these don't pass through Colorado:", all - colorado);
            
            			//Use the '&amp;' operator to find rivers that are in Colorado AND in Utah.
            			//A river must be present in both states, not just one.
            			Print("Rivers common to both Colorado and Utah:", colorado &amp; utah);
            
            			//use the '^' operator to find rivers that are in Colorado OR Utah,
            			//but not in both.
            			Print("Rivers in Colorado and Utah that are not shared by both states:",
            				colorado ^ utah);
            
            			//Use the '&amp;' operator to discover which rivers are present in Arizona, 
            			// California,Colorado, Nevada, and Utah.  The river must be present in 
            			// all states to be counted.
            			Print("Rivers common to Arizona, California, Colorado, Nevada, and Utah:", 
            				arizona &amp; california &amp; colorado &amp; nevada &amp; utah);
            			//Just to prove to you that operators always return like types, let's do a
            			//complex Set operation and look at the type of the result:
            			log.Info("The type of this complex operation is: {0}",
            				((southWest ^ colorado &amp; california) | kansas).GetType().FullName);
            		}
            		private static void Print(string title, Set elements)
            		{
            			log.Info(title);
            			foreach(object o in elements)
            			{
            				log.Info("\t {0}", o);
            			}
            			log.Info("");
            		}
            	}
            	</code>
            	</p>
            	<p>
            		Although there are other kinds of sets available in the library, the example uses 
            		<see cref="T:Hca.Common.Collection.SortedSet"/> throughout. This is nice for the example, since everything will 
            		print neatly in alphabetical order. But you may be wondering what kind of <c>Set</c>
            		is returned when you "union," "intersect," "exclusive-or," or "minus" two <c>Set</c>
            		instances. The library always returns a <c>Set</c> that is the same type as 
            		the <c>Set</c> on the left, unless the left operand is null, in which case it 
            		returns the type of the <c>Set</c> on the right.
            	</p>
            	<p>
            		Here is the output from running the example:
            		<code><![CDATA[
            2006-01-19 12:45:01,696 [4240] INFO  [Rivers] [(null)] <(null)> - All rivers:
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Arkansas River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Colorado River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Green River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Missouri River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Rio Grande
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Sacramento River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        San Juan River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers in the southwest:
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Arkansas River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Colorado River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Green River
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        Rio Grande
            2006-01-19 12:45:01,727 [4240] INFO  [Rivers] [(null)] <(null)> -        San Juan River
            2006-01-19 12:45:01,743 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,743 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers in the west:
            2006-01-19 12:45:01,743 [4240] INFO  [Rivers] [(null)] <(null)> -        Colorado River
            2006-01-19 12:45:01,743 [4240] INFO  [Rivers] [(null)] <(null)> -        Sacramento River
            2006-01-19 12:45:01,759 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,759 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers in the midwest:
            2006-01-19 12:45:01,759 [4240] INFO  [Rivers] [(null)] <(null)> -        Arkansas River
            2006-01-19 12:45:01,759 [4240] INFO  [Rivers] [(null)] <(null)> -        Missouri River
            2006-01-19 12:45:01,759 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,774 [4240] INFO  [Rivers] [(null)] <(null)> - Of all rivers, these don't pass through Colorado:
            2006-01-19 12:45:01,774 [4240] INFO  [Rivers] [(null)] <(null)> -        Missouri River
            2006-01-19 12:45:01,774 [4240] INFO  [Rivers] [(null)] <(null)> -        Sacramento River
            2006-01-19 12:45:01,790 [4240] INFO  [Rivers] [(null)] <(null)> -        San Juan River
            2006-01-19 12:45:01,790 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,806 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers common to both Colorado and Utah:
            2006-01-19 12:45:01,806 [4240] INFO  [Rivers] [(null)] <(null)> -        Colorado River
            2006-01-19 12:45:01,821 [4240] INFO  [Rivers] [(null)] <(null)> -        Green River
            2006-01-19 12:45:01,821 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,821 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers in Colorado and Utah that are not shared by both states:
            2006-01-19 12:45:01,821 [4240] INFO  [Rivers] [(null)] <(null)> -        Arkansas River
            2006-01-19 12:45:01,837 [4240] INFO  [Rivers] [(null)] <(null)> -        Rio Grande
            2006-01-19 12:45:01,837 [4240] INFO  [Rivers] [(null)] <(null)> -        San Juan River
            2006-01-19 12:45:01,837 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,837 [4240] INFO  [Rivers] [(null)] <(null)> - Rivers common to Arizona, California, Colorado, Nevada, and Utah:
            2006-01-19 12:45:01,852 [4240] INFO  [Rivers] [(null)] <(null)> -        Colorado River
            2006-01-19 12:45:01,852 [4240] INFO  [Rivers] [(null)] <(null)> -
            2006-01-19 12:45:01,868 [4240] INFO  [Rivers] [(null)] <(null)> - The type of this complex operation is: Hca.Common.Collection.SortedSet
            Press any key to continue
            		]]></code>
            	</p> 
            </example>
        </member>
        <member name="T:Hca.Common.Collection.SortedSet">
            <summary>
            Implements a <see cref="T:Hca.Common.Collection.Set"/> based on a <see cref="T:System.Collections.SortedList"/>.
            </summary>
            <remarks>
            <para>
            The sorted implementation gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <see cref="T:Hca.Common.Collection.HashSet"/>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <see cref="T:System.IComparable"/>,
            and they must actually be comparable.  You can't mix <see cref="T:System.String"/> and <see cref="T:System.Int32"/> values, for example.
            </para>
            <para>
            When defining classes that may be put in a <see cref="T:Hca.Common.Collection.SortedSet"/>, be sure that the comparer is based on the entire
            value of the object. If it does not, then no guarantees can be made about operations on this set. As an alternative
            to prevent this, you can create a <see cref="T:System.Collections.IComparer"/> that can be passed on construction of a <see cref="T:Hca.Common.Collection.SortedSet"/>.
            This will allow the internal implementation to use just this comparer for all actions.
            </para>
            </remarks>
            <example>
            For basic usage, see the collection namespace documentation.
            This example shows using the case-insensitive comparer for a string based sorted set.
            <code>
            	using System.Collections;
            	using Hca.Common.Collection;
            	...
            	ArrayList expectedOrder = new ArrayList( 3 );
            	expectedOrder.Add( "ONE" );
            	expectedOrder.Add( "two" );
            	expectedOrder.Add( "tHree" );
            	
            	SortedSet theSet = new SortedSet( expectedOrder, new CaseInsensitiveComparer() );
            	Print("Case Insensitive Comparer", theSet);
            	...
            	
            	private static void Print(string title, Set elements)
            	{
            		log.Info(title);
            		foreach(object o in elements)
            		{
            			log.Info("\t {0}", o);
            		}
            		log.Info("");
            	}
            </code>
            The Print yields the following Result:
            <code><![CDATA[
            	2006-01-19 16:39:30,376 [5776] INFO  [Rivers] [(null)] <(null)> - Case Insensitive Comparer
            	2006-01-19 16:34:47,301 [5652] INFO  [Rivers] [(null)] <(null)> -        ONE
            	2006-01-19 16:34:47,301 [5652] INFO  [Rivers] [(null)] <(null)> -        tHree
            	2006-01-19 16:34:47,301 [5652] INFO  [Rivers] [(null)] <(null)> -        two
            	2006-01-19 16:34:47,301 [5652] INFO  [Rivers] [(null)] <(null)> -	]]></code>
            </example>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Collection.SortedSet"/>.</overloads>
            <summary>
            Creates a new set instance based on a sorted list using the default comparer.
            </summary>
            <remarks>
            All items added must implement <see cref="T:System.IComparable"/> and be of the same type. Hence, heterogeneous collections
            are not allowed for a <see cref="T:Hca.Common.Collection.SortedSet"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a sorted list and initializes it based on a collection of elements
            while using the default comparer.
            </summary>
            <remarks><see cref="T:Hca.Common.Collection.SortedSet"/></remarks>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.#ctor(System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted list while using the provided comparer.
            </summary>
            <remarks>
            if the comparer is <see langword="null"/>, a default comparer is used that does value based equality
            and uses the item's <see cref="T:System.IComparable"/> implementation to determine order.
            </remarks>
            <param name="comparisonProvider">The comparison provider for items added to the set.</param>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.#ctor(System.Collections.ICollection,System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted list and initializes it based on a collection of elements
            and provided comparer.
            </summary>
            <remarks>
            </remarks>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="comparisonProvider">The comparison provider for items added to the set.</param>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.Add(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Add(System.Object)"/>
            </summary>
            <param name="item">The item to add</param>
            <returns><see langword="true"/> if added, else already in collection.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.AddAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.AddAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>If the collection passed is zero count, no change occurs to the current set.</remarks>
            <param name="c">The collection to add from</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.Clear">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Clear"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.Contains(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Contains(System.Object)"/>
            </summary>
            <remarks>
            An item is considered to be present if its value is present. Hence, if two different references of the same
            class have the same value and one of those instances is stored in a set, asking for the second reference
            will return <see langword="true"/>. 
            <note>
            <see langword="null"/> is a valid value and hence looking for <see langword="null"/> is not the same as 
            the <see cref="M:Hca.Common.Collection.SortedSet.ContainsAll(System.Collections.ICollection)"/> call being invoked with <see langword="null"/> collection. 
            </note>
            </remarks>
            <param name="item">The item to check for membership in the set</param>
            <returns><see langword="true"/> if the item's value is contained in the set.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.ContainsAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>An empty collection is treated as looking for the "empty set"/&gt; and will always return <see langword="true"/>.</remarks>
            <param name="c">The collection to check</param>
            <returns><see langword="true"/> if all items are present.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.Remove(System.Object)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.Remove(System.Object)"/>
            </summary>
            <param name="item">The item to remove</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.RemoveAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>If the passed collection is empty, no action is taken on the current set.</remarks>
            <param name="c">The collection of items to remove from current set.</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.RetainAll(System.Collections.ICollection)">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.RetainAll(System.Collections.ICollection)"/>
            </summary>
            <remarks>If the passed collection is empty, all members are removed.</remarks>
            <param name="c">The collection whose members will be retained.</param>
            <returns><see langword="true"/> if the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed argument is <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy the elements of this set to an existing array starting at a specified position.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The zero based offset where copying begins in the array</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If array passed is <see langword="null"/> or multidimensional, or if array is to small to hold items</exception>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.GetEnumerator">
            <summary>
            <see cref="M:Hca.Common.Collection.Set.GetEnumerator"/>
            </summary>
            <remarks>The values of the enumeration are the objects that were placed into the set.		
            The enumeration represents a snapshot of the contained objects at the point that the 
            enumeration is created. Hence, the enumeration returned is safe from modifications
            to the set made after the enumeration is returned.</remarks>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> over the elements in the <see cref="T:Hca.Common.Collection.Set"/>.</returns>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.SortSetComparer">
            <summary>
            Get the Comparer for this set.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.SortSet">
            <summary>
            Return the Sorted set
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.IsEmpty">
            <summary>
            Returns <see langword="true"/> if the set has no members.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.Count">
            <summary>
            Returns the number of members in set(the cardinality)
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.SyncRoot">
            <summary>
            Returns on object to lock on for this set.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SortedSet.IsSynchronized">
            <summary>
            Returns whether this set is synchronized.
            </summary>
        </member>
        <member name="T:Hca.Common.Collection.SortedSet.SortedSetComparer">
            <summary>
            This class provides a specialized comparator for handling the semantics we desire for placing items in an 
            ordered set. 
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.SortedSet.SortedSetComparer.Compare(System.Object,System.Object)">
            <summary>
            <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)"/>
            </summary>
            <param name="x">object instance one to compare</param>
            <param name="y">object instance two to compare</param>
            <returns>-1 if <paramref name="x"/> &lt; <paramref name="y"/>, 0 if <paramref name="x"/> == <paramref name="y"/>, 
            and 1 if <paramref name="x"/> &gt; <paramref name="y"/></returns>
        </member>
        <member name="T:Hca.Common.Collection.SynchronizedSet">
            <summary>
            Implements a thread-safe <see cref="T:Hca.Common.Collection.Set"/> wrapper.
            </summary>
            <remarks>
            <p>This implementation is extremely conservative, 
            serializing critical sections to prevent possible deadlocks, and locking on everything.</p>
            <p>This class does not synchronize any collection passed as an argument. Hence if this is an expected need, you
            must synchronize that set before passing into a synchronized operation. The reason for this is that in normal
            use, synchronization may not be needed on that set and hence, the overhead of doing this can be eliminated.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.#ctor(Hca.Common.ISet)">
            <summary>
            Default Ctor
            </summary>
            <param name="basisSet">The set to wrap for synchronization</param>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><see langword="true"/> is the object was added, <see langword="false"/> if it was already present.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <remarks>
            <p>
            If the items in the collection are already present, they are not added and hence the collection remains
            unchanged. An empty collection will always cause <see langword="false"/> to be returned.</p></remarks>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><see langword="true"/> is the set changed as a result of this operation, <see langword="false"/> if not.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If the passed collection is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.Contains(System.Object)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><see langword="true"/> if this set contains the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <see langword="true"/> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><see langword="true"/> if the set contains all the elements in the specified collection, 
            <see langword="false"/> otherwise.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If passed collection is null</exception>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><see langword="true"/> if the set contained the specified element, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><see langword="true"/> if the set was modified as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If passed collection is null.</exception>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><see langword="true"/> if this set changed as a result of this operation.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">If passed collection is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <see cref="T:Hca.Common.Collection.Set"/> to an array.  The type of array needs
            to be compatible with the objects in the <see cref="T:Hca.Common.Collection.Set"/>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.GetEnumerator">
            <summary>
            Returns a thread-safe enumerator
            </summary>
            <returns>IEnumerator</returns>
        </member>
        <member name="M:Hca.Common.Collection.SynchronizedSet.Clone">
            <summary>
            Returns a clone of the <see cref="T:Hca.Common.Collection.Set"/> instance.  
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="P:Hca.Common.Collection.SynchronizedSet.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SynchronizedSet.IsSynchronized">
            <summary>
            Returns <see langword="true"/>, indicating that this object is thread-safe.  The exception to this
            is enumeration, which is inherently not thread-safe.  Use the <see cref="P:Hca.Common.Collection.Set.SyncRoot"/> object to
            lock this object for the entire duration of the enumeration.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SynchronizedSet.SyncRoot">
            <summary>
            Returns an object that can be used to synchronize the <see cref="T:Hca.Common.Collection.Set"/> between threads.
            </summary>
        </member>
        <member name="P:Hca.Common.Collection.SynchronizedSet.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this set contains no elements.
            </summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache">
            <summary>Caches <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s and their corresponding <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects.</summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para>The functionality of this class was factored out of <see cref="T:Hca.Common.Configuration.ConfigFactory"/> for clarity and cohesion. 
            However, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> is the only expected client.</para>
            </remarks>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.rebuildLock">
            <summary>Used to synchronize reads from <see cref="F:Hca.Common.Configuration.Cache.ConfigCache.caches"/> with calls to <see cref="M:Hca.Common.Configuration.Cache.ConfigCache.Rebuild(Hca.Common.Configuration.IConfigDefinition[])"/>.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.caches">
            <summary>Holds <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> indexed by their <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.#ctor">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache"/>.</summary>
            <exception cref="T:System.ArgumentNullException">Thrown if <c>interpreter</c> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.Rebuild(Hca.Common.Configuration.IConfigDefinition[])">
            <summary>Clears the cache of all configuration <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s and <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects, 
            and re-initializes it with a new set of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <param name="definitions">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</param>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigs(System.Type)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with a specified configuration <see cref="T:System.Type"/>.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with <paramref name="configType"/> 
            (regardless of defined context), or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitions(System.Type)">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/>.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitionCount(System.Type)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/>.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> 
            (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigsWithoutContext(System.Type)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with a specified configuration <see cref="T:System.Type"/> 
            and <see langword="null"/> context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with <paramref name="configType"/> 
            and <see langword="null"/> context, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitionsWithoutContext(System.Type)">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/> 
            and <see langword="null"/> context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitionWithoutContextCount(System.Type)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/> 
            and <see langword="null"/> context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigsWithContext(System.Type,System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with a specified configuration <see cref="T:System.Type"/> 
            and a specified context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <param name="context">The required context.</param>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with <paramref name="configType"/> 
            and <paramref name="context"/>, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitionsWithContext(System.Type,System.String)">
            <summary>Gets <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/> and 
            a specified context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <param name="context">The required context.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetConfigDefinitionWithContextCount(System.Type,System.String)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with a specified configuration <see cref="T:System.Type"/> 
            and a specified context.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <param name="context">The required context.</param>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with <paramref name="configType"/> 
            and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.Clear">
            <summary>Clears the cache of all <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s and <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects.</summary>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.AddConfigDefinition(Hca.Common.Configuration.IConfigDefinition)">
            <summary>Adds a <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> for its specified configuration <see cref="T:System.Type"/>.</summary>
            <param name="definition">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>.</param>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetCacheForDefinition(Hca.Common.Configuration.IConfigDefinition)">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>'s 
            specified <see cref="T:System.Type"/>, creating a new one if none exists.</summary>
            <param name="definition">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> specifying the required configuration <see cref="T:System.Type"/>.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>, creating 
            and returning a new cache if none has been created.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetCacheForType(System.Type)">
            <overloads>Gets the <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>.</overloads>
            
            <summary>Gets the <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>, 
            or <see langword="null"/> if none exists.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>, or 
            an empty place-holder if none has been created.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.GetCacheForType(System.Type,System.Boolean)">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>, 
            optionally creating a new cache if none exists.</summary>
            <param name="configType">The required configuration <see cref="T:System.Type"/>.</param>
            <param name="addIfMissing">Whether to create a new one if none exists.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> for a specified configuration <see cref="T:System.Type"/>. 
            If none has been created, behavior is determined by <i>addIfMissing</i>: if <see langword="true"/>, 
            a new cache is created and returned; if <see langword="true"/>, an empty place-holder is returned.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache">
            <summary>Interface for retrieving <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects from a <see cref="T:System.Type"/>-specific cache.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigs">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects.</summary>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context), or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitions">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitionCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with <see langword="null"/> context.</summary>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitionsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitionWithoutContextCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            and <paramref name="context"/>, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitionsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.GetConfigDefinitionWithContextCount(System.String)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            and <paramref name="context"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects exposed by this cache.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache">
            <summary>Fully-functional implementation of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/>.</summary>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.configType">
            <summary>Holds the <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects exposed by this cache.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.instanceDefinitions">
            <summary>Holds all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.instanceDefinitionsWithNullContext">
            <summary>Holds all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects specifying <see langword="null"/> context.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.instanceDefinitionsByContext">
            <summary>Holds all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects, indexed by their respective (non <see langword="null"/>) 
            context(s).</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.#ctor(System.Type)">
            <summary>Constructs a fully-functional implementation of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/>.</summary>
            <param name="configType">The <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects exposed by this cache.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <c>interpreter</c> is <see langword="null"/>.</exception>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigs">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects.</summary>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context), or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitions">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitionCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with <see langword="null"/> context.</summary>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitionsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitionWithoutContextCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>An array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <paramref name="context"/>, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitionsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.GetConfigDefinitionWithContextCount(System.String)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The number of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType"/> 
            and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.AddConfigDefinition(Hca.Common.Configuration.IConfigDefinition)">
            <summary>Adds a <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>.</summary>
            <param name="definition">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>.</param>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ValidateConfigDefinition(Hca.Common.Configuration.IConfigDefinition)">
            <summary>Ensures that the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> reference passed is not <see langword="null"/> 
            and that its <see cref="P:Hca.Common.Configuration.IConfigDefinition.ConfigType"/> is assignable to <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</summary>
            <param name="definition">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> to check.</param>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ConfigType">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects exposed by this cache.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList">
            <summary>Implements collection functionality for <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> items with a specific 
            <see cref="P:Hca.Common.Configuration.IConfigDefinition.ConfigType"/>.</summary>
            <remarks>Type safety is provided for the declared methods and properties. However, a known hole exists where the 
            base class' interface implementations are used. This hole was deemed small due to this classes limited 
            scope of usage.</remarks>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.configType">
            <summary>Holds the <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ConfigType"/> of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects managed by this list.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.#ctor(System.Type)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/>.</summary>
            <param name="configType">The <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ConfigType"/> of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects 
            managed by this list.</param>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="configType"/> does not inherit 
            from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.Add(Hca.Common.Configuration.IConfigDefinition)">
            <summary>Adds a <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> to the end of this list.</summary>
            <param name="instance">The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> to add.</param>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.GetOutputConfigs">
            <summary>Retrieves the <see cref="P:Hca.Common.Configuration.IConfigDefinition.OutputConfig"/>s from this list's 
            <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>An array of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects, or an empty array if this list is empty. 
            The return value may be cast directly to an array of the type specified by <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ConfigType"/>.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ToArray">
            <summary>Retrieves the contents of the list.</summary>
            <returns>An array of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ConfigType">
            <summary>Gets the <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.ConfigType"/> of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects managed by this list.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList.Item(System.Int32)">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> at the specified index in this list.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary">
            <summary>Indexes <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/>s by their members' 
            <see cref="P:Hca.Common.Configuration.IConfigDefinition.Contexts"/>.</summary>
            <remarks>Type safety is provided for the declared methods and properties. However, a known hole exists where the 
            base class' interface implementations are used. This hole was deemed small due to this class' limited scope 
            of usage.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary.Add(System.String,Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList)">
            <summary>Adds an element to this dictionary with a <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/> value and 
            a context <see cref="T:System.String"/> key.</summary>
            <param name="context">The context key of the element to add.</param>
            <param name="list">The <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/> value of the element to add.</param>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary.Contains(System.String)">
            <summary>Determines whether this dictionary contains an <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/> element 
            with the specified context.</summary>
            <param name="context">The context to locate.</param>
            <returns>Whether this dictionary contains the specified context key.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary.Item(System.String)">
            <summary>Gets a <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/> by its members' 
            <see cref="P:Hca.Common.Configuration.IConfigDefinition.Contexts"/>, or <see langword="null"/> if none is found.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary.Keys">
            <summary>Gets a <see cref="T:System.String"/> array containing the unique contexts indexing this dictionary.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.ContextualConfigDefinitionListDictionary.Values">
            <summary>Gets an array containing the <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache.TypeSpecificConfigDefinitionList"/> values 
            indexed by this dictionary.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache">
            <summary>Always-empty implementation of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/>.</summary>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.configType">
            <summary>Holds the <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects (ostensibly) exposed by this cache.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.emptyArrayOfConfigType">
            <summary>Holds a pre-constructed, zero-length array of the <see cref="T:System.Type"/> specified by <see cref="F:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.configType"/>.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.#ctor(System.Type)">
            <summary>Constructs an always-empty implementation of <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/>.</summary>
            <param name="configType">The <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects (ostensibly) exposed by this cache.</param>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigs">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects.</summary>
            <returns>An (empty) array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> (regardless of defined context), or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitions">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitionCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s.</summary>
            <returns>The number (0) of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> (regardless of defined context).</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with <see langword="null"/> context.</summary>
            <returns>An (empty) array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <see langword="null"/> context, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitionsWithoutContext">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitionWithoutContextCount">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with <see langword="null"/> context.</summary>
            <returns>The number (0) of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <see langword="null"/> context.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>An (empty) array of the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <paramref name="context"/>, or an empty array if none are defined.
            The return value may be cast directly to an array of the type specified by this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitionsWithContext(System.String)">
            <summary>Gets all the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <paramref name="context"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#GetConfigDefinitionWithContextCount(System.String)">
            <summary>Gets the number of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s with a specified context.</summary>
            <param name="context">The required context.</param>
            <returns>The number (0) of the <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>s defined with this cache's 
            <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> and <paramref name="context"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.EmptyTypeSpecificConfigCache.Hca#Common#Configuration#Cache#ConfigCache+ITypeSpecificConfigCache#ConfigType">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects (ostensibly) exposed by this cache.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCacheDictionary">
            <summary>Indexes <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/>s by their <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</summary>
            <remarks>Type safety is provided for the declared methods and properties. However, a known hole exists where the base 
            class' interface implementations are used. This hole was deemed small due to this class' limited scope of usage.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCacheDictionary.Add(Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCache)">
            <summary>Adds an element to this dictionary with a <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> value and a 
            <see cref="T:System.Type"/> key.</summary>
            <param name="value">The <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> value of the element to add.</param>
            <remarks>The <see cref="T:System.Type"/> key is derived from the <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/> 
            property of <paramref name="value"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCacheDictionary.Contains(System.Type)">
            <summary>Determines whether this dictionary contains an <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> element 
            with the specified <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>.</summary>
            <param name="key">The <see cref="T:System.Type"/> key to locate.</param>
            <returns>Whether this dictionary contains the specified <see cref="T:System.Type"/> key.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCacheDictionary.Item(System.Type)">
            <summary>Gets an <see cref="T:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache"/> by its <see cref="P:Hca.Common.Configuration.Cache.ConfigCache.ITypeSpecificConfigCache.ConfigType"/>, 
            or <see langword="null"/> if none is found.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Cache.ConfigCache.TypeSpecificConfigCacheDictionary.Keys">
            <summary>Gets a list of the <see cref="T:System.Type"/>s of cofiguration objects defined in the caches indexed by this dictionary.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.AppConfigSource">
            <summary>Provides access to the list of XML configuration definitions in .NET's application configuration XML.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource">
            <summary>Abstracts a discrete list of XML configuration definitions.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.IChangeWatcher">
            <summary>Abstracts interaction with mutable configuration sources.</summary>
        </member>
        <member name="E:Hca.Common.Configuration.Store.IChangeWatcher.Changed">
            <summary>Indicates when the contents of a source have changed.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigSource.Dispose">
            <summary>When overridden in a derived class, performs tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="E:Hca.Common.Configuration.Store.ConfigSource.Changed">
            <summary>Indicates when the contents of a source have changed.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.ConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigSource.interpreter">
            <summary>Caches the result of <see cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigSource.Interpreter"/>'s getter for multiple calls.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigSource.GetXml">
            <summary>Gets a reader for this source's XML.</summary>
            <returns>An <see cref="T:System.Xml.XmlTextReader"/> containing the unvalidated XML from this configuration source.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigSource.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource"/>.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource"/>.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigSource.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
            <returns>A value-based hash code for the current <see cref="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigSource.Exists">
            <summary>Indicates whether the source specified in this object's constructor actually exists.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigSource.Interpreter">
            <summary>Gets the wrapper around this source's XML.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigSource.UseLineInfo">
            <summary>Whether the line numbers reported by the concrete implementation's <see cref="M:Hca.Common.Configuration.Store.Xml.XmlConfigSource.GetXml"/> should be reported in user messages.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigSource.RelativeReferenceBasePath">
            <summary>Gets the file system path from which relative file system includes should be based.</summary>
            <remarks>This should be a directory name, with or without the trailing separator character.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AppConfigSource.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.AppConfigSource"/>.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Hca.Common.Configuration.Store.Xml.AppConfigSource"/>.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.AppConfigSource"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AppConfigSource.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
            <returns>A value-based hash code for the current <see cref="T:Hca.Common.Configuration.Store.Xml.AppConfigSource"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AppConfigSource.Dispose">
            <summary>Override method required by <see langword="abstract"/> base performs no actual function.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AppConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AppConfigSource.Exists">
            <summary>Indicates whether the source specified in this object's constructor actually exists.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AppConfigSource.UseLineInfo">
            <summary>Whether the line numbers reported by the concrete implementation's <see cref="M:Hca.Common.Configuration.Store.Xml.AppConfigSource.GetXml"/> should be reported in user messages.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AppConfigSource.RelativeReferenceBasePath">
            <summary>Gets the file system path from which relative file system includes should be based.</summary>
            <remarks>This implementation returns the application domain's <see cref="P:System.AppDomain.BaseDirectory"/>.</remarks>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource">
            <summary>Provides access to the list of XML configuration definitions in an XML file resource embedded in a .NET assembly.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource"/>.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource"/>.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.AssembliesAreEqual(System.Reflection.Assembly,System.String,System.Reflection.Assembly,System.String)">
            <summary>Compares two assemblies either by actual fusion-determined <see cref="P:System.Reflection.Assembly.FullName"/>, or by provided name if they can't be loaded.</summary>
            <param name="asm1">The first assembly to compare.</param>
            <param name="asm1Name">The name of the assembly to load if <paramref name="asm1"/> is <see langword="null"/>.</param>
            <param name="asm2">The second assembly to compare.</param>
            <param name="asm2Name">The name of the assembly to load if <paramref name="asm2"/> is <see langword="null"/>.</param>
            <returns><see langword="true"/> if both comparands are or can be loaded and are the same assembly, or if neither can be loaded but the names are the same; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
            <returns>A value-based hash code for the current <see cref="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.Dispose">
            <summary>Override method required by abstract base performs no actual function.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.Exists">
            <summary>Indicates whether the source specified in this object's constructor actually exists.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.UseLineInfo">
            <summary>Whether the line numbers reported by the concrete implementation's <see cref="M:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.GetXml"/> should be reported in user messages.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource.RelativeReferenceBasePath">
            <summary>Gets the file system path from which relative file system includes should be based.</summary>
            <remarks>This implementation returns the application domain's <see cref="P:System.AppDomain.BaseDirectory"/>.</remarks>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.AttributedAssembliesConfigSource">
            <summary>Watches for new assemblies with the <see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute"/>.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AttributedAssembliesConfigSource.HandleAssemblyLoad(System.Object,System.AssemblyLoadEventArgs)">
            <summary>Handles the <see cref="E:System.AppDomain.AssemblyLoad"/> event, raising <see cref="E:Hca.Common.Configuration.Store.ConfigSource.Changed"/> if the assembly declares a configuration file.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.AttributedAssembliesConfigSource.Dispose">
            <summary>Releases the watch on the <see cref="E:System.AppDomain.AssemblyLoad"/> event.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.AttributedAssembliesConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter">
            <summary>Interprets configuration XML files and nodes for object-oriented consumption.</summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para>The functionality of this class was factored out of <see cref="T:Hca.Common.Configuration.ConfigFactory"/> for clarity and cohesion. However, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> and <see cref="T:Hca.Common.Configuration.Cache.ConfigCache"/> are the only clients presently designed for.</para>
            <para>This class in turn depends on a <see cref="T:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor"/> and a <see cref="T:Hca.Common.Builder.IObjectBuilder"/>, which must be provided for construction by the (<see cref="T:Hca.Common.Configuration.ConfigFactory"/>) client.</para>
            </remarks>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.PREFIX">
            <summary>An arbitrary XML namespace prefix used for XPath queries.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.subject">
            <summary>Holds the XML configuration document to be interpreted.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.description">
            <summary>Holds a human-readable description of the source of <cref name="subject" />.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.schema">
            <summary>Generates the config XSD descriptor and object builder being used.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.nsMgr">
            <summary>Holds the namespace information used for XPath queries.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.#ctor(System.Xml.XmlDocument,System.String,Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.ISchema)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter"/>.</summary>
            <param name="subject">The XML configuration document to be interpreted.</param>
            <param name="description">A human-readable description of the source of <paramref name="subject"/>.</param>
            <param name="schema">Generates the config XSD descriptor and object builder being used.</param>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.ForXml(System.Xml.XmlTextReader,System.String,System.Boolean)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter"/> wrapping the contents of a given XML reader.</summary>
            <param name="source">The XML reader defining configuration.</param>
            <param name="description">A human-readable description of the source of the XML.</param>
            <param name="useLineInfo">Indicates whether the line information reported by <paramref name="source"/> should be reported in user messages.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="source"/>'s root element is unrecognized.</exception>
            <returns>An instance of <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.FindIncludes(System.Xml.XmlNode)">
            <summary>Retrieves the <see cref="T:System.Xml.XmlNode"/>s from a given configuration <see cref="T:System.Xml.XmlNode"/> that specify inclusion of other configuration documents.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/> in which to search.</param>
            <returns>An <see cref="T:System.Xml.XmlNodeList"/> of the include nodes found in <paramref name="source"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetIncludeId(System.Xml.XmlNode)">
            <summary>Retrieves the inclusion id from a given 'include' <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The 'include' <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A string representing the inclusion id, or <see langword="null"/> if none is specified.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetFileName(System.Xml.XmlNode)">
            <summary>Retrieves the file name from a given 'include' <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The 'include' <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A string representing the file name, or <see langword="null"/> if none is specified.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetAssemblyName(System.Xml.XmlNode)">
            <summary>Retrieves the assembly name from a given 'include' <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The 'include' <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A string representing the assembly name, or <see langword="null"/> if none is specified.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.FindTokenDefaults(System.Xml.XmlNode)">
            <summary>Retrieves the <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token default name/value pairs from a given configuration <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/> in which to search.</param>
            <returns>An <see cref="T:System.Xml.XmlNodeList"/> of the token default nodes found in <paramref name="source"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.FindTokens(System.Xml.XmlNode)">
            <summary>Retrieves the <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token name/value pairs from a given configuration <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/> in which to search.</param>
            <returns>An <see cref="T:System.Xml.XmlNodeList"/> of the token nodes found in <paramref name="source"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetTokenName(System.Xml.XmlNode)">
            <summary>Retrieves the token name from a given 'token' <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The 'token' <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A string representing the token name.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetTokenValue(System.Xml.XmlNode)">
            <summary>Retrieves the token value name from a given 'token' <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The 'token' <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A string representing the token value.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.FindConfigs(System.Xml.XmlNode)">
            <summary>Retrieves the <see cref="T:System.Xml.XmlNode"/>s that define configuration instances from a given configuration <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/> in which to search.</param>
            <returns>An <see cref="T:System.Xml.XmlNodeList"/> of the configuration nodes found in <paramref name="source"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetReadOnly(System.Xml.XmlNode)">
            <summary>Retrieves the read-only setting from a given configuration instance <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A boolean representing the read-only setting.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetContext(System.Xml.XmlNode)">
            <summary>Retrieves the list of contexts from a given configuration instance <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>A delimited string representing the list of contexts, or <see langword="null"/> if none are specified.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetType(System.Xml.XmlNode)">
            <summary>Retrieves the target type of a given configuration instance <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>The <see cref="T:System.Type"/> of which <paramref name="source"/> defines an instance.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.Build(System.Xml.XmlNode,Hca.Common.Builder.TokenFilter,System.Boolean)">
            <summary>Builds the configuration object defined by a given configuration <see cref="T:System.Xml.XmlNode"/>, optionally calling its <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/>.</param>
            <param name="tokenFilter">The filter to use for token expansion.</param>
            <param name="validate">Whether to call the object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</param>
            <returns>The configuration object defined by <paramref name="source"/>.</returns>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>Retrieves the string value of a spcified attribute on a specified <see cref="T:System.Xml.XmlNode"/>.</summary>
            <param name="source">The containing <see cref="T:System.Xml.XmlNode"/>.</param>
            <param name="name">The name of the attribute from which to retrieve the value.</param>
            <returns>The string value of <paramref name="source"/>'s attribute specified by <i>name</i>, or <see langword="null"/> if it is undefined or empty.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.FindNodes(System.Xml.XmlNode,System.String)">
            <summary>Queries a given configuration <see cref="T:System.Xml.XmlDocument"/> for the <see cref="T:System.Xml.XmlNode"/>s matching a given XPath.</summary>
            <param name="source">The configuration <see cref="T:System.Xml.XmlNode"/> in which to search.</param>
            <param name="query">The XPath specifying what <see cref="T:System.Xml.XmlNode"/>s to retrieve, with a placeholder ("{0}") for this interpreter's namespace prefix.</param>
            <returns>An <see cref="T:System.Xml.XmlNodeList"/> of the <see cref="T:System.Xml.XmlNode"/>s in <paramref name="source"/> which match <paramref name="query"/>.</returns>
            <remarks>See <see cref="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.MassageXPathQuery(System.String)"/> for details on namespace prefix placeholders in <paramref name="query"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.MassageXPathQuery(System.String)">
            <summary>Replaces a placeholder in a given string with the configuration namespace prefix defined for this interpreter.</summary>
            <param name="query">An XPath query with a placeholder ({0}) for this interpreter's namespace prefix.</param>
            <returns>An XPath query with all namespace prefix placeholders populated with this interpreter's namespace prefix.</returns>
            <remarks>The placeholder(s) must take the form recognizable to <see cref="M:System.String.Format(System.String,System.Object)"/>. Since only one prefix is being assigned, all placeholders have the same number: 0</remarks>
            <example>If <paramref name="query"/> is <c>"{0}hcaConfigFactory/{0}config"</c>, and <see cref="F:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter.PREFIX"/> is <c>"ConfigFactory"</c>, this method will return <c>"ConfigFactory:hcaConfigFactory/ConfigFactory:config"</c>.</example>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor">
            <summary>Describes <i>EmbedFile.ConfigFactory.xsd</i> for programmatic consumption.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor">
            <summary>Describes a <see cref="T:Hca.Common.Configuration.ConfigFactory"/> XML schema (XSD file) for programmatic consumption.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.RootElementName">
            <summary>Gets the element name for the root configuration node.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.FactoryXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify a configuration fragment.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.IncludesXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify inclusion of other configuration documents.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.IncludeIdAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s inclusion id value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.FileNameAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s file name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.AssemblyNameAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s assembly name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.TokenDefaultsXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token default name/value pairs.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.TokensXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token name/value pairs.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.TokenNameAttributeName">
            <summary>Gets the attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.TokenValueAttributeName">
            <summary>Gets the attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-value value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.ConfigsXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that define configuration instances.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.ReadOnlyAttributeName">
            <summary>Gets the attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s read-only setting.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.IConfigXsdDescriptor.ContextAttributeName">
            <summary>Gets the attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s contexts list.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.SCHEMA_RESOURCE_NAME">
            <summary>The name of the embedded resource containing the .XSD file.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.SCHEMA_NAMESPACE_URI">
            <summary>The Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ROOT_ELEMENT_NAME">
            <summary>The element name for the root configuration node.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.FACTORY_XPATH_QUERY">
            <summary>The XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify a configuration fragment.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.INCLUDES_XPATH_QUERY">
            <summary>The XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify inclusion of other configuration documents.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.INCLUDE_ID_ATTRIBUTE_NAME">
            <summary>The attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s inclusion id value.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.FILE_NAME_ATTRIBUTE_NAME">
            <summary>The attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s file name value.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ASSEMBLY_NAME_ATTRIBUTE_NAME">
            <summary>The attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s assembly name value.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TOKEN_DEFAULTS_XPATH_QUERY">
            <summary>The XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token default name/value pairs.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TOKENS_XPATH_QUERY">
            <summary>The XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token name/value pairs.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TOKEN_NAME_ATTRIBUTE_NAME">
            <summary>The attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-name value.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TOKEN_VALUE_ATTRIBUTE_NAME">
            <summary>The attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-value value.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.CONFIGS_XPATH_QUERY">
            <summary>The XPath for locating <see cref="T:System.Xml.XmlNode"/>s that define configuration instances.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.READ_ONLY_ATTRIBUTE_NAME">
            <summary>The attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s read-only setting.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.CONTEXT_ATTRIBUTE_NAME">
            <summary>The attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s contexts list.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.schemas">
            <summary>Holds the cached result of <see cref="M:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.GetSchemas"/>.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.#ctor">
            <summary>Private constructor supports / enforces singleton pattern.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.GetSchemas">
            <summary>Retrieves all the schema information necessary to validate an XML document written against the schema that this descriptor represents.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the primary XML schema represented by this descriptor, as well as any other schemas referenced by the primary schema.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.Instance">
            <summary>Gets the singleton instance of <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor"/>.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.NamespaceUri">
            <summary>Gets the Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ReferencedXsds">
            <summary>Gets a list of the schemas referenced by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.RootElementName">
            <summary>Gets the element name for the root configuration node.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.FactoryXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify a configuration fragment.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.IncludesXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify inclusion of other configuration documents.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.IncludeIdAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s inclusion id value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.FileNameAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s file name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.AssemblyNameAttributeName">
            <summary>Gets the attribute name of an 'include' <see cref="T:System.Xml.XmlNode"/>'s assembly name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TokenDefaultsXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token default name/value pairs.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TokensXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that specify replaceable token name/value pairs.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TokenNameAttributeName">
            <summary>Gets the attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-name value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.TokenValueAttributeName">
            <summary>Gets the attribute name of a 'token' <see cref="T:System.Xml.XmlNode"/>'s token-value value.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ConfigsXPathQuery">
            <summary>Gets the XPath for locating <see cref="T:System.Xml.XmlNode"/>s that define configuration instances.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ReadOnlyAttributeName">
            <summary>Gets the attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s read-only setting.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.ConfigXsdDescriptor.ContextAttributeName">
            <summary>Gets the attribute name of a configuration instance <see cref="T:System.Xml.XmlNode"/>'s contexts list.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.EncryptedFileConfigSource">
            <summary>Provides access to the list of XML configuration definitions in an encrypted XML file.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.FileConfigSource">
            <summary>Provides access to the list of XML configuration definitions in an XML file.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.Dispose">
            <summary>Releases the watch on the configuration file.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.HandleWatcherRenamed(System.Object,System.IO.RenamedEventArgs)">
            <summary>Fired when a the watcher detects the file has been renamed.</summary>
            <param name="sender">object firing the event</param>
            <param name="e">The event args for the event</param>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.HandleWatcherChanged(System.Object,System.IO.FileSystemEventArgs)">
            <summary>Fired when the file watcher detects the file has changed.</summary>
            <param name="sender">object firing the event</param>
            <param name="e">The event args for the event</param>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.FileConfigSource"/>.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Hca.Common.Configuration.Store.Xml.FileConfigSource"/>.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hca.Common.Configuration.Store.Xml.FileConfigSource"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
            <returns>A value-based hash code for the current <see cref="T:Hca.Common.Configuration.Store.Xml.FileConfigSource"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.AbsolutePath">
            <summary>Gets a rooted path to the file.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.Exists">
            <summary>Indicates whether the source specified in this object's constructor actually exists.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.UseLineInfo">
            <summary>Whether the line numbers reported by the concrete implementation's <see cref="M:Hca.Common.Configuration.Store.Xml.FileConfigSource.GetXml"/> should be reported in user messages.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.RelativeReferenceBasePath">
            <summary>Gets the file system path from which relative file system includes should be based.</summary>
            <remarks>This implementation returns the directory portion of <see cref="P:Hca.Common.Configuration.Store.Xml.FileConfigSource.AbsolutePath"/>.</remarks>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.EncryptedFileConfigSource.Description">
            <summary>Gets a human-readable description of this configuration source.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition">
            <summary>Caches a single configuration <see cref="T:System.Xml.XmlNode"/> and (once built) its corresponding <see cref="T:Hca.Common.Configuration.ConfigBase"/> object. Builds the object from the XML just-in-time when requested.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.IConfigDefinition.Location">
            <summary>Gets a human-readable description of where this configuration is declared - used when reporting configuration errors.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.IConfigDefinition.ConfigType">
            <summary>Gets the concrete <see cref="T:System.Type"/> of <see cref="P:Hca.Common.Configuration.IConfigDefinition.OutputConfig"/>.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.IConfigDefinition.Contexts">
            <summary>Gets the contexts for which this object is defined.</summary>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="P:Hca.Common.Configuration.IConfigDefinition.OutputConfig">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.ConfigBase"/> object built by this object, calling its <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</summary>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.interpreter">
            <summary>Holds the <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter"/> to be used for building <c>outputConfig</c>.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.tokenFilter">
            <summary>Holds the filter to use for token expansion.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.inputXml">
            <summary>Holds the configuration <see cref="T:System.Xml.XmlNode"/> represented by this object.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.configType">
            <summary>Holds the concrete <see cref="T:System.Type"/> of <see cref="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfig"/>.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.location">
            <summary>Holds a human-readable description of where this configuration is declared - used when reporting configuration errors.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfigSyncRoot">
            <summary>Used to synchronize access to <see cref="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfigIsSet"/>.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfigIsSet">
            <summary>Indicates whether <see cref="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfig"/> has been (or is being) built.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.outputConfig">
            <summary>Holds the <see cref="T:Hca.Common.Configuration.ConfigBase"/> object built by this object.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.#ctor(Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter,Hca.Common.Builder.TokenFilter,System.Xml.XmlNode,System.String)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/>.</summary>
            <param name="interpreter">The <see cref="T:Hca.Common.Configuration.Store.Xml.ConfigXmlInterpreter"/> to be used for building <see cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.OutputConfig"/>.</param>
            <param name="tokenFilter">The filter to use for token expansion.</param>
            <param name="inputXml">The configuration <see cref="T:System.Xml.XmlNode"/> represented by this object.</param>
            <param name="location">A human-readable description of where this configuration is declared - used when reporting configuration errors.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="interpreter"/>, <paramref name="tokenFilter"/>, <paramref name="inputXml"/> or <paramref name="location"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="inputXml"/> does not define a <see cref="T:Hca.Common.Configuration.ConfigBase"/> object.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.SplitContextsString(System.String)">
            <summary>
            Splits a <see cref="T:System.String"/> list of contexts.
            </summary>
            <param name="source">A comma-delmited (',') <see cref="T:System.String"/> of context names.</param>
            <returns>A <see cref="T:System.String"/> array of context names. </returns>
            <seealso cref="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.JoinContextsString(System.String[])"/>
            <seealso cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.Contexts"/>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.JoinContextsString(System.String[])">
            <summary>
            Joins a <see cref="T:System.String"/> list of contexts.
            </summary>
            <param name="source">A <see cref="T:System.String"/> array of context names.</param>
            <returns>A comma-delmited (',') <see cref="T:System.String"/> of context names.</returns>
            <seealso cref="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.SplitContextsString(System.String)"/>
            <seealso cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.Contexts"/>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.JoinContextsString(System.Collections.Specialized.StringCollection)">
            <summary>
            Joins a <see cref="T:System.String"/> list of contexts.
            </summary>
            <param name="source">A <see cref="T:System.Collections.Specialized.StringCollection"/> of context names.</param>
            <returns>A comma-delmited (',') <see cref="T:System.String"/> of context names. See also: <see cref="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.JoinContextsString(System.String[])"/>, <see cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.Contexts"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.SplitStringIntoUniques(System.String,System.Char,System.Boolean)">
            <summary>
            Splits a <see cref="T:System.String"/> into an array, on a given character, <see cref="M:System.String.Trim(System.Char[])"/>ing all entries, ensuring no duplicate entries, and either converting <see cref="F:System.String.Empty"/> to <see langword="null"/> or skipping it altogether.
            </summary>
            <param name="source">The <see cref="T:System.String"/> list to split.</param>
            <param name="separator">The character separating entries in <paramref name="source"/>.</param>
            <param name="includeNull">Whether to include <see langword="null"/> (<see cref="F:System.String.Empty"/> entries in the returned array.</param>
            <returns>A <see cref="T:System.String"/> array of the entries found.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.InputXml">
            <summary>Gets the configuration <see cref="T:System.Xml.XmlNode"/> represented by this object.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.Location">
            <summary>Gets a human-readable description of where this configuration is declared - used when reporting configuration errors.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.ConfigType">
            <summary>Gets the concrete <see cref="T:System.Type"/> of <see cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.OutputConfig"/>.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.Contexts">
            <summary>Gets the contexts in which <see cref="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.OutputConfig"/> is defined.</summary>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="P:Hca.Common.Configuration.Store.Xml.XmlConfigDefinition.OutputConfig">
            <summary>Gets the <see cref="T:Hca.Common.Configuration.ConfigBase"/> object built by this object, calling its <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</summary>
            <exception cref="T:System.Exception">TODO</exception>
        </member>
        <member name="T:Hca.Common.Configuration.Store.AggregateChangeWatcher">
            <summary>Wraps a collection of <see cref="T:Hca.Common.Configuration.Store.IChangeWatcher"/> objects with a single point of interaction.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.Store.BufferedChangeWatcher">
            <summary>Wraps a <see cref="T:Hca.Common.Configuration.Store.IChangeWatcher"/> for delayed notification of changes.</summary>
            <remarks>This class implements the delay used by <see cref="T:Hca.Common.Configuration.Store.ConfigStore"/> to prevent unnecessary processing when multiple sources are being updated in one batch.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.Store.BufferedChangeWatcher.HandleDelayTimerExpired(System.Object)">
            <summary>Called by the timer when the configuration has been updated.</summary>
            <param name="state">Ignore.</param>
        </member>
        <member name="T:Hca.Common.Configuration.Store.ConfigStore">
            <summary>Provides access to an XML repository of configuration object definitions.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.IConfigStore">
            <summary>Abstracts a repository of configuration object definitions.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.IConfigStore.GetConfigDefinitions(System.String[])">
            <summary>Retrieves the contents of this store.</summary>
            <param name="activeIncludeIds">Names the optional items that should be included by this operation.</param>
            <returns>An array of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects that can be sorted and cached without expending the resources to actually build all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined.</returns>
        </member>
        <member name="E:Hca.Common.Configuration.IConfigStore.Changed">
            <summary>Indicates when configuration in this store has changed.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.ConfigStore.PRIMARY_DOCUMENT_CONFIG_KEY">
            <summary>The configuration key used to override the default primary configuration file name.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.ConfigStore.REFRESH_TIMEOUT">
            <summary>The number of milliseconds to wait after a source is changed before all sources are reloaded. (Used to prevent unnecessary processing when multiple sources are being updated in one batch.)</summary>
        </member>
        <member name="F:Hca.Common.Configuration.Store.ConfigStore.changeWatcher">
            <summary>Receives notification of changes to sources in this store.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigStore.GetConfigDefinitions(System.String[])">
            <summary>Retrieves the contents of this store.</summary>
            <param name="activeIncludeIds">Names the optional items that should be included by this operation.</param>
            <returns>An array of <see cref="T:Hca.Common.Configuration.IConfigDefinition"/> objects that can be sorted and cached without expending the resources to actually build all the <see cref="T:Hca.Common.Configuration.ConfigBase"/> objects defined.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigStore.GetPrimarySource">
            <summary>Finds the primary configuration source.</summary>
            <returns>The root <see cref="T:Hca.Common.Configuration.Store.Xml.XmlConfigSource"/> for this application.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigStore.AppendSources(System.Collections.IList,Hca.Common.Configuration.Store.AggregateChangeWatcher,Hca.Common.Configuration.Store.ConfigSource,System.String[])">
            <summary>Adds a given <see cref="T:Hca.Common.Configuration.Store.ConfigSource"/> and any others that it references (see <see cref="M:Hca.Common.Configuration.Store.ConfigSource.GetReferencedSources(System.String[])"/>) to a specified <see cref="T:System.Collections.IList"/> and <see cref="T:Hca.Common.Configuration.Store.AggregateChangeWatcher"/>.</summary>
            <param name="target">The <see cref="T:System.Collections.IList"/> to which to add all sources (that aren't already in the list).</param>
            <param name="watchers">The <see cref="T:Hca.Common.Configuration.Store.AggregateChangeWatcher"/> to which to add all sources.</param>
            <param name="source">The <see cref="T:Hca.Common.Configuration.Store.ConfigSource"/> with which to start the operation.</param>
            <param name="activeIncludeIds">Names the optional items that should be included by this operation.</param>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigStore.HandleSourceChanged(System.Object,System.EventArgs)">
            <summary>Fired when a file watcher detects a file has changed.</summary>
            <param name="sender">object firing the event</param>
            <param name="e">event args</param>
        </member>
        <member name="M:Hca.Common.Configuration.Store.ConfigStore.OnChanged">
            <summary>Raises the <see cref="E:Hca.Common.Configuration.Store.ConfigStore.Changed"/> event.</summary>
            <event><see cref="E:Hca.Common.Configuration.Store.ConfigStore.Changed"/></event>
        </member>
        <member name="E:Hca.Common.Configuration.Store.ConfigStore.Changed">
            <summary>Indicates when configuration in this store has changed.</summary>
        </member>
        <member name="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute">
            <summary>Specifies 'bootstrap' configuration to be loaded by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when this assembly is in use.</summary>
            <remarks>The referenced configuration file may be embedded in this assembly or found in an external file.</remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for example code applying this attribute to an assembly.</example>
        </member>
        <member name="F:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.fileName">
            <summary>Holds the name of the configuration file to load when the marked this assembly is in use.</summary>
        </member>
        <member name="F:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.isEmbedded">
            <summary>Holds whether <see cref="F:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.fileName"/> refers to an embedded resource, or, instead, an external file.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.#ctor(System.String)">
            <summary>Initializes an instance referencing an embedded resource.</summary>
            <param name="fileName">The name of the configuration file to load when the marked this assembly is in use.</param>
        </member>
        <member name="M:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.#ctor(System.String,System.Boolean)">
            <summary>Initializes an instance referencing either an embedded resource or an external file.</summary>
            <param name="fileName">The name of the configuration file to load when the marked this assembly is in use.</param>
            <param name="isEmbedded">Indicates whether <see cref="F:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.fileName"/> refers to an embedded resource, or, instead, an external file</param>
            <remarks>See the <see cref="P:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.FileName"/> property for information on how <see cref="T:Hca.Common.Configuration.ConfigFactory"/> handles <paramref name="fileName"/> if <paramref name="isEmbedded"/> is <see langword="false"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.IsDefaultAttribute">
            <summary>Returns an indication whether the value of this instance is the default value for the derived class.</summary>
            <returns><see langword="true"/> if this instance is the default attribute for the class; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.Match(System.Object)">
            <summary>Returns a value indicating whether this instance equals a specified object.</summary>
            <param name="obj">An <see cref="T:System.Object"/> to compare with this instance of <see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute"/>.</param>
            <returns><see langword="true"/> if this instance equals <paramref name="obj"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.FileName">
            <summary>Gets the name of the configuration file to load when the marked assembly is in use.</summary>
            <remarks>
            <para>If <see cref="P:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.IsEmbedded"/> is <see langword="true"/>, this is the name of a resource file linked into the marked assembly. Otherwise, this is a file system path.</para>
            <para>Relative paths are from the code base location of the assembly to which this attribute is applied. This presents a problem for shared library assemblies which have been loaded into the GAC, because their actual code base location is controlled by Windows. <see cref="T:Hca.Common.Configuration.ConfigFactory"/> handles this situation using the functionality provided by <see cref="M:Hca.Common.Utility.SystemUtility.GetAssemblyCodeBasePath(System.Reflection.Assembly)"/>; thus, developers should set a code base registry key for any shared library deployed to the GAC.</para>
            <note>The value of this property is set by the class constructor.</note>
            </remarks>
        </member>
        <member name="P:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.IsEmbedded">
            <summary>Gets whether <see cref="P:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.FileName"/> refers to an embedded resource (if <see langword="true"/>), or (if <see langword="false"/>) an external file.</summary>
            <remarks>The value of this property is set by the class constructor.</remarks>
        </member>
        <member name="T:Hca.Common.Configuration.CommonConfig">
            <summary>Config used to hold Common settings that may be overridden by an application.</summary>
            <remarks>The instance Common uses is defined inside Common's embedded configuration. Applications may override these settings by assigning values to configuration tokens. See each property for the related token name.</remarks>
        </member>
        <member name="P:Hca.Common.Configuration.CommonConfig.ExcludeNamespacesPrefixedWith">
            <summary>
            Required. This is a comma delimited list of namespaces that should be
            excluded for evaluation. The default is <see cref="N:System"/>,<see cref="N:Microsoft"/>; 
            applications can override the default by setting the value of the 
            <c>@Hca.Common.Configuration.CommonConfig.ExcludeNamespacesPrefixedWith@</c> 
            configuration token.
            </summary>
            <remarks>This setting controls the behavior of <see cref="T:Hca.Common.BaseType.ObjectBase"/> and <see cref="T:Hca.Common.Resource.ResourceMessage"/>.</remarks>
        </member>
        <member name="P:Hca.Common.Configuration.CommonConfig.UseOptimisticLocking">
            <summary>
            Should optimistic locking be used? The default is <see langword="true"/>; 
            applications can override the default by setting the value of the 
            <c>@Hca.Common.Configuration.CommonConfig.UseOptimisticLocking@</c> 
            configuration token.
            </summary>
            <remarks>This setting controls <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>.</remarks>
        </member>
        <member name="T:Hca.Common.Configuration.ConfigFactory">
            <summary>Loads configuration object definitions from the configuration store and builds and caches the objects as they are requested.</summary>
            <remarks>
            <para>This class is implemented as a singleton - that is, there is never more than one instance of <see cref="T:Hca.Common.Configuration.ConfigFactory"/> in a given application domain. The static <see cref="P:Hca.Common.Configuration.ConfigFactory.Instance"/> property constructs and then accesses that instance.</para>
            <para>The <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/> and <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)"/> methods are used to retrieve objects defined in the configuration store. <see cref="M:Hca.Common.Configuration.ConfigFactory.AddIncludeConfig(System.String)"/>, <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveIncludeConfig(System.String)"/>, and <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveAllAddedIncludes"/> allow clients to dynamically manipulate what is included in the configuration store.</para>
            <para><see cref="T:Hca.Common.Configuration.ConfigFactory"/> watches the configuration store after loading and rebuilds its cache when it detects changes. The <see cref="E:Hca.Common.Configuration.ConfigFactory.Refreshed"/> event is raised when this rebuild is complete. A rebuild may be forced by a client through a call to <see cref="M:Hca.Common.Configuration.ConfigFactory.Refresh"/>.</para>
            <note>A five-second "queueing period" intervenes between when changes are detected and when the rebuild is initiated. This keeps <see cref="T:Hca.Common.Configuration.ConfigFactory"/> from thrashing unnecessarily in the case of additional near-simultaneous changes. The rebuild begins when no additional changes have been detected for a period of five seconds.</note>
            <para>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through of the functionality provided by <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</para>
            </remarks>
        </member>
        <member name="T:Hca.Common.IRefreshable">
            <summary>
            Interface that indicates that this class is refreshable. The semantics
            of what this means depends on the class.
            </summary>
            <remarks>
            Usually a refreshable class is a one that has a cache. On refresh, it
            will dump its cache.
            </remarks>
        </member>
        <member name="M:Hca.Common.IRefreshable.Refresh">
            <summary>
            This is the method to be implemented by consuming class.
            </summary>
        </member>
        <member name="E:Hca.Common.IRefreshable.Refreshed">
            <summary>
            The event that is raised when the time is refreshed.
            </summary>
        </member>
        <member name="F:Hca.Common.Configuration.ConfigFactory.PRIMARY_DOCUMENT_CONFIG_KEY">
            <summary>The configuration key used to override the default primary configuration file name.</summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.#ctor">
            <summary>Private constructor initializes the singleton instance.</summary>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if there is a problem loading the configuration store.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)">
            <overloads>Searches the configuration store for a single instance of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/>.</overloads>
            
            <summary>Searches the configuration store for a single instance of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the default (unspecified) context, throwing an exception if no match is found.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <returns>An instance of <paramref name="configType"/> as defined in the configuration store. The return value may be cast directly to the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request</para>
            <para>-- OR --</para>
            <para>if multiple objects match the request</para>
            <para>-- OR --</para>
            <para>if the matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls the object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type,System.String)">
            <summary>Searches the configuration store for a single instance of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the specified context, throwing an exception if no match is found.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches the default (unspecified) context.</param>
            <returns>An instance of <paramref name="configType"/> as defined in the configuration store. The return value may be cast directly to the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request</para>
            <para>-- OR --</para>
            <para>if multiple objects match the request</para>
            <para>-- OR --</para>
            <para>if the matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls the object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type,System.Boolean)">
            <summary>Searches the configuration store for a single instance of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the default (unspecified) context, optionally returning <see langword="null"/> if no objects match the request.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="isOptional">Whether to return <see langword="null"/> instead of throwing an exception if no objects match the request.</param>
            <returns>An instance of <paramref name="configType"/> as defined in the configuration store. The return value may be cast directly to the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request and <paramref name="isOptional"/> is <see langword="false"/></para>
            <para>-- OR --</para>
            <para>if multiple objects match the request</para>
            <para>-- OR --</para>
            <para>if the matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls the object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type,System.String,System.Boolean)">
            <summary>Searches the configuration store for a single instance of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the specified context, optionally returning <see langword="null"/> if no objects match the request.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches the default (unspecified) context.</param>
            <param name="isOptional">Whether to return <see langword="null"/> instead of throwing an exception if no objects match the request.</param>
            <returns>An instance of <paramref name="configType"/> as defined in the configuration store. The return value may be cast directly to the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request and <paramref name="isOptional"/> is <see langword="false"/></para>
            <para>-- OR --</para>
            <para>if multiple objects match the request</para>
            <para>-- OR --</para>
            <para>if the matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls the object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)">
            <overloads>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/>.</overloads>
            
            <summary>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the default (unspecified) context, throwing an exception if no match is found.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <returns>An array of <paramref name="configType"/> containing instances as defined in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request</para>
            <para>-- OR --</para>
            <para>if any matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls each object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type,System.String)">
            <summary>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the specified context, throwing an exception if no match is found.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches the default (unspecified) context.</param>
            <returns>An array of <paramref name="configType"/> containing instances as defined in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request</para>
            <para>-- OR --</para>
            <para>if any matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls each object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type,System.Boolean)">
            <summary>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the default (unspecified) context, optionally returning a zero-length array if no objects match the request.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="isOptional">Whether to return a zero-length arrayinstead of throwing an exception if no objects match the request.</param>
            <returns>An array of <paramref name="configType"/> containing instances as defined in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request and <paramref name="isOptional"/> is <see langword="false"/></para>
            <para>-- OR --</para>
            <para>if any matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls each object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type,System.String,System.Boolean)">
            <summary>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in the specified context, optionally returning a zero-length array if no objects match the request.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches the default (unspecified) context.</param>
            <param name="isOptional">Whether to return a zero-length arrayinstead of throwing an exception if no objects match the request.</param>
            <returns>An array of <paramref name="configType"/> containing instances as defined in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request and <paramref name="isOptional"/> is <see langword="false"/></para>
            <para>-- OR --</para>
            <para>if any matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls each object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type,System.Boolean,System.Boolean)">
            <summary>Searches the configuration store for instances of a given concrete <see cref="T:Hca.Common.Configuration.ConfigBase"/> <see cref="T:System.Type"/> in either the default (unspecified) context or any context, optionally returning a zero-length array if no objects match the request.</summary>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="isOptional">Whether to return a zero-length arrayinstead of throwing an exception if no objects match the request.</param>
            <param name="nullContextOnly">Whether (if <see langword="true"/>) to search only the default (unspecified) context, or (if <see langword="false"/> to search all contexts.</param>
            <returns>An array of <paramref name="configType"/> containing instances as defined in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="configType"/> is <see langword="null"/> or does not derive from <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">
            <para>Thrown if no objects match the request and <paramref name="isOptional"/> is <see langword="false"/></para>
            <para>-- OR --</para>
            <para>if any matching object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> fails</para>
            <para>-- OR --</para>
            <para>if some other error occurs while accessing the configuration store.</para>
            </exception>
            <exception cref="T:System.Security.SecurityException">Thrown if <paramref name="configType"/> is defined in a different assembly than the calling code (unless <paramref name="configType"/> is marked [<see cref="T:Hca.Common.Configuration.InsecureConfigAttribute">InsecureConfig</see>]).</exception>
            <remarks>
            <para>This method calls each object's <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> before returning.</para>
            <para>Objects defined in the configuration store are instantiated on a just-in-time basis. The first time a particular object is requested, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and validates it, and then caches a reference to it. Duplicate requests then return that same reference.</para>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for a complete walk-through example of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.Refresh">
            <summary>Forces a reload of the configuration store, flushing the cache.</summary>
            <remarks>
            <para>If this method fails for any reason, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> will continue to operate with the last-loaded configuration.</para>
            <para>Calling this method will also raise <see cref="E:Hca.Common.Configuration.ConfigFactory.Refreshed"/>.</para>
            </remarks>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if there is a problem loading the configuration store.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.AddIncludeConfig(System.String)">
            <summary>
            Enables a specified conditional include.
            </summary>
            <param name="includeId">The identity of the conditional include to enable.</param>
            <remarks>
            <para>Disable the include using <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveIncludeConfig(System.String)"/>; disable all includes using <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveAllAddedIncludes"/>. Conditional include settings are applied at the next <see cref="M:Hca.Common.Configuration.ConfigFactory.Refresh"/>.</para>
            <para>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for details on conditional includes.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.RemoveIncludeConfig(System.String)">
            <summary>
            Disables a specified conditional include.
            </summary>
            <param name="includeId">The identity of the conditional include to disable.</param>
            <remarks>
            <para>Enable the include using <see cref="M:Hca.Common.Configuration.ConfigFactory.AddIncludeConfig(System.String)"/>; disable all includes using <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveAllAddedIncludes"/>. Conditional include settings are applied at the next <see cref="M:Hca.Common.Configuration.ConfigFactory.Refresh"/>.</para>
            <para>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for details on conditional includes.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.RemoveAllAddedIncludes">
            <summary>
            Disables all conditional includes.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether any includes had been enabled.</returns>
            <remarks>
            <para>Enable specified includes using <see cref="M:Hca.Common.Configuration.ConfigFactory.AddIncludeConfig(System.String)"/>; disable one specified include using <see cref="M:Hca.Common.Configuration.ConfigFactory.RemoveIncludeConfig(System.String)"/>. Conditional include settings are applied at the next <see cref="M:Hca.Common.Configuration.ConfigFactory.Refresh"/>.</para>
            <para>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for details on conditional includes.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfig_Impl(System.Reflection.Assembly,System.Type,System.String,System.Boolean)">
            <summary>Searches the configuration store for a single instance of a given <see cref="T:System.Type"/> in a specified <paramref name="context"/>, optionally throwing an exception if no object matching the request can be found.</summary>
            <param name="caller">The assembly requesting the configuration object.</param>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches in the <see langword="null"/> context.</param>
            <param name="isOptional">Whether to return <see langword="null"/> instead of throwing a 'not found' exception.</param>
            <returns>An instance of the <paramref name="configType"/> populated as defined in the configuration store, or <see langword="null"/> if <paramref name="isOptional"/> is <see langword="true"/> and a definition matching this request cannot be found.</returns>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown when an invalid configuration setting or request is encountered.</exception>
            <remarks>
            <para>This method retrieves an object of <paramref name="configType"/> from the specified <paramref name="context"/> in the configuration store. Before it is returned, the object is asked to validate its state (calling <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>).</para>
            <para>If no definition matching this request can be found, this method's behavior is determined by the value of <paramref name="isOptional"/>: if <see langword="true"/>, <see langword="null"/> is returned; if <see langword="false"/>, a <see cref="T:System.Configuration.ConfigurationException"/> is thrown.</para>
            <para>If more than one definition matching this request is found, a <see cref="T:System.Configuration.ConfigurationException"/> is thrown.</para>
            <para>Configuration object definitions are instantiated on a just-in-time basis. The first time a particular request is made, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and initializes the instance per the definition, and then caches it before returning. Future requests then return the instance that was cached at the first request.</para>
            </remarks>
            <seealso cref="T:Hca.Common.Configuration.ConfigBase">ConfigBase Class</seealso>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.GetConfigs_Impl(System.Reflection.Assembly,System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>Searches the configuration store for all instances of a given <see cref="T:System.Type"/> in a specified <paramref name="context"/>, optionally throwing an exception if no objects matching the request can be found.</summary>
            <param name="caller">The assembly requesting the configuration object(s).</param>
            <param name="configType">The <see cref="T:System.Type"/> to find (must inherit from <see cref="T:Hca.Common.Configuration.ConfigBase"/>).</param>
            <param name="context">The context in which to search. If <see langword="null"/> or <see cref="F:System.String.Empty"/>, the method searches in the <see langword="null"/> context.</param>
            <param name="isOptional">Whether to return an empty array instead of throwing a 'not found' exception.</param>
            <param name="nullContextOnly">Whether to match only the <see langword="null"/> context.</param>
            <returns>An array of <paramref name="configType"/> containing instances populated as defined in the configuration store, or an empty array if <paramref name="isOptional"/> is <see langword="true"/> and a definition matching this request cannot be found.</returns>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown when an invalid configuration setting or request is encountered.</exception>
            <remarks>
            <para>This method retrieves an array of objects of <paramref name="configType"/> from the specified <paramref name="context"/> in the configuration store. The return value may be cast directly to an array of the type specified by <paramref name="configType"/>.</para>
            <para>Before the array is returned, each object is asked to validate its state (calling <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>).</para>
            <para>If no definitions matching this request can be found, this method's behavior is determined by the value of <paramref name="isOptional"/>: if <see langword="true"/>, an empty array is returned; if <see langword="false"/>, a <see cref="T:System.Configuration.ConfigurationException"/> is thrown.</para>
            <para>Configuration object definitions are instantiated on a just-in-time basis. The first time a particular request is made, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> creates and initializes the instances per their definitions, and then caches them before returning. Future requests then return the instances that were cached at the first request.</para>
            </remarks>
            <seealso cref="T:Hca.Common.Configuration.ConfigBase">ConfigBase Class</seealso>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.CheckCallerRights(System.Reflection.Assembly,System.Type)">
            <summary>Ensures that a given assembly has the right to retrieve instances of a particular configuration type.</summary>
            <param name="caller">The requesting assembly.</param>
            <param name="configType">The requested configuration type.</param>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.Refresh_Impl">
            <summary>
            Loads and validates the xml and clears the cache of config objects
            </summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.OnRefreshed">
            <summary>
            Fires the refreshed event
            </summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.LoadConfiguration">
            <summary>
            Loads and validates the xml and clears the cache of config objects
            </summary>
        </member>
        <member name="M:Hca.Common.Configuration.ConfigFactory.HandleStoreChanged(System.Object,System.EventArgs)">
            <summary>Fired when a file watcher detects a file has changed.</summary>
            <param name="sender">object firing the event</param>
            <param name="e">event args</param>
        </member>
        <member name="P:Hca.Common.Configuration.ConfigFactory.Instance">
            <summary>Gets the singleton instance of <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</summary>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if there is a problem loading the configuration store.</exception>
        </member>
        <member name="E:Hca.Common.Configuration.ConfigFactory.Refreshed">
            <summary>Raised when the configuration store is reloaded.</summary>
            <remarks>
            Most applications should simply call <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/> or <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)"/> whenever they perform logic that is subject to 
            configuration. This is inexpensive through <see cref="T:Hca.Common.Configuration.ConfigFactory"/>'s 
            caching functionality, and eliminates the need to monitor for configuration 
            changes. However, applications that maintain complex state based on 
            configuration should consider resetting whenever this event is raised.
            </remarks>
        </member>
        <member name="T:Hca.Common.Configuration.ConfiguredNetworkCredential">
            <summary>Helper class for configuring impersonation.</summary>
            <remarks>Configuration classes that represent impersonation settings should have a <see cref="T:System.Net.NetworkCredential"/>-typed property (c.f., <see cref="T:Hca.Common.Service.ServiceConfig"/>). The methods on this class provide for consistent and convenient validation and consumption of such a configured property.</remarks>
        </member>
        <member name="M:Hca.Common.Configuration.ConfiguredNetworkCredential.#ctor">
            <summary>Private constructor prevents instantiation of static-only class.</summary>		
        </member>
        <member name="M:Hca.Common.Configuration.ConfiguredNetworkCredential.Validate(System.Net.NetworkCredential)">
            <summary>Validates a configured <see cref="T:System.Net.NetworkCredential"/>.</summary>
            <param name="credential">The credential to validate.</param>
            <remarks>This method succeeds if the input is <see langword="null"/>.</remarks>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> contains an invalid character, or if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/> while the other (or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Password"/>) is not.</exception>
        </member>
        <member name="M:Hca.Common.Configuration.ConfiguredNetworkCredential.Clean(System.Net.NetworkCredential)">
            <summary>Cleans a configured <see cref="T:System.Net.NetworkCredential"/>.</summary>
            <param name="credential">The credential to clean.</param>
            <returns>The <see cref="T:System.Net.NetworkCredential"/> specified by this object's properties, or <see langword="null"/> if <paramref name="credential"/> is <see langword="null"/> or all properties are <see langword="null"/> or <see cref="F:System.String.Empty"/>.</returns>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> contains an invalid character, or if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/> while the other (or <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.Password"/>) is not.</exception>
        </member>
        <member name="T:Hca.Common.Configuration.InsecureConfigAttribute">
            <summary>Indicates that any assembly may use <see cref="T:Hca.Common.Configuration.ConfigFactory"/> to retrieve an instance of this type from the configuration store.</summary>
            <remarks>
            By default, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> will return a configuration object only 
            if the calling assembly also defined the object's class. If a class derived from 
            <see cref="T:Hca.Common.Configuration.ConfigBase"/> is intended for direct consumption by other 
            assemblies, it must be marked with this attribute.
            </remarks>
        </member>
        <member name="T:Hca.Common.Configuration.MiscellaneousConfig">
            <summary>Config with one <see cref="T:System.Collections.Hashtable"/> property used to hold miscellaneous settings that may be used by libraries and applications.</summary>
            <remarks>This class is for use by the applications and libraries that do not require structured configuration types. Similar to <see cref="P:System.Configuration.ConfigurationSettings.AppSettings"/>, it allows unlimited declaration of arbitrary name-value pairs (in the <see cref="P:Hca.Common.Configuration.MiscellaneousConfig.Settings"/> property), and static-method value retrieval (using the <see cref="M:Hca.Common.Configuration.MiscellaneousConfig.GetSetting(System.String,System.String)"/> method), but with this framework's added context, file-include, encryption, and rich-type functionality.</remarks>
            <example>
            <para>The follwing example illustrates declaration and retrieval of a <see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> setting.</para>
            <code><![CDATA[<config type="Hca.Common.Configuration.MiscellaneousConfig" context="misc1">
            <propertyDictionary name="Settings">
            	<item key="item1" value="value1" />
            </propertyDictionary>
            </config>]]></code>
            <code><![CDATA[string item1 = (string) MiscellaneousConfig.GetSetting("misc1", "item1");]]></code>
            </example>
        </member>
        <member name="M:Hca.Common.Configuration.MiscellaneousConfig.GetSetting(System.String,System.String)">
            <summary>Retreives the specified <see cref="P:Hca.Common.Configuration.MiscellaneousConfig.Settings"/> value from the specified <see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> instance.</summary>
            <param name="configContext">The configuration context of the <see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> instance to find.</param>
            <param name="settingsKey">The key of the <see cref="P:Hca.Common.Configuration.MiscellaneousConfig.Settings"/> value to find.</param>
            <returns>The value assigned to the specified key in the specified context, or <see langword="null"/> if there is no <see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> in the specified <paramref name="configContext"/> or if the <see cref="T:Hca.Common.Configuration.MiscellaneousConfig"/> in the specified <paramref name="configContext"/> has no value assigned to the key specified by <paramref name="settingsKey"/>.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.MiscellaneousConfig.Settings">
            <summary>
            Used for passing settings that may be used by libraries and applications.
            </summary>
        </member>
        <member name="T:Hca.Common.Configuration.NamespaceDoc">
            <summary>
            <para>The <see cref="N:Hca.Common.Configuration"/> namespace contains classes implementing a rich framework for configuring applications declaratively with XML.</para>
            <h2 class="dtH2">Contents</h2>
            <para>
            This document introduces the concepts that comprise the configuration framework. It contains the following sections:
            <list type="definition">
            <item>
            	<term><see href="#files">Configuration Files</see></term>
            	<description>
            		<para>Describes the XML files that make up the configuration store - how they are formatted, where they can reside, how they are located by the framework, and how changes are handled after loading.</para>
            		<para><see href="#files.xml">XML Syntax</see>, <see href="#files.types">Types of Files</see>, <see href="#files.locating">Locating Files</see>, <see href="#files.watching">Watching Changes</see>, <see href="#files.encryption">Encrypting Sensitive Values</see>, <see href="#files.readonly">Read-Only Configurations</see></para>
            	</description>
            </item>
            <item>
            	<term><see href="#objects">Object Definitions</see></term>
            	<description>
            		<para>Describes how individual configuration objects are defined in configuration files - how they are formatted, how they reference their defining class, and how they are organized.</para>
            		<para><see href="#objects.xml">XML Syntax</see>, <see href="#objects.contexts">Organizing Configuration Objects into Contexts</see></para>
            	</description>
            </item>
            <item>
            	<term><see href="#tokens">Token Definitions</see></term>
            	<description>
            		<para>Describes how string tokens are defined and referenced in configuration files.</para>
            		<para><see href="#tokens.xml">XML Syntax</see></para>
            	</description>
            </item>
            <item>
            	<term><see href="#examples">Examples</see></term>
            	<description>
            		<para>Illustrates a complete walk-through of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</para>
            		<para><see href="#example.class"><see cref="T:Hca.Common.Configuration.ConfigBase"/> Subclass</see>, <see href="#example.files">XML Configuration Files</see>, <see href="#example.getting">Calling GetConfig</see>, <see href="#example.validation">Custom Validation</see></para>
            	</description>
            </item>
            <item>
            	<term><see href="#guidelines">Development Guidelines</see></term>
            	<description>
            		<para>Describes the basic guidelines for designing and implementing configuration classes and files.</para>
            		<para><see href="#guidelines.tenets">Tenets</see> <see href="#guidelines.bestPractices">Best Practices</see> </para>
            	</description>
            </item>
            <item>
            	<term><see href="#api">Application Programming Interface</see></term>
            	<description>
            		<para>Summarizes the public types used by clients to interact with the configuration framework.</para>
            		<para><see href="#api.classes">Classes</see></para>
            	</description>
            </item>
            </list>
            </para>
            <para>
            Additional information relevant to usage of the configuration framework but not covered here may be found in the following locations:
            <list type="bullet">
            <item><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfNETFrameworkConfigurationFileSchema.htm">Microsoft .NET 1.1 Configuration File Schema</see></item>
            </list>
            </para>
            
            <a name="files"></a>
            <h2 class="dtH2">Configuration Files</h2>
            <para>The declarative configuration store that is consumed and exposed by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> consists of one or more XML files. This section describes those files - how they are formatted, where they can reside, how they are located by the framework, and how changes are handled after loading.</para>
            
            <a name="files.xml"></a>
            <h3 class="dtH3">XML Syntax</h3>
            <para>
            All configuration files contain a single <c>hcaConfigFactory</c> XML element. The following example illustrates this element along with the elements it may contain:
            <hcaExample desc="Basic configuration file structure"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <cf:hcaConfigFactory
            		xmlns:cf="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" 
            		xmlns:xsi="]]><a target="_blank" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a><![CDATA[" 
            		xsi:schemaLocation="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" >
            	<]]><see href="#files.locating.includes">include</see><![CDATA[ ... />
            	<]]><see href="#tokens.xml">tokenDefault</see><![CDATA[ ... />
            	<]]><see href="#tokens.xml">token</see><![CDATA[ ... />
            	<]]><see href="#objects.xml">config</see><![CDATA[ ... />
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            </para>
            
            <a name="files.types"></a>
            <h3 class="dtH3">Types of Files</h3>
            <para>The <c>hcaConfigFactory</c> element may be contained in three types of files. By convention, all configuration file names should have the <c>.config</c> extention. (This practice has the added benefit of making configuration files inaccessible to web clients in ASP.NET.)</para>
            <h4 class="dtH4">Basic File in the File System</h4>
            <para>The most basic form of configuration file has the <c>hcaConfigFactory</c> element as the root of an XML text file on disk. The <c>?xml</c> processing directive is optional.</para>
            <h4 class="dtH4">File Resource Embedded in a .NET Assembly</h4>
            <para>The configuration framework can also access an XML file with the <c>hcaConfigFactory</c> root element that has been linked into a .NET assembly as file resource.</para>
            <h4 class="dtH4">Section Inside the .NET Configuration File</h4>
            <para>
            Finally, the configuration framework also recognizes the <c>hcaConfigFactory</c> element inside .NET's configuration file ([App].config/web.config) as long as it is declared in the <c>configSections</c> element. This is illustrated below:
            <hcaNote>The <c>cf:</c> prefix is mandatory.</hcaNote>
            <hcaExample desc="Declaring a section inside .NET's configuration file"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfconfiguration.htm">configuration</see><![CDATA[>
            	<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfconfigsectionselementcontainertag.htm">configSections</see><![CDATA[>
            		<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfsectionelement.htm">section</see><![CDATA[ name="cf:hcaConfigFactory"
            				type="Hca.Common.Configuration.SectionHandler, Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=FD260FD4A2A56402" />
            	</configSections>
            	<]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ ... />
            </configuration>]]>
            </code></hcaExample>
            </para>
            
            <a name="files.locating"></a>
            <h3 class="dtH3">Locating Files</h3>
            The configuration framework identifies files that should be included in its store in three ways.
            <h4 class="dtH4">The "Primary" Configuration File</h4>
            <para>By default, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> looks for an <c>hcaConfigFactory</c> element inside .NET's configuration file. This is considered the 'primary' configuration file. However, consuming applications may override this behavior and point <see cref="T:Hca.Common.Configuration.ConfigFactory"/> to an alternative file on disk. This is illustrated in the following example:</para>
            <hcaExample desc="Redirecting 'primary' configuration"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfconfiguration.htm">configuration</see><![CDATA[>
            	<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfappsettingselement.htm">appSettings</see><![CDATA[>
            		<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfaddelementfornamevaluesectionhandlerdictionarysectionhandler.htm">add</see><![CDATA[
            				key="Hca.Common.ConfigFactory.ConfigFile"
            				value="MyPrimary.config" />
            	</appSettings>
            </configuration>]]>
            </code></hcaExample>
            <a name="files.locating.bootstrap"></a>
            <h4 class="dtH4">Assembly "Bootstrap" Configuration Files</h4>
            <para>
            Individual assemblies can inform <see cref="T:Hca.Common.Configuration.ConfigFactory"/> of configuration needed for 'bootstraping' by applying the assembly-level [<see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute">AssemblyConfigurationFile</see>] attribute. These files are loaded into the configuration store independent of the 'primary' configuration. This is illustrated in the following code:
            <hcaNote>Please see <see cref="M:Hca.Common.Configuration.AssemblyConfigurationFileAttribute.#ctor(System.String,System.Boolean)"/> for details on constructor arguments.</hcaNote>
            <hcaExample desc="'Bootstrap' configuration attribute in AssemblyInfo.cs"><code>
            <![CDATA[using ]]><see cref="N:Hca.Common.Configuration">Hca.Common.Configuration</see><![CDATA[;
            
            // A file embedded inside this assembly.
            [assembly:]]><see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute">AssemblyConfigurationFile</see><![CDATA[("Hca.Common.EmbedFile.Common.config")]
            
            // A file path relative to this assembly's code base.
            [assembly:]]><see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute">AssemblyConfigurationFile</see><![CDATA[("ExternalFile.config", ]]><see langword="false"/><![CDATA[)]]]>
            </code></hcaExample>
            </para>
            <a name="files.locating.includes"></a>
            <h4 class="dtH4">"Include" References</h4>
            <para>Finally, any configuration file may direct <see cref="T:Hca.Common.Configuration.ConfigFactory"/> to 'include' other configuration 
            files located either on disk or embedded in an assembly. Typically, includes will refer to physical files deployed
            with the application or assembly and not embedded within an assembly since the "bootstrap" mechanism describe above
            is the preferred means for an assembly to load its embedded defintion. However, there may be cases where this is 
            needed or preferred and hence the example that follow shows how this would be done. The XML syntax for these 
            references is illustrated below:
            <hcaNote>Relative paths in 'include' references are relative to the file containing the reference, unless that file is embedded in an assembly - in that case, they are relative to the application domain's <see cref="P:System.AppDomain.BaseDirectory"/>.</hcaNote>
            <a name="files.locating.includes.xml"></a>
            <hcaExample desc="XML syntax for &quot;include&quot; references to other configuration files"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ ... >
            	<!-- A file path relative to the application. -->
            	<include filename="Environmental.config" />
            	
            	<!-- A file resource linked into an assembly. -->
            	<include filename="Hca.Application.EmbedFile.Embeddedconfig"
            			assembly="Hca.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0123456789ABCDEF" />
            	
            	<!-- A conditional reference. -->
            	<include filename="..\Conditional.config" 
            			includeid="conditional" />
            	<]]><see href="#tokens.xml">tokenDefault</see><![CDATA[ ... />
            	<]]><see href="#tokens.xml">token</see><![CDATA[ ... />
            	<]]><see href="#objects.xml">config</see><![CDATA[ ... />
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            </para>
            <para>As illustrated, includes may be designated as <em>conditional</em> by declaring an <c>includeid</c> attribute. Any reference with an <c>includeid</c> will by default be ignored by <see cref="T:Hca.Common.Configuration.ConfigFactory"/>. Use <see cref="M:Hca.Common.Configuration.ConfigFactory.AddIncludeConfig(System.String)"/> to enable a conditional <c>include</c>.</para>
            
            <a name="files.watching"></a>
            <h3 class="dtH3">Watching Changes</h3>
            <para>A key advantage of this configuration framework is that configuration changes may be applied to the application while it is still running. Whenever a configuration file loaded from the file system is modified (or deleted) <see cref="T:Hca.Common.Configuration.ConfigFactory"/> will clear its cache and reload the store, starting with the 'bootstrap' and 'primary' configuration files and again tracing through all 'include' references they contain. When this completes, clients are notified by the <see cref="E:Hca.Common.Configuration.ConfigFactory.Refreshed"/> event, and changes are immediately reflected in subsequent calls to <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/> and <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)"/>.</para>
            <para>
            However, it is important to note that only files loaded directly from the file system are watched for changes:
            <list type="bullet">
            <item>File resources linked into an assembly are not watched. Embedded resources cannot change unless the assembly changes, and assembly changes cannot be applied without unloading the application domain.</item>
            <item>
            	The .NET configuration file is not watched. .NET loads this file only once during the lifetime of the application domain.
            	<note>This is a moot issue in ASP.NET, because the whole application is recycled automatically whenever <c>web.config</c> is modified.</note>
            </item>
            </list>
            </para>
            
            <a name="files.encryption"></a>
            <h3 class="dtH3">Encrypting Sensitive Values</h3>
            <para>The configuration framework detects and decrypts basic configuration files that have been encrypted. The encryption tool used at deployment time finds all <c>.config</c> files with <c>cf:hcaConfigFactory</c> as the root element, and encrypts each one, changing the file name extension to <c>.encrypted.config</c>. In turn, <see cref="T:Hca.Common.Configuration.ConfigFactory"/> always checks first for a file with the <c>.encrypted.config</c> whenever it is directed to a <c>.config</c>.</para>
            <para>Hence, the only action required of developers to protect sensitive configuration is to make sure all sensitive values are contained in basic file system configuration files. (Encryption is not supported for files linked into assemblies or for the section inside .NET's configuration file.)</para>
            
            <a name="files.readonly"></a>
            <h3 class="dtH3">Read-Only Configurations</h3>
            <para>The Configuration Framework allows for a configuration element to be marked as <i>read-only</i>. This 
            indicates to the framework that items in the section are not meant to be changed.</para>
            <hcaExample desc="Marking a Config as Read Only">
            <code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <cf:hcaConfigFactory...>
            	<config type="Hca.Library.LibraryConfig, Hca.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0123456789ABCDEF"
            			context="shortTimeout" readonly="true" >
            		<property name="Timeout" value="500" />
            	</config>
            	<config ... />
            </cf:hcaConfigFactory>]]>
            </code>
            </hcaExample>
            
            <para>However, simply marking the config section as read-only does not guarantee the items in the section
            are protected from being changed. In the configuration class that maps to the configuration file, the setter 
            property needs to check to see if the item is marked as read-only before writing to it. The following 
            example shows how this is done.</para>
            
            <hcaExample desc="Checking for Read-Only"><code>
            <![CDATA[using System;
            using System.Reflection;
            
            namespace Hca.Library
            {
            	[Serializable]
            	public class LibraryConfig : ConfigBase
            	{
            		[Required] 
            		private int timeout;
            
            		public int TimeOut
            		{
            			get { return timeout; }
            			set
            			{
            				CheckWritable(MethodInfo.GetCurrentMethod());
            				timeout = value;
            			}
            		}
            	}
            }]]>
            </code></hcaExample>
            
            <a name="objects"></a>
            <h2 class="dtH2">Object Definitions</h2>
            <para>Configuration objects are instances of classes derived from <see cref="T:Hca.Common.Configuration.ConfigBase"/>, built by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> based on declarative object defintions in configuration files. This section describes how these definitions are formatted and how they are organized.</para>
            
            <a name="objects.xml"></a>
            <h3 class="dtH3">XML Syntax</h3>
            <para>
            Each object is defined by a <c>config</c> XML element inside <c>hcaConfigFactory</c> in a configuration file. These definitions are loaded by <see cref="T:Hca.Common.Configuration.ConfigFactory"/> and parsed by <see cref="T:Hca.Common.Builder.ObjectBuilder"/>. The following example illustrates defining configuration objects in a configuration file:
            <hcaNote>The configuration schema's <c>config</c> element is derived from <see cref="T:Hca.Common.Builder.ObjectBuilder"/>'s <c>object</c> element. Please see <see cref="T:Hca.Common.Builder.ObjectBuilder"/> for details on the XML schema it expects.</hcaNote>
            <hcaExample desc="XML syntax for defining configuration objects"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ ... >
            	<]]><see href="#files.locating.includes">include</see><![CDATA[ ... />
            	<]]><see href="#tokens.xml">tokenDefault</see><![CDATA[ ... />
            	<]]><see href="#tokens.xml">token</see><![CDATA[ ... />
            	<config type="Hca.Library.LibraryConfig, Hca.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0123456789ABCDEF"
            			context="longTimeout" >
            		<property name="Timeout" value="15000" />
            		<property name="TimeoutMessage">The patient clock says, "you're out of time!"</property>
            	</config>
            	<config type="Hca.Library.LibraryConfig, Hca.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0123456789ABCDEF"
            			context="shortTimeout" readonly="true" >
            		<property name="Timeout" value="500" />
            		<property name="TimeoutMessage">The impatient clock says, "you're out of time!"</property>
            	</config>
            	<config ... />
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            </para>
            
            <a name="objects.contexts"></a>
            <h3 class="dtH3">Organizing Configuration Objects into Contexts</h3>
            <para>Some <see cref="T:Hca.Common.Configuration.ConfigBase"/> subclasses are intended for the equivalent of singleton usage - only one instance is ever used in any given application domain. <see cref="T:Hca.Common.Configuration.ConfigFactory"/> allows such objects to be retrieved simply by specifying the <see cref="T:System.Type"/> in a call to <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/>. However, some <see cref="T:Hca.Common.Configuration.ConfigBase"/> subclasses may have many instances within a single application. Often, all of those instances are still consumed by a single object, which will retrieve them using <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)"/>.</para>
            <para>Many configuration classes, though, will have multiple instances consumed by different objects. In that case, each consuming object must have a way of directing <see cref="T:Hca.Common.Configuration.ConfigFactory"/> to the particular instance or instances that were intended for it (as disctinct from those intended for consumption by other objects). For situations such as this, the configuration framework provides a concept called 'context'.</para>
            <para>
            A context is a handle used by a client to request a subset of instances of a particular <see cref="T:Hca.Common.Configuration.ConfigBase"/> subclass. Every object defintion in the configuration store is associated with one or more contexts. The context(s) with which a <c>config</c> element is to be associated is specified by its <c>context</c> attribute, which can contain one or more context names. Multiple context names are delimited by commas (which will be stripped of leading and trailiing spaces). If the <c>context</c> attribute is omitted, then the 'default' context is assumed.
            <hcaNote>The default context may be explicitly specified by an empty string attribute value, or in the case of a list, by an extra comma. (I.e., <c>context="a, , b"</c> associates a configuration object with context <c>a</c>, context <c>b</c>, and the default context.</hcaNote>
            </para>
            <para>
            For client consumption of contextual configuration, <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/> and <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfigs(System.Type)"/> both accept a <c>context</c> parameter which limits the scope of the search to those instances of the specified class that are associated with the specified context name.
            <hcaNote>If this parameter is not specified, then the search is limited to the default context.</hcaNote>
            </para>
            
            <a name="tokens"></a>
            <h2 class="dtH2">Token Definitions</h2>
            <para>Typically, any value that should be part of a configuration object is specified literally in the configuration object definition. However, in some cases (such as a complex configuration with only one or two values that are likely to change, or multiple configuration objects repeating the same value), extracting a value to another seperate location in the configuration store is helpful. The configuration framework supports tokenization of values, allowing a named, string-valued token to be defined once, and then referenced from any number of object defintions (without any special handling by the affected objects' classes). This section describes how string tokens are defined and referenced in configuration files.</para>
            
            <a name="tokens.xml"></a>
            <h3 class="dtH3">XML Syntax</h3>
            <para>A token is defined using a <c>token</c> element. This element specifies the token <c>name</c> and <c>value</c> as attributes. Configuration object definitions can then reference that token in any value string by surrounding the token name with a pair of <c>@</c> characters. A token may also be referenced by the <c>value</c> attribute of another token definition using the same syntax.</para>
            <para>Tokens may be defined in one file and consumed in another, as long as both files are included in the configuration store. Apparent token references which do not match a defined token name will be passed through by the framework as literal strings containing two <c>@</c> characters.</para>
            <hcaNote type="tip">Common practice is to tokenize all environment-specific values throughout the configuration store, and then define them all in a single included configuration file named <c>Environmental.config</c>.</hcaNote>
            <para>
            It is an error to specify two <c>token</c> elements with the same <c>name</c> anywhere in the configuration store. However, the framework does supports the concept of a default value for a token which may be overridden. The default value is specified by a <c>tokenDefault</c> element, which contains a <c>name</c> and <c>value</c>. That value will be used unless a <c>token</c> element also specifies the same <c>name</c>, in which case the <c>value</c> of the <c>token</c> element will take precedence.
            <hcaNote>Token defaults are primarily intended for scenarios where default configuration is embedded in a library, but may be overridden in the configuration store of a consuming application.</hcaNote>
            </para>
            <para>
            The following example illustrates the syntax for defining and referencing tokens:
            <hcaNote type="tip">The configuration object's <c>Letter</c> property will be configured with the string "<c>The letter is: b!</c>".</hcaNote>
            <hcaExample desc="XML syntax for defining and referencing tokens"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ ... >
            	<]]><see href="#files.locating.includes">include</see><![CDATA[ ... />
            	<tokenDefault name="myToken1" value="a" />
            	<token name="myToken1" value="b" />
            	<token name="myToken2" value="@myToken1@" />
            	<]]><see href="#objects.xml">config</see><![CDATA[ ... >
            		<property name="Letter" value="The letter is: @myToken2@!" />
            	</config>
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            </para>
            
            <a name="examples"></a>
            <h2 class="dtH2">Examples</h2>
            <para>This section illustrates a complete walk-through of creating a configuration class, defining an instance in XML, and retrieving that instance from <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</para>
            <hcaNote>The <see cref="T:Hca.Common.Configuration.CommonConfig"/> class is a <see cref="T:Hca.Common.Configuration.ConfigBase"/> subclass used by Common to allow applications to override the behavior of certain low-level functions.</hcaNote>
            
            <a name="example.class"></a>
            <h3 class="dtH3"><see cref="T:Hca.Common.Configuration.ConfigBase"/> Subclass</h3>
            <para>The class is defined in <c>CommonConfig.cs</c> and compiled into <c>Hca_DevBlocks_Common</c>.</para>
            <hcaExample desc="CommonConfig.cs"><code>
            <![CDATA[using System;
            using System.Reflection;
            
            namespace Hca.Common.Configuration
            {
            	[Serializable]
            	public class CommonConfig : ConfigBase
            	{
            		[Required] private string excludeNameSpacesPrefixedWith;
            		private bool useOptimisticLocking;
            
            		public string ExcludeNamespacesPrefixedWith
            		{
            			get { return excludeNameSpacesPrefixedWith; }
            			set
            			{
            				CheckWritable(MethodInfo.GetCurrentMethod());
            				excludeNameSpacesPrefixedWith = SystemUtility.NullOrTrimString(value);
            			}
            		}
            
            		public bool UseOptimisticLocking
            		{
            			get { return useOptimisticLocking; }
            			set
            			{
            				CheckWritable(MethodInfo.GetCurrentMethod());
            				useOptimisticLocking = value;
            			}
            		}
            	}
            }]]>
            </code></hcaExample>
            
            <a name="example.files"></a>
            <h3 class="dtH3">XML Configuration Files</h3>
            <para>The XML object definition is contained in <c>CommonConfig.cs</c>, linked into <c>Hca_DevBlocks_Common</c> with an assembly-level attribute in <c>AssemblyInfo.cs</c>.</para>
            <para>Some application's <c>Web.config</c> file contains the 'primary' configuration, and 'include's <c>Environmental.config</c>, which contains token values for configuration specific to each deployment environment.</para>
            <hcaExample desc="AssemblyInfo.cs"><code>
            <![CDATA[using Hca.Common.Configuration;
            
            //	...
            [assembly:AssemblyConfigurationFile("Hca.Common.EmbedFile.Common.config")]]]>
            </code></hcaExample>
            <hcaExample desc="Hca.Common.EmbedFile.Common.config (linked into Hca_DevBlocks_Common)"><code>
            <![CDATA[<?xml version="1.0" encoding="UTF-8"?>
            <]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ 
            		xmlns:cf="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" 
            		xmlns:xsi="]]><a target="_blank" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a><![CDATA[" 
            		xsi:schemaLocation="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" >
            	
            	<]]><see href="#tokens.xml">tokenDefault</see><![CDATA[ name="Hca.Common.Configuration.CommonConfig.ExcludeNamespacesPrefixedWith" value="System" />
            	<]]><see href="#tokens.xml">tokenDefault</see><![CDATA[ name="Hca.Common.Configuration.CommonConfig.UseOptimisticLocking" value="true" />
            	
            	<]]><see href="#objects.xml">config</see><![CDATA[ type="Hca.Common.Configuration.CommonConfig, Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=FD260FD4A2A56402" readOnly="true">
            		<property name="ExcludeNamespacesPrefixedWith"
            				value="@Hca.Common.Configuration.CommonConfig.ExcludeNamespacesPrefixedWith@"/>
            		<property name="UseOptimisticLocking"
            				value="@Hca.Common.Configuration.CommonConfig.UseOptimisticLocking@"/>
            	</config>
            
            	<!-- ... -->
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            <hcaExample desc="Web.config"><code>
            <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
            <]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfconfiguration.htm">configuration</see><![CDATA[>
            
            	<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfconfigsectionselementcontainertag.htm">configSections</see><![CDATA[>
            		<]]><see href="ms-help://MS.VSCC.2003/MS.MSDNQTR.2005OCT.1033/cpgenref/html/gngrfsectionelement.htm">section</see><![CDATA[ name="cf:hcaConfigFactory"
            				type="Hca.Common.Configuration.SectionHandler, Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=FD260FD4A2A56402" />
            	</configSections>
            
            	<]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ 
            			xmlns:cf="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" 
            			xmlns:xsi="]]><a target="_blank" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a><![CDATA[" 
            			xsi:schemaLocation="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" >
             		
            		<]]><see href="#files.locating.includes">include</see><![CDATA[ filename="Environmental.config" />
            	
            	</cf:hcaConfigFactory>
            
            	<system.web ... />
            
            </configuration>]]>
            </code></hcaExample>
            <hcaExample desc="Environmental.config"><code>
            <![CDATA[<?xml version="1.0" encoding="UTF-8"?>
            <]]><see href="#files.xml">cf:hcaConfigFactory</see><![CDATA[ 
            		xmlns:cf="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" 
            		xmlns:xsi="]]><a target="_blank" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a><![CDATA[" 
            		xsi:schemaLocation="]]><a target="_blank" href="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd</a><![CDATA[" >
            	
            	<!-- Override tokenDefault from Common's embedded configuration. -->
            	<]]><see href="#tokens.xml">token</see><![CDATA[ name="Hca.Common.Configuration.CommonConfig.UseOptimisticLocking" value="false" />
            
            </cf:hcaConfigFactory>]]>
            </code></hcaExample>
            
            <a name="example.getting"></a>
            <h3 class="dtH3">Calling <see cref="M:Hca.Common.Configuration.ConfigFactory.GetConfig(System.Type)"/></h3>
            <para>The configuration object is consumed by <c>ValueObjectBase.cs</c>, also compiled into <c>Hca_DevBlocks_Common</c>.</para>
            <hcaExample desc="Snippet from ValueObjectBase.cs"><code>
            <![CDATA[using System;
            using Hca.Common.Configuration;
            
            namespace Hca.Common.BaseType
            {
            	public abstract class ValueObjectBase : ModelBase
            	{
            		private static bool isOptimisticLockingOn = false;
            
            		static ValueObjectBase()
            		{
            			CommonConfig config =
            					(CommonConfig) ConfigFactory.Instance.GetConfig(typeof(CommonConfig));
            			isOptimisticLockingOn = config.UseOptimisticLocking;
            		}
            
            		// ...
            	}
            }]]>
            </code></hcaExample>
            
            <a name="example.validation"></a>
            <h3 class="dtH3">Overriding <see cref="M:Hca.Common.Configuration.ConfigBase.ValidateCustom"/></h3>
            <para>If a configuration class contains items that need special validation, you can override 
            <see cref="M:Hca.Common.Configuration.ConfigBase.ValidateCustom"/> and add the appropriate validation code there. Generally, this
            is not necessary for most configuration classes.</para>
            <hcaNote>If the validation fails, you should throw an exception. You can only throw <see cref="T:System.Configuration.ConfigurationException"/> 
            or a sub-class of that exception.</hcaNote>
            <hcaExample desc="Implementing Custom Validation"><code>
            <![CDATA[using System;
            using Hca.Common.Configuration;
            
            namespace Hca.Library
            {
            	public class MyConfig : ConfigBase
            	{
            		private int customItem;
            
            		public int CustomItem
            		{
            			get { return customItem; }
            			set { customItem = value; }
            		}
            		
            		protected override void ValidateCustom()
            		{
            			// perform custom validation here
            			
            			// if the validation fails, throw an exception.
            			if ( validationFailed )
            			{
            				throw new HcaConfigurationException();
            			}
            		}	
            
            		// ...
            	}
            }]]>
            </code></hcaExample>
            
            <a name="guidelines"></a>
            <h2 class="dtH2">Guidelines</h2>
            <para>The following sections identify the basic tenets and best practices for implementing configuration classes and files.</para>
            
            <a name="guidelines.tenets"></a>
            <h3 class="dtH3">Tenets</h3>
            The following tenets should be adhered when utilizing the configuration framework.
            <list type="bullet">
            	<item>All configuration classes must extend <see cref="T:Hca.Common.Configuration.ConfigBase"/>.</item>
            	<item>
            		Avoid configuration classes that are merely collections of miscellaneous values. Configuration 
            		information should be organized into cohesive classes.
            	</item>
            	<item>Keep the structure of each configuration class as simple as possible.</item>
            	<item>
            		Application configuration information should be cleanly separated from target and platform 
            		configuration.
            	</item>
            	<item>Configuration objects may throw only <see cref="T:System.Configuration.ConfigurationException"/>.</item>
            </list>
             
            <a name="guidelines.bestPractices"></a>
            <h3 class="dtH3">Best Practices</h3>
            The Configuration Framework provides a robust and consistent means for configuring applications and the components with which they interact. Ideally, once system administrators are familiar with the Configuration Framework, they can determine how the application is configured by just reviewing its configuration files, regardless of the system’s underlying architecture or domain. To accomplish this, the following guidelines should be used.
            <list type="bullet">
            	<item>Avoid configuration classes that are unrelated collections of values.</item>
            	<item>
            		Configuration classes should represent a cohesive concept that is readily recognizable to those 
            		who are familiar with the system domain.
            	</item>
            	<item>
            		Keep the structure of configuration classes as simple as is possible. Complex classes require 
            		complex XML object definitions. Unnecessary complexity makes maintenance difficult and error-prone.
            	</item>
            	<item>
            		Use the advanced features of the configuration framework sparingly. The Configuration Framework 
            		provides many powerful tools for object instantiation. However, many of the advanced features 
            		add extra complexity to the process and are not usually required. If you have a habit of using 
            		many of the Framework’s more advanced features, you may want to review your design for 
            		opportunities to simplify it.
            	</item>
            	<item>
            		Application configuration information should be clearly separate target and platform configuration. 
            		Applications should consistently use the Configuration Framework rather than using platform 
            		specific methods of configuration like “app.config”. Configuration information specific to the 
            		underlying target, platform, or operating system should continue to use the platform specific 
            		methods. Doing this ensures that configuration remains robust and portable across targets and 
            		platforms.
            	</item>
            	<item>
            		Configuration classes should use the <c>Config</c> suffix as a convention (e.g., <c>ServiceConfig</c>, 
            		<c>ExceptionConfig</c>, etc.).
            	</item>
            	<item>
            		Consider nomenclature carefully when creating configuration classes. Remember that configuration 
            		objects are not defined and maintained in a vacuum; the names you choose for classes and 
            		properties will be seen by system administrators. Try to choose names that convey meaning easily 
            		understood by domain users and administrators.
            	</item>
            </list>
            
            <a name="api"></a>
            <h2 class="dtH2">Application Programming Interface</h2>
            <para>This section summarizes the types exposed by the configuration framework.</para>
            <a name="api.classes"></a>
            </summary>
        </member>
        <member name="T:Hca.Common.Configuration.SectionHandler">
            <summary>Implements <see cref="T:System.Configuration.IConfigurationSectionHandler"/> for defining <see cref="T:Hca.Common.Configuration.ConfigFactory"/> settings in App.config (or Web.config).</summary>
            <remarks>
            <para>This class is for internal use only. It should only be referenced from a <c>&lt;configurationSection&gt;</c> element in the .NET configuration store.</para>
            <note><see cref="T:Hca.Common.Configuration.ConfigFactory"/>'s default behavior of integrating with .NET's configuration can be overridden. Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for details.</note>
            </remarks>
            <example>Please see the <see cref="N:Hca.Common.Configuration"/> namespace overview for an example of a .NET configuration file referencing <see cref="T:Hca.Common.Configuration.SectionHandler"/>.</example>
        </member>
        <member name="M:Hca.Common.Configuration.SectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
            <summary>Implemented by all <see cref="T:System.Configuration.IConfigurationSectionHandler"/>s to parse the XML of the configuration section. The returned object is added to the <see cref="T:System.Configuration.ConfigurationSettings"/> collection and is accessed by <see cref="M:System.Configuration.ConfigurationSettings.GetConfig(System.String)"/>.</summary>
            <param name="parent">The configuration settings in a corresponding parent configuration section.</param>
            <param name="configContext">An <c>HttpConfigurationContext</c> when <see cref="M:Hca.Common.Configuration.SectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)"/> is called from the ASP.NET configuration system. Otherwise, this parameter is reserved and is <see langword="null"/>.</param>
            <param name="section">The <see cref="T:System.Xml.XmlNode"/> that contains the configuration information from the configuration file. Provides direct access to the XML contents of the configuration section.</param>
            <returns>A configuration object - in this case, the <paramref name="section"/> node itself.</returns>
        </member>
        <member name="P:Hca.Common.Configuration.TokenDefinition.Location">
            <summary>Gets a human-readable description of where this token is declared - used when reporting configuration errors.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.TokenDefinition.Name">
            <summary>Gets the token name for which to search.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.TokenDefinition.Value">
            <summary>Gets the value with which occurrences of this token should be replaced.</summary>
        </member>
        <member name="P:Hca.Common.Configuration.TokenDefinition.OutputToken">
            <summary>Gets the <see cref="T:Hca.Common.Builder.Token"/> defined by this object.</summary>
        </member>
        <member name="T:Hca.Common.DataType.Address">
            <summary>
            This class provides a concrete Address implementation that uses codified values for common 
            terminology properties of Location (address type), State, Country, and County.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            See <see cref="T:Hca.Common.DataType.AddressBase"/> remarks for additional information on when to use <see cref="T:Hca.Common.DataType.Address"/> as 
            opposed to <see cref="T:Hca.Common.DataType.TextAddress"/>.
            <para/>
            <b>Address Property Semantics</b>
            <list type="table">
            	<listheader>
            		<term><b>Property</b></term>
            		<description><b>Usage</b></description>
            	</listheader>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.LocationId"/></term>
            		<description>
            			The place that is designated by the address. This is a codified value and 
            			represents locations such as home, business, etc.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.StateId"/></term>
            		<description>
            			The id of the state of the address. This is a codified value and represents 
            			the state.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountryId"/></term>
            		<description>
            			The id of the country of the address. This is a codified value and represents 
            			the country.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountyId"/></term>
            		<description>
            			The id of the county of the address. This is a codified value and represents 
            			the county.
            		</description>
            	</item>
            </list>
            <para/>
            All of the fields that <see cref="T:Hca.Common.DataType.Address"/> adds to <see cref="T:Hca.Common.DataType.AddressBase"/> 
            are codified. This means that only the code for the item is stored - not the text or description 
            of the item. The connection between the codified values and the text lookup is managed through 
            an <see cref="T:Hca.Common.DataType.ICodeRenderer"/>. This renderer should be configured through <see cref="T:Hca.Common.Service.ServiceHelper"/>. The 
            following example illustrates this configuration.
            </remarks>
            <example>
            <code>
            <![CDATA[
            <config type="Hca.Common.Service.ServiceConfig" readOnly="true" context="ICodeRenderer"> 
            	<Property name="serviceType" value="Hca.Facility.CodeManagement.CodeProvider"/> 
            	<Property name="Creator" value="Hca.Common.Service.SingletonTypeCreator"/> 
            </config>
            ]]>
            </code>
            <para/>
            	Example that illustrates how to set values using the constructor.
            	<hcaNote>The numerical values are fake codified values.</hcaNote>
            	<para/>
            	<hcaExample desc="Instantiating an Address">
            		<code>
            Address a = new Address ("115 Center Street", "Apt. A", "Nashville", "37201", 400, 8938, 7234, 9981);
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to set values using the property accessors.
            	<hcaNote>The numerical values are fake codified values.</hcaNote>
            	<para/>
            	<hcaExample desc="Address Property Usage">
            		<code>
            Address a = new Address ();
            a.StreetAddress = "115 Center Street";
            a.AddressLine2 = "Apt. A";
            a.City = "Nashville";
            a.CountyId = 8938;
            		</code>
            		
            	</hcaExample>
            	<para/>
            	Example that illustrates how to format the object into a string.  This method generates a 
            	standard mailing address. Note that the <see cref="M:Hca.Common.DataType.AddressBase.ToString"/> method is shared by both 
            	<see cref="T:Hca.Common.DataType.Address"/> and <see cref="T:Hca.Common.DataType.TextAddress"/> 
            	and hence the same example applies to <see cref="T:Hca.Common.DataType.TextAddress"/> other 
            	than the code values would be replaced by text values.
            	<para/>
            	<hcaExample desc="Using the IFormattable ToString of Address">
            		<code>
            Address address1 = new Address("100 Main St.", "Suite 100", "Nashville", "37214", 100, 201, 33);
            
            // assume 100, 201, and 33 are keys for codes
            address1.EffectiveDate = new Date(2004, 2, 6);
            
            string output = address1.ToString("M", CultureInfo.CurrentCulture);
            // returns: 100 Main St.\nSuite 100\nNashville . . . 
            
            // Print for another culture
            CultureInfo fr = new CultureInfo("fr-FR", false);
            String output = address1.ToString("V", fr);
            //returns: InCareOf: \nStreetAddress: 100 Main St.\nAddressLine2: Suite 100\nCity: Nashville\n
            State: 100\nPostalZone: 37214\nPostalZonePlusFour: \nCountry: 201\nCounty: 33\nEffectiveDate: 06/02/2004\n
            EndDate: \nIsDeliverable: \nIsPoBox: \nLocation: 1\n
            
            // Use a custom format
            String output = address1.ToString("{L1} {c} {s},{z}", CultureInfo.CurrentCulture);
            // returns: 100 Main St. Nashville 100,37214
            		</code>
            	</hcaExample>	
            </example>
        </member>
        <member name="T:Hca.Common.DataType.AddressBase">
            <summary>
            This class provides support to represent both domestic and international addresses. 
            This class supports flags for indication of standardization (USPS standards) which 
            may be a requirement for storage. Additionally, validations on whether the address 
            is deliverable (CASS certified) can be indicated through the <see cref="P:Hca.Common.DataType.AddressBase.IsDeliverable"/> 
            property. <see cref="P:Hca.Common.DataType.AddressBase.PostalZone"/> holds the standard postal address for any country. If a 
            US address is represented, <see cref="P:Hca.Common.DataType.AddressBase.PostalZonePlusFour"/> should hold the 4 digit part of 
            the zip code.
            </summary>
            <remarks>
            <see cref="T:Hca.Common.DataType.AddressBase"/> is the abstract base class for the codified <see cref="T:Hca.Common.DataType.Address"/>
            and the textual <see cref="T:Hca.Common.DataType.TextAddress"/>. Both derived classes 
            provide the same level of semantics but are intended for use in different scenarios. 
            <see cref="T:Hca.Common.DataType.Address"/> is suited for applications that have control 
            of the data entry of values that would make up the address. In particular, the codified 
            values need to driven from the legal set of codes for that term (e.g. all valid states 
            for <see cref="P:Hca.Common.DataType.Address.StateId"/>) to ensure consistency in representation. However, there are cases 
            where data is from a foreign system and the application cannot control the data that is 
            provided. In these cases, <see cref="T:Hca.Common.DataType.TextAddress"/> may be better 
            suited since it accepts the text value as is and does not need a provider to translate 
            between the coded form and the display form. For example, if a legacy system only stores 
            the value of the State attribute and not a code, it would require translation between the 
            text value and the codes that an application might use for this attribute. Further, if the 
            foreign system did not restrict the values entered (e.g. allowed TN or Tenn or Tennessee 
            for a State value) it may be impractical or impossible to provide reliable translation. 
            Hence, <see cref="T:Hca.Common.DataType.TextAddress"/> allows for the value as entered to be 
            used while maintaining the other features of <see cref="T:Hca.Common.DataType.AddressBase"/>. However, in general, it 
            is highly recommended that codified terms be used whenever possible to allow for evolution 
            and efficient communication of terms.
            <para/>
            <note>
            During design, consider using the <see langword="abstract"/> base class as a member 
            type if it is anticipated that the codified version of the address will 
            be evidentially used. 
            </note>
            <para/>
            			<see cref="T:Hca.Common.DataType.Address"/> and <see cref="T:Hca.Common.DataType.TextAddress"/> share 
            			these attributes:
            			<list type="bullet">
            				<item>Addressee (in care of)</item>
            				<item>Street Address and address Line 2</item>
            				<item>City</item>
            				<item>Zip Code (postal code) and Postal Zone + 4r</item>
            				<item>Whether it is a post office box</item>
            				<item>Dates when it starts and stops being valid.</item>
            			</list>
            			<see cref="T:Hca.Common.DataType.Address"/> also contains the following codified attributes:
            			<list type="bullet">
            				<item>State Id, County Id, and Country Id</item>
            				<item>Location Id (e.g. Home, Business, Vacation, etc.)</item>
            			</list>
            			<see cref="T:Hca.Common.DataType.TextAddress"/> also contains the following attributes:
            			<list type="bullet">
            				<item>State Text, County Text, and Country Text</item>
            				<item>Location Text</item>
            			</list>
            <para/>
            The data elements of an address are set and retrieved through properties. Most of them can also 
            be set through the overloaded constructor. However, the following properties must be set after 
            the object is created: <see cref="P:Hca.Common.DataType.AddressBase.EffectiveDate"/>, <see cref="P:Hca.Common.DataType.AddressBase.EndDate"/>, <see cref="P:Hca.Common.DataType.AddressBase.IsDeliverable"/>, <see cref="P:Hca.Common.DataType.AddressBase.IsPoBox"/>. 
            The semantics of the address fields that are not directly obvious are shown below. 
            <para/>
            <b>Address Property Semantics</b>
            <list type="table">
            	<listheader>
            		<term><b>Property</b></term>
            		<description><b>Usage</b></description>
            	</listheader>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.StreetAddress"/></term>
            		<description>The physical numbered address.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.AddressLine2"/></term>
            		<description>
            			For placement of information such as department, suite, or other designation that helps 
            			direct mail or identify the location of the address.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.PostalZonePlusFour"/></term>
            		<description>If the postal address in is the US, this the +4 portion of the zip code.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.EffectiveDate"/></term>
            		<description>The date that address becomes available for use.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.EndDate"/></term>
            		<description>The date the address becomes invalid for use.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.IsDeliverable"/></term>
            		<description>
            			Used to indicate that the address has been validated either through CASS certification 
            			or another source (such as a utility bill).
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.LocationId"/></term>
            		<description>
            			The place that is designated by the address. This is a codified value and 
            			represents locations such as home, business, etc.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.LocationDisplayText"/></term>
            		<description>The displayable text for the location.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.StateId"/></term>
            		<description>
            			The id of the state of the address. This is a codified value and represents 
            			the state.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.StateDisplayText"/></term>
            		<description>The displayable text for the state.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountryId"/></term>
            		<description>
            			The id of the country of the address. This is a codified value and represents 
            			the country.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.CountryDisplayText"/></term>
            		<description>The displayable text for the country.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountyId"/></term>
            		<description>
            			The id of the county of the address. This is a codified value and represents 
            			the county.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.AddressBase.CountyDisplayText"/></term>
            		<description>The displayable text for the county.</description>
            	</item>
            </list>
            <para/>
            There are several items that are codified. This means that only the code for the item is 
            stored - not the text or description of the item. The connection between the codified values
            and the text lookup is managed through an <see cref="T:Hca.Common.DataType.ICodeRenderer"/>. This renderer should be 
            configured through <see cref="T:Hca.Common.Service.ServiceHelper"/>. The following example illustrates this configuration.
            <example>
            <code>
            <![CDATA[
            <config type="Hca.Common.Service.ServiceConfig" readOnly="true" context="ICodeRenderer"> 
            	<Property name="serviceType" value="Hca.Facility.CodeManagement.CodeProvider"/> 
            	<Property name="Creator" value="Hca.Common.Service.SingletonTypeCreator"/> 
            </config>
            ]]>
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.DataTypeBase">
            <summary>
            Base type for datatype classes.
            </summary>
            <remarks>
            This class provides support for codified values
            by handling retrieving the <see cref="T:Hca.Common.DataType.ICodeRenderer"/>
            and 
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.ICodifiedType">
            <summary>
            Indicates that the type contains codified values
            and provides means to retrieve string representations
            given the code's key.
            </summary>
            <remarks>
            The actual implementation of these methods is usually with
            an <see cref="T:Hca.Common.DataType.ICodeRenderer"/> which is determined by the context
            for the code.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.ICodifiedType.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the numeric form for the specified <c>key</c>.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="context">The context for this code. This is used to retrieve
            the correct <see cref="T:Hca.Common.DataType.ICodeRenderer"/></param>
            <param name="culture">The desired culture for the
            display text if the provider supports cultures.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodifiedType.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the display text for the specified <c>key</c>.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="context">The context for this code. This is used to retrieve
            the correct <see cref="T:Hca.Common.DataType.ICodeRenderer"/></param>
            <param name="culture">The desired culture for the
            display text if the provider supports cultures.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="F:Hca.Common.DataType.DataTypeBase.DATATYPE_SCHEMA_NAMESPACE">
            <summary>
            The URI of the schema namespace that ObjectBuilder enforces
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.GetCodeProvider(System.String)">
            <summary>
            Return a code provider based on a given context.
            </summary>
            <remarks>
            It calls <see cref="T:Hca.Common.Service.ServiceHelper"/> to retrieve a <see cref="T:Hca.Common.DataType.ICodeRenderer"/>
            given a context if one was defined. If a context was passed 
            and no code provider was found, then
            a default code provider will be returned. This
            provider will return the key as a result for display text and numeric form calls.
            </remarks>
            <param name="context">The context to determine the code provider.</param>
            <returns>code provider</returns>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.GetSchema">
            <summary>
            Return the schema for all data types.
            </summary>
            <returns>XmlSchema</returns>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the numeric form for the specified <c>key</c>.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="context">The context for this code. This is used to retrieve
            the correct <see cref="T:Hca.Common.DataType.ICodeRenderer"/></param>
            <param name="culture">The desired culture for the
            display text if the provider supports cultures.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">
            Thrown if key is null.
            </exception>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the display text for the specified <c>key</c>.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="context">The context for this code. This is used to retrieve
            the correct <see cref="T:Hca.Common.DataType.ICodeRenderer"/></param>
            <param name="culture">The desired culture for the
            display text if the provider supports cultures.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">
            Thrown if key is null.
            </exception>
        </member>
        <member name="T:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer">
            <summary>
            Provides a default code renderer if one has not been defined.
            The return values are the keys.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.ICodeRenderer">
            <summary>
            Signature for a code provider. Code providers
            manage retrieve the appropriate string representation
            for code keys. 
            </summary>
            <remarks>
            This interface allows for datatypes and other types
            that have codified values to get different string
            representations of these codes given their keys.
            <p/>
            This interface allows multiple renderers to be represented
            and used by types. For instance, you could use Code Management
            Facility or create your own renderer that maps to your schema. The
            renders should be configured for the <see cref="T:Hca.Common.Service.ServiceHelper"/>
            and delineated by a context. A context of <see langword="null"/> should
            return a contextless renderer or the default renderer.
            If no context was provided and a renderer was not found,
            the key should be returned as the display text and numeric form.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong)">
            <overloads>Returns the most current numeric form.</overloads>
            <summary>
            Returns the most current numeric form for the specified <paramref name="key"/>. 
            </summary>
            <param name="key">The key of the code to look up</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean)">
            <summary>
            Returns the numeric form for the specified <paramref name="key"/> and optionally adds historical display text.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Returns the numeric form for the specified <paramref name="key"/> and culture and optionally adds historical display text.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="culture">The desired culture for the numeric form</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if the provider does not support cultures.</exception>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong)">
            <overloads>Returns the most current display text.</overloads>
            <summary>
            Returns the most current display text for the specified <paramref name="key"/>.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean)">
            <summary>
            Returns the display text for the specified <paramref name="key"/> and optionally adds historical display text.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.ICodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Returns the display text for the specified <paramref name="key"/> and culture and optionally adds historical display text.
            Implementors that do not support culture info
            will throw a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="culture">The desired culture for the
            display text</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/> if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the provider does not support cultures.</exception>
        </member>
        <member name="P:Hca.Common.DataType.ICodeRenderer.SupportsCultures">
            <summary>
            Does this provider support cultures for its codes?
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong)">
            <summary>
            Returns the most current numeric form for the specified <c>key</c>. 
            </summary>
            <param name="key">The key of the code to look up</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean)">
            <summary>
            Returns the numeric form for the specified <c>key</c>.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetNumericForm(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Returns the numeric form for the specified <c>key</c>.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <param name="culture">The desired culture for the numeric form</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if the provider does not support cultures.</exception>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong)">
            <summary>
            Returns the most current display text for the specified <c>key</c>.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean)">
            <summary>
            Returns the display text for the specified <c>key</c>.
            No culture is specified and therefore the default
            culture for the code will be used.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.GetDisplayText(Hca.Common.NullableValueType.nulong,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Returns the display text for the specified <c>key</c>.
            Implementors that do not support culture info
            will throw a NotSupportedException.
            </summary>
            <param name="key">The key of the code to look up</param>
            <param name="culture">The desired culture for the
            display text</param>
            <param name="showHistoricalValue"><see langword="true"/> if the historical display text should be shown.
            If <see langword="false"/>, then the latest version of the display text is shown.</param>
            <returns>The numeric form of the code or <see langword="null"/>  if there is not a numeric form.</returns>
            <exception cref="T:Hca.Common.BaseException.ItemNotFoundException">Thrown if code is not found.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the provider does not support cultures.</exception>
        </member>
        <member name="P:Hca.Common.DataType.DataTypeBase.DefaultCodeRenderer.SupportsCultures">
            <summary>
            Does this provider support cultures for its codes?
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.AddressBase"/>.</overloads>
            <summary>
            Default constructor.
            </summary>		
            <remarks>
            The effective date is set to Today. The other fields are set to <see langword="null"/> by default.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Constructor that creates a new instance and populates the object with the given 
            address elements.
            </summary>
            <param name="streetAddress">The street address</param>
            <param name="addressLine2">The second line of the address</param>
            <param name="city">the city of the address</param>
            <param name="postalZone">the zip code (5 digit)</param>
            <remarks>
            The effective date is set to Today.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.#ctor(Hca.Common.DataType.AddressBase)">
            <summary>
            This constructor creates a new instance and uses the data from the specified
            <paramref name="addressBase"/> to populate the new instance.
            </summary>
            <remarks>
            If <paramref name="addressBase"/> is <see langword="null"/>, this constructor is equivalent 
            to calling the default constructor.
            </remarks>
            <param name="addressBase">An instance of <see cref="T:Hca.Common.DataType.AddressBase"/> to copy from.</param>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.Populate(Hca.Common.DataType.AddressBase)">
            <summary>
            This method will set the values of this address to the values of the passed 
            address. 
            </summary>
            <remarks>
            If the argument passed is <see langword="null"/>, no change occurs to the current address. 
            Implementors should override this method and add any population of fields they may add.
            </remarks>
            <param name="addressBase">The instance of <see cref="T:Hca.Common.DataType.AddressBase"/> to 
            use to populate this instance.</param>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.CalculateHashKey">
            <summary>
            <p>
            This method calculates a hash value for the value-part of an address.
            </p>
            </summary>
            <remarks>
            The following fields are used for calculation of the value:
            <list type="bullet">
            	<item><see cref="P:Hca.Common.DataType.AddressBase.StreetAddress"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.AddressLine2"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.City"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.PostalZone"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.PostalZonePlusFour"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.StateDisplayText"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.CountryDisplayText"/></item>
            	<item><see cref="P:Hca.Common.DataType.AddressBase.CountyDisplayText"/></item>
            </list>
            <p>
            The intent of use for this method is to provide a key for the "value" part of the address such that when 
            modeling one to many relationships of an entity to an address, the value part is stored only once for the 
            same address value. For example, given relationships of contact address and home address, if both values 
            were: 
            <code>100 main St. AnyTown AnyState</code> 
            instead of storing this twice, you could use this key to store the address value (the properties listed
            previously) in one table and the relationship in another where the foreign key in the parent is this key.</p>
            <note>
            If you change the the values that contribute to this key, you must call this method again to get the new
            key instead of updating the values at the old key. If a new value is created, it may need to be inserted
            since it may not exist. Cleanup of values should be based on whether history needs to be maintained for 
            historical address values. If not, some form of reference counting needs to be used so it is known when a 
            value can be cleaned up. This is up to the client application to provide.</note>
            </remarks>
            <returns>A hash (<see langword="int"/> )for the current address value</returns>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.ToString">
            <overloads>Returns a string representation of the current address.</overloads>
            <summary>
            Returns the general format string of <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/> implementation.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.ToString(System.String,System.IFormatProvider)">
            <summary>
            This method provides specialized formatting of an address based on the passed 
            character(s) in the format argument.
            </summary>
            <remarks>
            The format can be specified in two different ways.
            <para/>
            <b>Standard Formats</b>
            <br/>
            The first way is by specifying one of the <i>Standard Formats</i>:
            <list type="table">
            	<item>
            		<term>G or g (General format)</term>
            		<description>Default if not specified.</description>
            	</item>
            	<item>
            		<term>M (Mailing Address)</term>
            		<description>Returns a mailable Address.</description>
            	</item>
            	<item>
            		<term>V (Verbose)</term>
            		<description>Returns a listing of the values of all fields.</description>
            	</item>
            </list>
            <para/>
            <b>Custom Formats</b>
            <br/>
            The second way is by specifying the address segments using these identifiers.
            <br/>
            These formats are case insensitive:
            <list type="table">
            	<item>
            		<term>{L1}</term>
            		<description>Street Address; Line 1</description>
            	</item>
            	<item>
            		<term>{L2}</term>
            		<description>Address Line 2</description>
            	</item>
            	<item>
            		<term>{C}</term>
            		<description>City</description>
            	</item>
            	<item>
            		<term>{S}</term>
            		<description>State</description>
            	</item>
            	<item>
            		<term>{Z}</term>
            		<description>Postal Zone</description>
            	</item>
            	<item>
            		<term>{F}</term>
            		<description>Postal Zone + 4</description>
            	</item>
            	<item>
            		<term>{R}</term>
            		<description>Country</description>
            	</item>
            	<item>
            		<term>{N}</term>
            		<description>County</description>
            	</item>
            </list>
            <para/>
            Any unrecognized characters are repeated back into the output string as specified 
            in the format string for the custom format.
            <para/>
            If the format provided is not a standard format and none of the custom characters 
            are recognized, the returned string is the format string as provided.
            <para/>
            The <b>{</b> is treated as a delimiter of sorts and if you desire it to be in the 
            output as a literal, you must escape it with a second left or right brace<b>{ or }</b> 
            character. For example:
            <code>
            	"{{C}"
            </code>
            will yield a parsed pattern of only the <b>{C</b> literal since the double left brace 
            characters are consumed together. Instead, to have this appear as a brace followed by 
            the {c} token,  add a second left brace to the string. For example:
            <code>
            	"{{{C}"
            </code>
            will yield a parsed pattern of a literal { followed by the C token <b>{&lt;C Token Value&gt;</b>.
            <para/>
            Finally, to make this happen internally, we use unicode 0 and 1 as temporary replacement 
            tokens. Hence these cannot be used as literal values in the format string. Given that 
            these are not printable characters and this method is to generate a printable string, 
            this is not a problem.
            </remarks>
            <example>
            Standard Format
            <code>
            Address someAddress = new Address("111 Maple Street", "Apt 2", "OurTown", "12345", 12, 1, 0);
            
            string myAddress = someAddress.ToString("M", System.Globalization.CultureInfo.CurrentCulture);
            returns: 111 Maple Street\nApt 2\nOutTown . . .
            
            myAddress = String.Format("My Address is {0:G}", someAddress);
            returns: My Address is 111 Maple Street, Apt 2, OutTown . . .
            </code>
            Custom Format
            <code>
            Address someAddress = new Address("111 Maple Street", "Apt 2", "OurTown", "12345", 12, 1, 0);
            
            string myAddress = someAddress.ToString("{L1}, {L2} : {C}", System.Globalization.CultureInfo.CurrentCulture);
            returns: 111 Maple Street, Apt 2 : OurTown
            </code>
            </example>
            <param name="format">The format string</param>
            <param name="formatProvider">Format Provider to use.</param>
            <returns>The formatted address, or the format string if there are no parts of the format string
            that are recognizable.
            </returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if Unicode character 0 or 1 is included in the 
            format string.</exception>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.AppendLine(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Formats the information passed in <paramref name="caption"/> and <paramref name="val"/>
            and appends it to <paramref name="builder"/>.
            </summary>
            <param name="builder">The <see cref="T:System.Text.StringBuilder"/> to add the formatted line to.</param>
            <param name="caption">The caption to use in the formatted line.</param>
            <param name="val">The value to use in the formatted line.</param>
            <remarks>
            <paramref name="builder"/> is updated with the newly formatted line.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.AppendSegment(System.Text.StringBuilder,System.String,System.String,System.String)">
            <summary>
            Creates a formatted line and adds it to <paramref name="builder"/>.
            </summary>
            <param name="builder">The <see cref="T:System.Text.StringBuilder"/> to add the formatted line to.</param>
            <param name="val">The value to use in the formatted line.</param>
            <param name="before">Information to include in the line before the value.</param>
            <param name="after">Information to include in the line after the value.</param>
            <remarks>
            <paramref name="builder"/> is updated with the newly formatted line.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.FormatHashData(System.String)">
            <overloads>Formats a hash key and returns it.</overloads>
            <summary>
            Formats a string hash key and returns it as a byte array.
            </summary>
            <param name="value">The data to format.</param>
            <returns>The hash data for this value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.FormatHashData(Hca.Common.NullableValueType.nulong)">
            <summary>
            Formats a nullable long hash key and returns it as a byte array.
            </summary>
            <param name="value">The data to format.</param>
            <returns>The hash data for this value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.AddressBase.PopulateImpl(Hca.Common.DataType.AddressBase)">
            <summary>
            Populates the current instance with the values from <paramref name="addressBase"/>.
            </summary>
            <param name="addressBase">The <see cref="T:Hca.Common.DataType.AddressBase"/> instance to use to populate this instance.</param>
            <remarks>
            This non-virtual implementation is safe call from a constructor.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.StreetAddress">
            <summary>
            The street Address (line one) of the address.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.AddressLine2">
            <summary>
            The second line of the address, if any.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.City">
            <summary>
            The city where this address is located.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.PostalZone">
            <summary>
            The standard 5 digit postal code for the address.
            </summary>
            <remarks>
            To store the extended portion of a zip+4 code, place the extended information
            in the <see cref="P:Hca.Common.DataType.AddressBase.PostalZonePlusFour"/> attribute.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.PostalZonePlusFour">
            <summary>
            The plus-4 part of the zip code.
            </summary>
            <remarks>
            Store the base portion of a zip+4 code in the <see cref="P:Hca.Common.DataType.AddressBase.PostalZone"/> attribute.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.InCareOf">
            <summary>
            The name of the individual who actually resides at this address.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.EffectiveDate">
            <summary>
            The begin date that this address is valid for use. This defaults to the
            date this object is created. If the user desires a different date, that
            date should be set via the setter for this property.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.EndDate">
            <summary>
            The date that the address is no longer valid for use.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.IsDeliverable">
            <summary>
            This flag indicates that the address is a deliverable address. If <see langword="true"/>, 
            this flag indicates that a non-CASS certifiable address is deliverable (validated through 
            some other means such as a utility bill). The fact that this flag is <see langword="false"/> 
            may be useful in the case where the address is also non-CASS certified (e.g., disallowing 
            some activity to proceed due to a non-deliverable Address).
            </summary>
            <remarks>
            The default value for this property is <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.IsPoBox">
            <summary>
            Indicates whether this is a Post Office address or a physical location.
            </summary>
            <remarks>
            The default value for this property is <see langword="false"/> indicating that the 
            address is <b>not</b> a Post Office address.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.LocationDisplayText">
            <summary>
            The displayable text for the <c>location</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.StateDisplayText">
            <summary>
            The displayable text for the <c>state</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.CountryDisplayText">
            <summary>
            The displayable text for the <c>country</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AddressBase.CountyDisplayText">
            <summary>
            The displayable text for the <c>county</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.Address"/>.</overloads>
            <summary>
            Default Constructor. See <see cref="T:Hca.Common.DataType.AddressBase"/> for more information
            on how the various fields are populated by default.
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(Hca.Common.NullableValueType.nulong)">
            <summary>
            This constructor creates new a address with location code (also called the address 
            type) specified in <paramref name="locationId"/>. The address location defines the 
            <b>type</b> of address, such as <i>home</i>, <i>office</i>, etc.
            </summary>
            <param name="locationId">The address type code(Home, Business, etc.)</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(Hca.Common.DataType.Address)">
            <summary>
            This constructor creates a new instance and uses the data from the specified
            <see cref="T:Hca.Common.DataType.Address"/> to populate the new instance.
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.Address"/> to 
            use to populate this instance.</param>
            <remarks>
            If the address passed is <see langword="null"/>, this constructor is equivalent to calling 
            the default constructor.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(System.String,System.String,System.String,System.String,Hca.Common.NullableValueType.nulong)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="stateId">The state of the address.</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(System.String,System.String,System.String,System.String,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="stateId">The state of the address.</param>
            <param name="countryId">The country of the address.</param>
            <param name="locationId">The address type.</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(System.String,System.String,System.String,System.String,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="stateId">The state of the address.</param>
            <param name="countyId">The county code of the address.</param>
            <param name="countryId">The country of the address.</param>
            <param name="locationId">The address type.</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.#ctor(System.String,System.String,System.String,System.String,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="stateId">The state of the address.</param>
            <param name="countyId">The county of the address.</param>
            <param name="countryId">The country of the address.</param>
            <param name="locationId">The address type.</param>
            <param name="postalZonePlusFour">The plus four zip-code extension of the address.</param>
        </member>
        <member name="M:Hca.Common.DataType.Address.CalculateHashKey">
            <summary>
            <p>
            This method calculates a hash value for the value-part of an address.
            </p>
            </summary>
            <remarks>
            For general information refer to <see cref="M:Hca.Common.DataType.AddressBase.CalculateHashKey"/>.
            A codified address uses the string version of the ids for (State, Country, and County) so that display changes
            don't change the hash for the address.
            </remarks>
            <returns>A hash (<see langword="int"/> )for the current address value</returns>
        </member>
        <member name="M:Hca.Common.DataType.Address.Populate(Hca.Common.DataType.AddressBase)">
            <summary>
            This method will set the values of this address to the values of the passed 
            address. 
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.Address"/> to 
            use to populate this instance.</param>
            <remarks>
            If the argument passed is <see langword="null"/>, no change occurs to the current address. 
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.Address.PopulateImpl(Hca.Common.DataType.Address)">
            <summary>
            Populates the current instance with the values from <paramref name="addressValue"/>.
            </summary>
            <param name="addressValue">The <see cref="T:Hca.Common.DataType.Address"/> instance to use to populate this instance.</param>
        </member>
        <member name="P:Hca.Common.DataType.Address.LocationId">
            <summary>
            The Type of address as represented by a codified value. This is the actual key for 
            the code.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Address.LocationDisplayText">
            <summary>
            The displayable text for the <c>location</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Address.StateId">
            <summary>
            A codified value of the state this address is located within. This is the actual key 
            for the code.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Address.StateDisplayText">
            <summary>
            The displayable text for the <c>state</c> code. The actual value returned is determined 
            by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Address.CountryId">
            <summary>
            A codified value of the country this address is located within. This is the actual key 
            for the code.
            </summary>
            <remarks>
            If the value is other than USA, it must be included when mailing to the address.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Address.CountryDisplayText">
            <summary>
            The displayable text for the <c>country</c> code. The actual value returned is 
            determined by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Address.CountyId">
            <summary>
            A codified value of the county this address is located within. This is the actual key 
            for the code.
            </summary>
            <remarks>
            For addresses that have county concepts, where this is useful to capture (e.g. marketing 
            targeting certain counties for a promotion.)
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Address.CountyDisplayText">
            <summary>
            The displayable text for the <c>county</c> code. The actual value returned is determined 
            by the implementation of the code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.AuditDetail">
            <summary>
            This class provides a attributes for capturing information typically used 
            when collecting detail for audit records.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            The create time is set by default to the time this object is created. The
            update time is left <see langword="null"/>  until it is updated for the first time outside 
            the initial construction of this object.
            </remarks>
        </member>
        <member name="F:Hca.Common.DataType.AuditDetail.createDateTime">
            <summary>
            When this item was created.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.AuditDetail.createUser">
            <summary>
            A string that contains the user identity of who created this item.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.AuditDetail.updateDateTime">
            <summary>
            When this item was last updated outside of the initial create.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.AuditDetail.updateUser">
            <summary>
            a string that contains the user identity of who updated this item.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.AuditDetail"/>.</overloads>
            <summary>
            Creates a new default instance this class.
            </summary>
            <remarks>
            By default the create time is set to the current time.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.#ctor(Hca.Common.DataType.UtcDateTime,System.String)">
            <summary>
            Creates a new instance of this class with a specified create time and the identity of the user creating the object.
            </summary>
            <param name="createDateTime">The Create time for this object</param>
            <param name="createUser">The identity of the user that created this object</param>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.#ctor(Hca.Common.DataType.UtcDateTime,System.String,Hca.Common.DataType.UtcDateTime,System.String)">
            <summary>
            Constructor that takes all field values.
            </summary>
            <remarks>
            If the create time is <see langword="null"/> , the current time is used.
            </remarks>
            <param name="createDateTime">The Create time for this object</param>
            <param name="createUser">The identity of the user that created this object</param>
            <param name="updateDateTime">The time of the update to this object</param>
            <param name="updateUser">The Identity of the user who caused the change.</param>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.#ctor(Hca.Common.DataType.AuditDetail)">
            <summary>
            Creates a new instance of the <see cref="T:Hca.Common.DataType.AuditDetail"/> class based on the source object
            </summary>
            <param name="source">
            The <see cref="T:Hca.Common.DataType.AuditDetail"/> object to use as the source for the new instance.
            </param>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.Populate(Hca.Common.DataType.AuditDetail)">
            <summary>
            Sets the value of the object based on another object.
            </summary>
            <param name="source">The <see cref="T:Hca.Common.DataType.AuditDetail"/> object to use as the source for the object's new values.</param>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.ToString">
            <summary>
            Returns the "G" format string of <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/> implementation.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.AuditDetail.ToString(System.String,System.IFormatProvider)">
            <summary>
            Provide a formatted string value
            </summary>
            <remarks>
            This class provides for the standard format and a custom format. The
            formats are such:
            <p>
            <b>Standard Format</b>
            G, g, or no specification yields the standard <see cref="T:Hca.Common.Builder.ToStringBuilder"/> value 
            given the <see cref="T:Hca.Common.DataType.AuditDetail"/> object.
            <b>Custom Format</b>
            The custom format tags are case insensitive.
            <list type="table">
            <item>
            <term>{C}</term>
            <description>The Create time</description>
            </item>
            <item>
            <term>{CI}</term>
            <description>The Identity of the create user</description>
            </item>
            <item>
            <term>{U}</term>
            <description>The Update time</description>
            </item>
            <item>
            <term>{UI}</term>
            <description>The Identity of the update user</description>
            </item>
            </list>
            </p>
            Any unrecognized characters are repeated back into the output
            string as specified in the format string for the custom format.
            
            If the format provided is not a standard format and none of the 
            custom characters are recognized, the returned string is the 
            format string as provided.
            
            The <b>{</b> is treated as a delimiter of sorts and hence if you
            desire it to be in the output as a literal, you must escape it with
            a second left or right brace<b>{ or }</b> character. For example:
            <code>
            	"{{C}"
            </code>
            will yield a parsed pattern of only the <b>{C</b> literal since the 
            double left brace are consumed together. Instead, to have this appear
            as a brace followed by the {c} token,  add a second left brace to the 
            string. For example:
            <code>
            	"{{{C}"
            </code>
            will yield a parsed pattern of a literal { followed by the C token
            <b>{&lt;C Token Value%gt;</b>.
            <p>
            Finally, to make this happen internally, we use unicode 0 and 1
            as temporary replacement tokens. Hence these cannot be used as
            literal values in the format string. Given that these are not
            printable characters and this method is to generate a printable
            string, this is not a problem.
            </p>
            </remarks>
            <example>
            The following will print the ToString version as derived from 
            <see cref="T:Hca.Common.Builder.ToStringBuilder"/> given the audit detail object:
            <code>
            	AuditDetail myDetail = new AuditDetail();
            	string result = String.Format("Audit Detail:{0}", myDetail);
            	result = String.Format("Audit Detail:{0:g}", myDetail);
            	result = String.Format("Audit Detail:{0:G}", myDetail);
            	result = myDetail.ToString("", System.Globalization.CultureInfo.CurrentCulture);
            	result = myDetail.ToString("g", System.Globalization.CultureInfo.CurrentCulture);
            	result = myDetail.ToString("G", System.Globalization.CultureInfo.CurrentCulture);
            	// result = Hca.Common.DataType.AuditDetail@a54f7009-36d1-4950-ac16-0fe3fa47d3f0[CreateTime=Hca.Common.Datatype.UtcTimeStamp@43b81f51-18a8-40c9-ad86-1dfa1aeba0e0[dateValue=System.DateTime@276143829[ticks=632229902329036650]],CreateUser=(null),UpdateTime=(null),UpdateUser=(null)]
            </code>
            This shows how nulls are not shown in custom format mode where a value is <see langword="null"/> .
            <code>
            	AuditDetail myDetail = new AuditDetail();
            	string result = myDetail.ToString("{U}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = ""
            </code>
            This would print the create time. Note the third case that literals would remain in 
            as specified.
            <code>
            	AuditDetail myDetail = new AuditDetail(new UtcTimeStamp(), "myId", new UtcTimeStamp(), "myId");
            	string result = myDetail.ToString("{C}", System.Globalization.CultureInfo.CurrentCulture);
            	result = myDetail.ToString("{c}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = 6/16/2004 1:43:52 PM
            	result = myDetail.ToString("Create Time:{c}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = Create Time:6/16/2004 1:43:52 PM
            	result = myDetail.ToString("{{C}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = {C}
            	result = myDetail.ToString("{{{C}}}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = {6/16/2004 1:43:52 PM}
            </code>
            This would print the create time and create user.
            <code>
            	AuditDetail myDetail = new AuditDetail(new UtcTimeStamp(), "myId", new UtcTimeStamp(), "myId");
            	string result = myDetail.ToString("{C}{U}", System.Globalization.CultureInfo.CurrentCulture);
            	result = myDetail.ToString("{c}{u}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = 6/16/2004 1:43:52 PMmyId
            	result = myDetail.ToString("Create Time:{c} Create User:{u}", System.Globalization.CultureInfo.CurrentCulture);
            	// result = Create Time:6/16/2004 1:43:52 PM Create User:myId
            </code>
            </example>
            <param name="format">The format to use</param>
            <param name="formatProvider">A provider for processing format</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if Unicode character 0 or 1 is included in the 
            format string.</exception>
        </member>
        <member name="P:Hca.Common.DataType.AuditDetail.CreateUser">
            <summary>
            return the use who created this object.
            </summary>
            <remarks>
            Default: <see langword="null"/> 
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AuditDetail.CreateDateTime">
            <summary>
            Return the create time of this object
            </summary>
            <remarks>
            Default: the time the object instance was created.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AuditDetail.UpdateUser">
            <summary>
            The user who caused the update to this object.
            </summary>
            <remarks>
            Default: <see langword="null"/> 
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.AuditDetail.UpdateDateTime">
            <summary>
            The time that this object was last updated.
            </summary>
            <remarks>
            Default: <see langword="null"/> 
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.DataTypeXsdDescriptor">
            <summary>Describes <i>EmbedFile.DataTypeSchema.xsd</i> for programmatic consumption.</summary>
        </member>
        <member name="F:Hca.Common.DataType.DataTypeXsdDescriptor.SCHEMA_RESOURCE_NAME">
            <summary>The name of the embedded resource containing the .XSD file.</summary>
        </member>
        <member name="F:Hca.Common.DataType.DataTypeXsdDescriptor.SCHEMA_NAMESPACE_URI">
            <summary>The Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="F:Hca.Common.DataType.DataTypeXsdDescriptor.schemas">
            <summary>Holds the cached result of <see cref="M:Hca.Common.DataType.DataTypeXsdDescriptor.GetSchemas"/>.</summary>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeXsdDescriptor.#ctor">
            <summary>Private constructor supports / enforces singleton pattern.</summary>
        </member>
        <member name="M:Hca.Common.DataType.DataTypeXsdDescriptor.GetSchemas">
            <summary>Retrieves all the schema information necessary to validate an XML document written against the schema that this descriptor represents.</summary>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaCollection"/> containing the primary XML schema represented by this descriptor, as well as any other schemas referenced by the primary schema.</returns>
        </member>
        <member name="P:Hca.Common.DataType.DataTypeXsdDescriptor.Instance">
            <summary>Gets the singleton instance of <see cref="T:Hca.Common.DataType.DataTypeXsdDescriptor"/>.</summary>
        </member>
        <member name="P:Hca.Common.DataType.DataTypeXsdDescriptor.NamespaceUri">
            <summary>Gets the Universal Resource Identifier (URI) of the namespace defined by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="P:Hca.Common.DataType.DataTypeXsdDescriptor.ReferencedXsds">
            <summary>Gets a list of the schemas referenced by the XML schema that this descriptor represents.</summary>
        </member>
        <member name="T:Hca.Common.DataType.Date">
            <summary>
            This class contains the date elements of the <see cref="T:System.DateTime"/> class (Month, Day, and Year).
            There is no time component.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            
            
            	<para><b>Functional Requirements</b></para>
            	This class provides a date-only representation.
            
            	<para><b>Tenets</b></para>
            	The user should attempt to use values for only legitimate dates.  Invalid values 
            	generate an error. For example, January 43, 2004 is not a valid date.
            
            	<para><b>Design</b></para>
            	<see cref="T:Hca.Common.DataType.Date"/> is a custom data type that stores the elements of a date 
            	(year, month, and day). This class does not have time elements. It is intended to be used when 
            	the developer is only concerned with the date segments of <see cref="T:System.DateTime"/>.
            	<para/>
            	<see cref="T:Hca.Common.DataType.Date"/> uses <see cref="T:System.DateTime"/> internally to validate, 
            	manipulate, and output the values. It strips out any time-specific values.
            
            	<para><b>Usage</b></para>
            	<see cref="T:Hca.Common.DataType.Date"/> should be used in any Value Object that requires a date-only property. It 
            	should be used instead of <see cref="T:System.DateTime"/> because <see cref="T:System.DateTime"/> 
            	does not store any time zone information.
            	<para/>
            	Variables typed for this class can also be set to <see langword="null"/>, indicating a <i>not-set</i> 
            	state. This is useful as data types for properties of any class that requires a partial update. 
            	<para/>
            	Exceptions are also thrown when <see cref="T:Hca.Common.DataType.Date"/> instances are initialized with invalid dates .
            	<para/>
            	<hcaNote>Use <see cref="T:Hca.Common.DataType.Date"/> or <see cref="T:Hca.Common.DataType.UtcDateTime"/> 
            	instead of .NET's <see cref="T:System.DateTime"/>.
            	</hcaNote>
            
            	<para><b>Best Practices</b></para>
            	Use <see cref="T:Hca.Common.DataType.Date"/> and as data a 
            	type for properties of Value Objects instead of <see cref="T:System.DateTime"/>. Additionally, when 
            	only a date is needed (such as representing a date of birth), use <see cref="T:Hca.Common.DataType.Date"/> 
            	since it ensures that time components are not valued.
            
            
            <see cref="T:Hca.Common.DataType.DateConverter"/> is associated with this type allowing two-way conversion. 
            <seealso cref="T:System.ComponentModel.TypeConverter"/>
            </remarks>
            <example>
            	<hcaExample desc="Example 10: Setting the values through the constructors">
            		<code>
            // a new datetime with a blank time
            DateTime dateTime = new DateTime(2004,6,14,0,0,0,0); 
            Date dt = new Date(dateTime);
            	Or
            Date dt = new Date(2004, 6, 14);
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Example 11: Setting the values through SetDate">
            		<code>
            Date dt = new Date();
            dt.SetDate(2004, 6, 14);
            		</code>
            	</hcaExample>
            </example>
        </member>
        <member name="F:Hca.Common.DataType.Date.internalValue">
            <summary>The true value that stores the state. To support inherited classes, ONLY ACCESS THROUGH PROPERTY!</summary>
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.Date"/>.</overloads>
            <summary>
            Initializes a new instance of <see cref="T:Hca.Common.DataType.Date"/> to the current date.
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of <see cref="T:Hca.Common.DataType.Date"/> from the date portion of the <see cref="T:System.DateTime"/> provided.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> object that the date should be pulled from.</param>
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Hca.Common.DataType.Date"/> to the specified year, month, and day.
            </summary>
            <param name="year">The year (1 through 9999).</param>
            <param name="month">The month (1 through 12).</param>
            <param name="day">The day (1 through the number of days in month).</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor(System.String)">
            <summary>
            Sets the date given a string value of the date
            </summary>
            <remarks>
            </remarks>
            <param name="value"></param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor(Hca.Common.DataType.Date)">
            <summary>
            Constructor that takes a current reference <see cref="T:Hca.Common.DataType.Date"/>.
            </summary>
            <param name="value"></param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.#ctor(System.String,System.String)">
            <summary>
            Constructor that takes a date string representation and its format
            </summary>
            <remarks>
            </remarks> 
            <param name="value"></param>
            <param name="format"></param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToDateTime">
            <summary>
            Converts the value of the instance to a <see cref="T:System.DateTime"/> object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.AddDays(System.Double)">
            <summary>
            Adds the specified number of days to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional days. The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.Date"/> whose value is the sum of the date and time represented by this 
            instance and the number of days represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.AddMonths(System.Int32)">
            <summary>
            Adds the specified number of months to the value of this instance.
            </summary>
            <param name="value">A number of months. The months parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.Date"/> whose value is the sum of the date and time represented by this instance and months.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.AddYears(System.Int32)">
            <summary>
            Adds the specified number of years to the value of this instance.
            </summary>
            <param name="value">A number of years. The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.Date"/> whose value is the sum of the date and time represented by 
            this instance and the number of years represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToString">
            <summary>
            Converts the value of this instance to its equivalent string.
            </summary>
            <remarks>
            This prints the <see cref="T:Hca.Common.DataType.Date"/> in the "yyyy-MM-dd" format
            </remarks>
            <returns>A string representation.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToString(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to its equivalent 
            string representation using the specified culture-specific format information.
            </summary>
            <remarks>
            This prints the <see cref="T:Hca.Common.DataType.Date"/> in the standard short date form using the passed 
            culture settings.
            </remarks>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information.</param>
            <returns>A string representation of value of this instance as specified by provider.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">If the format provider is not valid.</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation 
            using the specified format.
            </summary>
            <remarks>
            This prints the date with the passed format using the current culture 
            settings.
            </remarks>
            <param name="format">A format string.</param>
            <returns>A string representation of value of this instance as specified by format.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">If the format is not valid.</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the value of this instance to its equivalent string representation using the 
            specified format and culture-specific format information.
            </summary>
            <param name="format">A format string.</param>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information.</param>
            <returns>A string representation of value of this instance as specified by format and provider.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">If the format or provider is not valid.</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToLongDateString">
            <summary>
            Converts the value of this instance to its equivalent long date string representation.
            </summary>
            <returns>A string containing the name of the day of the week, 
            the name of the month, the numeric day of the month, and the year equivalent 
            to the date value of this instance.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.ToShortDateString">
            <summary>
            Converts the value of this instance to its equivalent short date string representation.
            </summary>
            <returns>A string containing the numeric month, the numeric day of the month, 
            and the year equivalent to the date value of this instance.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.Parse(System.String,System.String)">
            <summary>
            This method will set the current value for the date from a string value and
            given format(s). The string value passed must match one of the given formats
            or an invalid date exception will be thrown
            </summary>
            <param name="value"></param>
            <param name="format">A valid array of <see cref="T:System.IFormattable"/> format string</param>
        </member>
        <member name="M:Hca.Common.DataType.Date.CompareTo(System.Object)">
            <summary>
            Two <see cref="T:Hca.Common.DataType.Date"/> compare equal if their datetime values compare equal
            </summary>
            <param name="obj"></param>
            <returns>
            <list type="table">
            <listheader>
            	<term>Value</term>
            	<term>Description</term>
            </listheader>
            <item>
            	<description>Less than zero</description>
            	<description>This instance is less than value.</description>
            </item>
            <item>
            	<description>Zero</description>
            	<description>This instance is equal to value.</description>
            </item>
            <item>
            	<description>Greater than zero</description>
            	<description>This instance is greater than value, or value is <see langword="null"/>.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if type is not a <see cref="T:Hca.Common.DataType.Date"/></exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_GreaterThan(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.DataType.Date"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>Date</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_LessThan(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.DataType.Date"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_GreaterThanOrEqual(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.DataType.Date"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_LessThanOrEqual(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.DataType.Date"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.DataType.Date.Equals(System.Object)">
            <summary>
            Overrides the Equals method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Boolean: whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_Equality(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Overloads the == operator
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.DataType.Date"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.DataType.Date"/> object to compare.</param>
            <returns>Boolean: whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.op_Inequality(Hca.Common.DataType.Date,Hca.Common.DataType.Date)">
            <summary>
            Overloads the != operator
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.DataType.Date"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.DataType.Date"/> object to compare.</param>
            <returns>Boolean: whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.Date.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all
            of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly
            the same values.
            </remarks>
            <returns>The HashCode of the object's concatenated values.</returns>
        </member>
        <member name="P:Hca.Common.DataType.Date.Year">
            <summary>
            Gets the year component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Date.Month">
            <summary>
            Gets the month component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Date.Day">
            <summary>
            Gets the day of the month represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Date.DayOfWeek">
            <summary>
            Gets the day of the week represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Date.DayOfYear">
            <summary>
            Gets the day of the year represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.Date.RawText">
            <summary>
            Provides the textual view of <see cref="T:Hca.Common.DataType.Date"/> in the "yyyy-MM-dd" format
            </summary>
            <remarks>
            This class is intended to be immutable and not updated via this property. It is only provided
            to allow fine grain control for XML serialization. There is not other way
            to achieve this control with .NET 1.1. .NET 2.0 provides support for mixing
            XML attributes and <see cref="T:System.Xml.Serialization.IXmlSerializable"/> methods.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.Date.InternalValue">
            <summary>The property accessor for the true value that stores the date.</summary>
        </member>
        <member name="T:Hca.Common.DataType.DateConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.DataType.Date"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.DataType.Date"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <c>string</c>, <see cref="T:Hca.Common.DataType.Date"/>, or <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is string or assignable from <see cref="T:Hca.Common.DataType.Date"/> or <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.DateConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.DateConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.DateConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.DataType.Date"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	The <see cref="N:Hca.Common.DataType"/> namespace contains HCA specific data 
            	types similar to .NET's <see cref="T:System.String"/>, <see cref="T:System.Collections.Hashtable"/>, 
            	<see cref="T:System.Boolean"/>, etc. HCA's data types are rich objects designed to be contained by still richer value or transfer 
            	objects. For example, a patient usually has many addresses and phone numbers. Some of these data types augment 
            	.NET's data type implementations like <see cref="T:Hca.Common.DataType.Date"/> augments <see cref="T:System.DateTime"/>. 
            	Other types have no equivalent objects in .NET, such as <see cref="T:Hca.Common.DataType.PersonName"/>. These new data 
            	types make the code more robust. Some scenarios might not be needed in all circumstances. For example, you might not 
            	need to store postal zip code with the plus-4 part. In this case, it can be left out. However, if your requirements 
            	change, this property is available. The goal is to have new data types that are rich enough to handle most scenarios.
            	<para/>
            	All data types contained in the <see cref="N:Hca.Common.DataType"/> namespace inherit 
            	from a base class named <see cref="T:Hca.Common.DataType.DataTypeBase"/>. 
            	The main purpose of this class is to provide an inheritance placeholder for future behavior abstraction as well 
            	as support for current codified behavior.
            	<list type="bullet">
            		<item>
            			<see cref="T:Hca.Common.DataType.PhoneNumber"/> and <see cref="T:Hca.Common.DataType.Address"/> are examples 
            			of codified data types.
            		</item>
            		<item>
            			Codified data types contain fields that are keys. These keys are usually a value in a lookup table. 
            			The key is persistent, referenced by other objects, and not the displayed lookup value. This provides 
            			flexibility because the actual display text for this key is decoupled from the key and can change if 
            			needed.
            		</item>
            		<item>
            			<see cref="T:Hca.Common.DataType.DataTypeBase"/> manages the relationship with code renderers, which helps 
            			classes with codified fields. Code renderers implement <see cref="T:Hca.Common.DataType.ICodeRenderer"/>.
            		</item>
            		<item>
            			The code renderer used by the data type is determined by a <see crf="Hca.Common.Service"/> configuration. 
            			The <see crf="Hca.Common.Service"/> framework allows the data types to abstract themselves from the code renderer.
            		</item>
            		<item>
            			Each codified data type passes in a context that is unique for its codified property. For example, 
            			<see cref="T:Hca.Common.DataType.PhoneNumber"/> has a property named 
            			<see cref="P:Hca.Common.DataType.PhoneNumber.DeviceTypeId"/> that represents 
            			the phone number's device (land line, fax, cell, etc.). The unique context for this field is 
            			"Hca.Common.DataType.PhoneNumber.DeviceType".
            			<para/>
            			<see cref="T:Hca.Common.DataType.PhoneNumber"/> also has a property 
            			named <see cref="P:Hca.Common.DataType.PhoneNumber.DeviceTypeDisplayText"/>. This property provides 
            			the display text value for the key or codified value <c>deviceTypeId</c>. It takes 
            			into consideration the current culture, the key's context, and the key itself as it passes this information 
            			to the base class to determine the text displayed.
            		</item>
            		<item>
            			The base class uses <see crf="Hca.Common.Service"/> to retrieve a code renderer for a given context. If a code renderer 
            			is not found, then the base class will try and find one with no context. If a code renderer is not found, 
            			then a default code renderer will be used. The default code renderer returns the key as the display text. 
            			For new applications, the code renderer should be Code Management Facility's code provider and it should 
            			be defined with no context, indicating that it should be used for all contexts that are not explicitly 
            			defined. This pattern allows you to define multiple code renderers in situations where Code Management 
            			Facility is not appropriate and there is legacy code or it interacts with other systems.
            		</item>
            	</list>
            	<para/>
            	<img src="datatype_uml.gif"/>
            	<br/>
            	<i>Figure 1: DataTypeBase</i>
            
            	<h2 class="dtH2">Address, TextAddress, PersonName, PhoneNumber, TextPhoneNumber</h2>
            	<h3 class="dtH3">Overview</h3>
            	These classes are custom data types that represent a mailing address, a person's name, and a phone number.  
            	Applications use these classes when the concept is needed within a class or by that application. This ensures 
            	that the same data elements are used across different applications and facilitates consistent persistence of 
            	these concepts.
            
            	<h3 class="dtH3">Requirements</h3>
            	These classes need to represent all essential elements of each data type.  Properties in these classes that 
            	are implemented by a primitive value type must support the <i>not set</i> state so that they can be used 
            	appropriately where partial updates are performed on the class. These classes are not intended to be used 
            	directly as value objects and do not inherit from <see cref="T:Hca.Common.BaseType.ValueObjectBase"/>. However, 
            	like any other standard data type, they can be used as parts of value objects. 
            	<hcaNote>
            		For more information about value objects, see <see cref="N:Hca.Common.BaseType"/>.
            	</hcaNote>
            	<para/>
            
            	<h3 class="dtH3">Tenets</h3>
            	<see cref="T:Hca.Common.DataType.Address"/> and <see cref="T:Hca.Common.DataType.PhoneNumber"/> have  properties that are <i>codified</i>. 
            	This means that their values are codes that cross-reference 
            	to literal values. This codification is a means to abstract the concept from the actual usage in code. 
            	Consequently, the information it conveys can change over time without affecting the existing use of the 
            	codified value. 
            	
            	<h3 class="dtH3">Usage</h3>
            	These classes maintain address, name, and phone number information.  They should be treated 
            	as standard data objects.
            
            	<h4 class="dtH4">Configuration</h4>
            	Codified values must have some code-to-text lookup functionality and/or configuration.  <see cref="N:Hca.Common.DataType"/> classes rely on an 
            	<see cref="T:Hca.Common.DataType.ICodeRenderer"/> to supply the code-to-text functionality. This 
            	renderer should be configured through ServiceFactory.
            	<para/>
            	The <see cref="T:Hca.Common.DataType.ICodeRenderer"/> configuration example shows a configuration for Code Provider 
            	which is the recommended code renderer. This configuration does not have a context defined 
            	so this renderer would be the default for all contexts. You can define specific renders 
            	for different contexts like location, state, country, county, etc. <see cref="T:Hca.Common.DataType.Address"/> type asks for 
            	a code renderer for the following contexts:
            	<list type="bullet">
            		<item>Location</item>
            		<item>State</item>
            		<item>Country</item>
            		<item>County</item>
            	</list>
            	<see cref="T:Hca.Common.DataType.PhoneNumber"/> type asks for a code renderer for the following contexts:
            	<list type="bullet">
            		<item>DeviceType</item>
            		<item>Location</item>
            	</list> 
            	If a renderer is not returned then it will look for a renderer with no context and finally 
            	use its own renderer if none is found.
            	<para/>
            	<hcaExample desc="CodeRenderer Configuration">
            		<code>
            <![CDATA[<config type="Hca.Common.Service.ServiceConfig" readOnly="true">
            	<property name="Interface" value="Hca.Common.DataType.ICodeRenderer"/>
            	<property name="Creator" value="Hca.Common.Service.SingletonTypeCreator"/>
            	<propertyDictionary name="Arguments" type="System.Collections.Hashtable" 
            			defaultKeyType="System.String" defaultValueType="System.Object">
            		<item>
            			<key type="System.String" value="type"/>
            			<value type="System.Type" value="Hca.Facility.CodeManagement.CodeProvider"/>
            		</item>
            	</propertyDictionary>
            </config>]]>
            		</code>
            	</hcaExample>
            
            	<h3 class="dtH3">Best Practices</h3>
            	Typically, it's best to set the data values through the constructor, though there is nothing 
            	specifically wrong with setting the values through the property accessors.
            	<para/>
            	Each class implements <see cref="T:System.IFormattable"/>, which consists of a specialized <c>ToString</c> 
            	method. The format parameter can be used to specify the data elements included in the string.  
            	Each class also has standard formatting selections. See the API documentation for complete 
            	details.  There are select examples below.
            
            	<h2 class="dtH2">Date and Time</h2>
            	<h3 class="dtH3">Overview</h3>
            	<see cref="T:System.DateTime"/> in the .NET framework does not store information 
            	about the time zone. The class assumes that the time is always in the local time zone (the 
            	time zone that the machine's operating system is set). It's very possible that the time zone 
            	is not set the same on all servers in the network. Storing a date and time as Eastern or 
            	Central time can lead to confusion and mishandling.
            	<para/>
            	On the other hand, when dealing with date-only values, there is no guarantee that the 
            	time values are not valued unless the developer takes care to prevent valuation. These 
            	issues result in extra code being written for each usage of <see cref="T:System.DateTime"/>, 
            	especially when dates and time are persistent.  
            	<para/>
            	<see cref="N:Hca.Common"/> provides four classes that work together to solve these problems: 
            	<see cref="T:Hca.Common.DataType.Date"/>,	<see cref="T:Hca.Common.DataType.UtcDateTime"/>, 
            	<see cref="T:Hca.Common.DataType.TimeOfDay"/>, and <see cref="T:Hca.Common.DataType.TimeZoneInfo"/>. 
            	These are found in this namespace.
            	<para/>
            	Per the schema <a target="_blank" href="http://hcaschema.hca.corpad.net/Common/DataType/1.0/DataTypeSchema.xsd">http://hcaschema.hca.corpad.net/Common/DataType/1.0/DataTypeSchema.xsd</a>, XML serialization 
            	of these classes conform to the XSD datatypes date, time, and datetime. 
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.PersonName">
            <summary>
            This class handles the elements of a person's name.
            Currently, it only handles basic names (first middle last)
            as well as prefixes (Mr., Dr., etc.) and suffixes (Jr., DDS, etc.)
            </summary>
            <remarks>
            
            	<see cref="T:Hca.Common.DataType.PersonName"/> data elements are stored as strings and can be set and retrieved through properties. 
            	They can also be set through the overloaded constructor. If it is determined later that HCA 
            	usage required that the prefix or suffix values needs restriction, these values can be 
            	changed to a codified value. However, until this need is recognized, it is more useful to 
            	treat them as string values.
            
            			<see cref="T:Hca.Common.DataType.PersonName"/> attributes include:
            			<list type="bullet">
            				<item>Prefix (Dr., Mr., etc.)</item>
            				<item>First Name, Middle Name, Last Name</item>
            				<item>Suffix (DDS, Jr., etc.)</item>
            			</list>
            </remarks>
            <example>
            	Example that illustrates how to set values using the constructor:
            	<para/>
            	<hcaExample desc="Instantiating a PersonName">
            		<code>
            PersonName name = new PersonName ("John", "David", "Smith");
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to set values using the properties:
            	<para/>
            	<hcaExample desc="PersonName Property Usage">
            		<code>
            PersonName name = new PersonName ();
            name.FirstName = "John";
            name.MiddleName = "David";
            name.LastName = "Smith";
            name.Prefix = "Dr.";
            name.Suffix = "III";
            
            PersonName name2 = new PersonName ();
            name2.FirstName = "Susan";
            name2.MiddleName = "Elizabeth Courtney Joan";
            name2.LastName = "Smith-Barney";
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to format the object into a string (Refer to the API guide for 
            	available format options.)  This method generates a normal name (first middle last).
            	<para/>
            	<hcaExample desc="Using the IFormattable ToString of PersonName">
            		<code>
            string output = name.ToString("N", System.Globalization.CultureInfo.CurrentCulture);
            // returns: John David Smith
            		</code>
            	</hcaExample>
            </example>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.PersonName"/>.</overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.PersonName.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor that takes the main parts of a person's name.
            </summary>
            <param name="firstName">The person's first name</param>
            <param name="middleName">The person's middle name</param>
            <param name="lastName">The person's last name</param>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Constructor that takes the main parts of a person's name.
            </summary>
            <param name="firstName">The person's first name</param>
            <param name="middleName">The person's middle name</param>
            <param name="lastName">The person's last name</param>
            <param name="prefix">The person's name prefix</param>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Constructor that takes the main parts of a person's name.
            </summary>
            <param name="firstName">The person's first name</param>
            <param name="middleName">The person's middle name</param>
            <param name="lastName">The person's last name</param>
            <param name="prefix">The person's name prefix</param>
            <param name="suffix">The person's name suffix</param>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.#ctor(Hca.Common.DataType.PersonName)">
            <summary>
            Copy constructor
            </summary>
            <param name="personName">A populated <see cref="T:Hca.Common.DataType.PersonName"/> to copy.</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if <paramref name="personName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.Populate(Hca.Common.DataType.PersonName)">
            <summary>
            Populates the current object with the values from <paramref name="personName"/>
            </summary>
            <param name="personName"></param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if <paramref name="personName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.ToString">
            <overloads>Returns a string representation of the current object.</overloads>
            <summary>
            Calls <see cref="M:Hca.Common.DataType.PersonName.ToString(System.String,System.IFormatProvider)"/> with null for the format and 
            current culture for the provider so the default is used.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.ToString(System.String,System.IFormatProvider)">
            <summary>
            This method provides specialized formatting of a <see cref="T:Hca.Common.DataType.PersonName"/> based
            on the passed character(s) in the format argument.
            </summary>
            <remarks>
            The format can be specified in two different ways.
            <p>
            <b>Standard Formats</b><br/>
            The first way is by specifying one of the "Standard Formats":
            <list type="table">
            <item>
            <term>G or g (General)</term>
            <description>Default if not specified. First Last (i.e. John Smith)</description>
            </item>
            <item>
            <term>N (Normal)</term>
            <description>First Middle Last (i.e. John Thomas Smith)</description>
            </item>
            <item>
            <term>I (Inverted: Last Name first)</term>
            <description>Last, First Middle (i.e. Smith, John Thomas)</description>
            </item>
            <item>
            <term>C (Complete)</term>
            <description>Prefix First Middle Last Suffix (i.e. Dr. John Thomas Smith III)</description>
            </item>
            </list>
            </p>
            <p>
            <b>Custom Formats</b><br/>
            The second way is by specifying the name segments using these identifiers.<br></br>
            Note: An Upper case character will display the full name segment.  
            A Lower case for F, M and L tokens will display the initial character of 
            the name segment followed by a period. For example, John would be <b>J.</b>.
            
            <list type="table">
            <item>
            <term>{P}</term>
            <description>Prefix (i.e. Dr., Mrs., Sir, etc.)</description>
            </item>
            <item>
            <term>{F}</term>
            <description>First Name</description>
            </item>
            <item>
            <term>{M}</term>
            <description>Middle Name</description>
            </item>
            <item>
            <term>{L}</term>
            <description>Last Name</description>
            </item>
            <item>
            <term>{S}</term>
            <description>Suffix (i.e. Jr., III, etc.)</description>
            </item>
            </list>
            </p>
            Any unrecognized characters are repeated back into the output
            string as specified in the format string for the custom format.
            
            If the format provided is not a standard format and none of the 
            custom characters are recognized, the returned string is the 
            format string as provided.
            
            The <b>{</b> is treated as a delimiter of sorts and hence if you
            desire it to be in the output as a literal, you must escape it with
            a second left or right brace<b>{ or }</b> character. For example:
            <code>
            	"{{F}"
            </code>
            will yield a parsed pattern of only the <b>{F</b> literal since the 
            double left brace are consumed together. Instead, to have this appear
            as a brace followed by the <b>{F}</b> token,  add a second left brace to the 
            string. For example:
            <code>
            	"{{{F}"
            </code>
            will yield a parsed pattern of a literal { followed by the F token i.e.,
            <b>{&lt;F Token Value&gt;</b>.
            <p/>
            Finally, to make this happen internally, we use unicode 0 and 1
            as temporary replacement tokens. Hence these cannot be used as
            literal values in the format string. Given that these are not
            printable characters and this method is to generate a printable
            string, this is not a problem.
            </remarks>
            <example>
            Standard Format
            <code>
            PersonName somePersonName = new PersonName("John", "Thomas", "Smith");
            
            string myName = somePersonName.ToString("N", System.Globalization.CultureInfo.CurrentCulture);
            returns: John Thomas Smith
            
            myName = String.Format("My name is {0:G}.", somePersonName);
            returns: My name is John Smith.
            </code>
            Custom Format
            <code>
            PersonName somePersonName = new PersonName("John", "Thomas", "Smith");
            
            string myName = somePersonName.ToString("{L}, {F} {m}.", System.Globalization.CultureInfo.CurrentCulture);
            returns: Smith, John T.
            </code>
            </example>
            <param name="format">The format string</param>
            <param name="formatProvider">Not currently used.</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if Unicode character 0 or 1 is included in the 
            format string.</exception>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.CompareTo(System.Object)">
            <summary>
            Two <see cref="T:Hca.Common.DataType.PersonName"/>s compare equal if their <see cref="T:System.IFormattable"/> forms compare equal.
            Use the <see cref="P:Hca.Common.DataType.PersonName.ComparableFormat"/> to set the desired comparison. If no comparison
            is specified, then the <em>I</em> format is used. 
            </summary>
            <remarks>
            The format set for the called on object is used for both compared 
            objects. For example:
            <code>
            PersonName name1 = new PersonName("First", "Last");
            name1.ComparableFormat = "I";
            PersonName name2 = new PersonName("First", "Last");
            name2.ComparableFormat = "N";
            name1.CompareTo(name2);
            </code>
            uses the <em>I</em> comparable format for comparison ordering which
            in this case is last name, middle name, first name.
            </remarks>
            <param name="obj">The object to compare with this instance.</param>
            <returns>
            <list type="table">
            <listheader>
            	<term>Value</term>
            	<term>Description</term>
            </listheader>
            <item>
            	<description>Less than zero</description>
            	<description>This instance is less than value.</description>
            </item>
            <item>
            	<description>Zero</description>
            	<description>This instance is equal to value.</description>
            </item>
            <item>
            	<description>Greater than zero</description>
            	<description>This instance is greater than value, or value is <see langword="null"/>.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if type is not a <see cref="T:Hca.Common.DataType.PersonName"/></exception>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.Equals(System.Object)">
            <summary>
            Overrides the Equals method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_Equality(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Overloads the == operator
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.DataType.PersonName"/> to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.DataType.PersonName"/> to compare.</param>
            <returns>Boolean: whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_Inequality(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Overloads the != operator
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.DataType.PersonName"/> to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.DataType.PersonName"/> to compare.</param>
            <returns>Boolean: whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_GreaterThan(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Determine if one <see cref="T:Hca.Common.DataType.PersonName"/> is greater than another
            <see cref="T:Hca.Common.DataType.PersonName"/>. 
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_LessThan(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Determine if one <see cref="T:Hca.Common.DataType.PersonName"/> is less than another
            <see cref="T:Hca.Common.DataType.PersonName"/>. 
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_GreaterThanOrEqual(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Determine if one <see cref="T:Hca.Common.DataType.PersonName"/> is greater than or equal to another
            <see cref="T:Hca.Common.DataType.PersonName"/>. 
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.op_LessThanOrEqual(Hca.Common.DataType.PersonName,Hca.Common.DataType.PersonName)">
            <summary>
            Determine if one <see cref="T:Hca.Common.DataType.PersonName"/> is less than or equal to another
            <see cref="T:Hca.Common.DataType.PersonName"/>. 
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.PersonName.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all
            of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly
            the same values.
            </remarks>
            <returns>The HashCode of the object's concatenated values.</returns>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.Prefix">
            <summary>
            Any prefix designation (e.g. Dr, Mr, Ms, etc.) If an application needs
            codification of this value, it should derive from this type and add 
            this semantics.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.FirstName">
            <summary>
            The given name of a person
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.MiddleName">
            <summary>
            The middle name of a person
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.LastName">
            <summary>
            The surname of a person
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.Suffix">
            <summary>
            Any suffix designation such as Jr, II, III etc. If an application needs
            codification of this value, it should derive from this type and add 
            this semantics. 
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PersonName.ComparableFormat">
            <summary>
            Set the format that should be used when comparing one <see cref="T:Hca.Common.DataType.PersonName"/>
            to another.
            </summary>
            <remarks>
            Refer to the <see cref="T:System.IFormattable"/> options for determining the valid options.
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.PhoneNumber">
            <summary>
            Phone number class provides codified properties for DeviceType and Location.
            Use <see cref="T:Hca.Common.DataType.TextPhoneNumber"/> class if you need non-codified properties. See <see cref="T:Hca.Common.DataType.PhoneNumberBase"/>
            for more detail.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            When a phone number is parsed or set the following attributes are not 
            effected and must be set via the corresponding property.
            <list type="bullet">
            	<item>location</item>
            	<item>deviceType</item>
            	<item>effectionDate</item>
            	<item>endDate</item>
            </list>
            NOTES:
            <list type="bullet">
            	<item>Extra attributes (e.g. location) are not considered when parsing</item>
            	<item>Extra attributes are not shown in the default display form.</item>
            	<item>Extra attributes are not serialized when sent to an xml stream.</item>
            </list>
            <p/>
            Code providers should provide for the following contexts:
            <list type="bullet">
            <item>Location - Hca.Common.DataType.PhoneNumber.Location</item>
            <item>DeviceType - Hca.Common.DataType.PhoneNumber.DeviceType</item>
            </list>
            <see cref="T:Hca.Common.DataType.PhoneNumberConverter"/> is associated with this type allowing two-way conversion. 
            <seealso cref="T:System.ComponentModel.TypeConverter"/>
            </remarks>
            <example>
            	Example that illustrates how to set values using the properties:
            	<para/>
            	<hcaExample desc="Property Usage">
            		<code>
            // Creating a phone number from a string.
            PhoneNumber number = new PhoneNumber("1-615-555-1212");
            
            // Creating a phone number from an alpha-numeric string.
            PhoneNumber number3 = new PhoneNumber("1-800-Flowers");
            string alias =  number3.Alias;	// alias = "1-800-Flowers"
            string dialable = number3.GetDisplayForm(false);	// dialable = "1 800-356-9377"
            
            // Creating a phone number using the phone number segments.
            PhoneNumber number4 = new PhoneNumber(1, "615", "555", "1212", false);
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to format the object into a string. This method generates a phone 
            	number in the standard format. Refer to the API guide for available format options.
            	<para/>
            	<hcaExample desc="Using the IFormattable ToString of PhoneNumber">
            		<code>
            PhoneNumber number = new PhoneNumber("1-800-Flowers");
            string output = number.ToString("N", CultureInfo.CurrentCulture);
            //returns: (800) 356-9377
            
            string output = number.ToString("{AL}", CultureInfo.CurrentCulture);
            // returns: 1-800-FLOWERS
            		</code>
            	</hcaExample>
            </example>
        </member>
        <member name="T:Hca.Common.DataType.PhoneNumberBase">
            <summary>
            This class represents a phone number. It supports both North American and
            International formats. See <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/>
            and <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/>
            for exact details of supported formats.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            	<see cref="T:Hca.Common.DataType.PhoneNumberBase"/> is an <see langword="abstract"/> base class for the 
            	codified <see cref="T:Hca.Common.DataType.PhoneNumber"/> and textual <see cref="T:Hca.Common.DataType.TextPhoneNumber"/>. 
            	<see cref="T:Hca.Common.DataType.PhoneNumber"/> is intended for use when applications have control over the data entry of 
            	codified items <see cref="P:Hca.Common.DataType.PhoneNumber.DeviceTypeId"/> and <see cref="P:Hca.Common.DataType.PhoneNumber.LocationId"/>. <see cref="T:Hca.Common.DataType.TextPhoneNumber"/>
            	is intended for use in applications that cannot provide legal codes for these items and text values 
            	may substituted in their place. 
            	<para>
            	These classes parse and validate a phone number string.  They can accept the phone number 
            	segments separately or translate an alpha-numeric alias such as <i>1-800-Collect</i>. They can 
            	parse North American and International numbers.</para>
            	<hcaNote>
            	These classes will not allow an invalid phone number to be entered. 
            	Use a regular string if you must store an invalid phone number.
            	</hcaNote>
            	<para/>
            			<see cref="T:Hca.Common.DataType.PhoneNumber"/> and <see cref="T:Hca.Common.DataType.TextPhoneNumber"/> share 
            			these attributes:
            			<list type="bullet">
            				<item>Country Code, Area Code, Prefix, Local Number, and Extension</item>
            				<item>Device Type (cell, fax, landline, etc.)</item>
            				<item>Alias (i.e. 1-800-FLOWERS)</item>
            				<item>Dates when it starts and stops being valid</item>
            			</list>
            			<see cref="T:Hca.Common.DataType.PhoneNumber"/> also contains the following codified attributes:
            			<list type="bullet">
            				<item>Device Type Id (cell, fax, landline, etc.)</item>
            				<item>Location Id (home, business, etc.)</item>
            			</list>
            			<see cref="T:Hca.Common.DataType.TextPhoneNumber"/> also contains the following attributes:
            			<list type="bullet">
            				<item>Device Type Text</item>
            				<item>Location Text</item>
            			</list>
            	<para/>
            	The semantics of properties that are not obvious is described in the Table below.
            	<para/>
            	<i><see cref="T:Hca.Common.DataType.PhoneNumber"/> Property Semantics</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Property</th>
            				<th width="80%">Usage</th>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.CountryCode"/></td>
            				<td>
            					The assigned digit(s) used to dial into a country from another country 
            					(e.g. 1 is for US and 44 is for the UK).
            				</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.Prefix"/></td>
            				<td>
            					The part of a phone number that indicates the central office of the local 
            					number within a country. Not all countries use a prefix.
            				</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumber.LocationId"/></td>
            				<td>A designation for the location of the phone number (e.g., Business, Home, etc.)</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.LocationDisplayText"/></td>
            				<td>The displayable text of the location ID.</td>
            			</tr>
            			<tr>	
            				<td><see cref="P:Hca.Common.DataType.PhoneNumber.DeviceTypeId"/></td>
            				<td>A designation for the device that holds the phone number (e.g., land line, fax, cell, etc.)</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.DeviceTypeDisplayText"/></td>
            				<td>The displayable text of the device type ID.</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.EffectiveDate"/></td>
            				<td>When the phone number becomes valid for use.</td>
            			</tr>
            			<tr>	
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.EndDate"/></td>
            				<td>When the phone number becomes invalid for use.</td>
            			</tr>
            			<tr>
            				<td><see cref="P:Hca.Common.DataType.PhoneNumberBase.Alias"/></td>
            				<td>
            					This is not directly settable by a client but represents a textual version 
            					of the real phone number as entered when created. This is often the case 
            					for marketing purposes.
            				</td>
            			</tr>
            		</table>
            	</div>
            
            <para/>
            When a phone number is parsed or set the following 
            attributes are not effected and must be set via the corresponding property.
            <list type="bullet">
            	<item>effectionDate</item>
            	<item>endDate</item>
            </list>
            NOTES:
            <list type="bullet">
            	<item>Extra attributes (e.g. location) are not considered when parsing</item>
            	<item>Extra attributes are not shown in the default display form.</item>
            	<item>Extra attributes are not serialized when sent to an xml stream.</item>
            </list>
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.#ctor">
            <overloads>Initializes a new instance of a <see cref="T:Hca.Common.DataType.PhoneNumberBase"/>.</overloads>
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor that takes typical parts of the number. This treats the number
            as a North American number
            </summary>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.#ctor(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Constructor that takes typical parts of the number for both 
            international and North American.
            </summary>
            <param name="countryCode">the value of the country code</param>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.#ctor(System.String)">
            <summary>
            Constructor that takes a sting for the number and parses as a north american 
            number. If international number is desired to be parsed, call Constructor that
            takes the North American flag.
            </summary>
            <param name="phoneNumber">string value of phone number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor that takes a string representation of the phone number. This is
            parsed into the appropriate parts. 
            </summary>
            <remarks>
            If the format is non-determinate or invalid, a runtime exception is thrown. If <see langword="null"/> is passed, 
            this Constructor acts as if the default Constructor was called. Rules for parsing are contained
            in the regular expression library <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> and 
            <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/>.
            </remarks>
            <param name="phoneNumber">string value of phone number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.internationalFlag">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.IsInternational"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.countryCode">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.CountryCode"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.areaCode">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.AreaCode"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.prefix">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.Prefix"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.localNumber">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.LocalNumber"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.extension">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.Extension"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.effectiveDate">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.EffectiveDate"/>
            Defaults: Instantiation Date
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.endDate">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.EndDate"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumberBase.alias">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumberBase.Alias"/>
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.ValidateForMandatoryFields">
            <summary>
            Validates for mandatory fields.
            </summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.ParsePhoneNumber(System.String,System.Boolean)">
            <summary>
            Helper method to parse phone number into this object from a string.
            </summary>
            <remarks>
            This function always modifies these properties:
            	internationalFlag
            	countryCode
            	areaCode
            	prefix
            	localNumber
            	extension
            This function does not set or modify these properties:
            	location
            	deviceType
            	effectionDate
            	endDate
            If <see langword="null"/> is passed, an Exception is thrown, <see langword="null"/> the reference
            if the desire is to remove the phone number.
            </remarks>
            <param name="phoneNumber">String with phone number</param>
            <param name="isNorthAmerican"><see langword="true"/> if north american format.</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.ToString">
            <summary>
            Returns object as a string using the "G" format string and the current culture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberBase.ToString(System.String,System.IFormatProvider)">
            <summary>
            This method provides specialized formatting of a <see cref="T:Hca.Common.DataType.PhoneNumber"/> based
            on the passed character(s) in the format argument.
            </summary>
            <remarks>
            The format can be specified in two different ways.
            <p>
            <b>Standard Formats</b><br/>
            The first way is by specifying one of the "Standard Formats":
            <list type="table">
            <item>
            <term>G or g (General)</term>
            <description>
            Default if not specified.   For North American phone numbers standard will be
            Country Code, Area Code, Prefix, and Local Number : X-XXX-XXX-XXXX
            International numbers will add a + to the country code which can be up to 3 digits.
            </description>
            </item>
            <item>
            <term>N (Normal)</term>
            <description>
            North American
            Area Code, Prefix, and Local Number : (XXX) XXX-XXXX
            International
            Country Code, Area Code, Prefix, and Local Number (the number of digits can vary and only Country code and
            local number are certain to be valued.
            </description>
            </item>
            <item>
            <term>X (Normal + extension)</term>
            <description>(default if not specified)   Area Code, Prefix, Local Number, and Extension : (XXX) XXX-XXXX ext. XXX</description>
            </item>
            <item>
            <term>F (Full)</term>
            <description>Country Code, Area Code, Prefix, Local Number, and Extension : XXX-XXX-XXX-XXXX ext. XXX</description>
            </item>
            <item>
            <term>S (Short)</term>
            <description>
            North American:
            Prefix, and Local Number : XXX-XXXX
            International:
            Prefix if specified and Local Number.
            </description>
            </item>
            </list>
            </p>
            <p>
            <b>Custom Formats</b><br/>
            The second way is by specifying the phone number segments using these identifiers.<br></br>
            <b>Note"</b>These codes are case insensitive.<br></br>
            <list type="table">
            <item>
            <term>{C}</term>
            <description>Country Code without any prefix(even for international numbers)</description>
            </item>
            <item>
            <term>{A}</term>
            <description>Area Code</description>
            </item>
            <item>
            <term>{P}</term>
            <description>Prefix</description>
            </item>
            <item>
            <term>{L}</term>
            <description>Local Number</description>
            </item>
            <item>
            <term>{E}</term>
            <description>Extension</description>
            </item>
            <item>
            <term>{AL}</term>
            <description>Alias, if not assigned, then the N format is used.</description>
            </item>
            </list>
            </p>
            </remarks>
            <example>
            Standard Format
            <code>
            PhoneNumber somePhoneNumber = new PhoneNumber(1, "615", "555", "1212", false);
            somePhoneNumber.Extension = "444";
            
            string myNum = somePhoneNumber.ToString("N", System.Globalization.CultureInfo.CurrentCulture);
            returns: (615) 555-1212
            
            myNum = String.Format("{0:N}");
            returns: 1-615-555-1212
            </code>
            
            Custom Format
            <code>
            PhoneNumber somePhoneNumber = new PhoneNumber(1, "615", "555", "1212", false);
            somePhoneNumber.Extension = "444";
            
            string myNum = somePhoneNumber.ToString("{P}-{L} ex:{E}", System.Globalization.CultureInfo.CurrentCulture);
            returns: 555-1212 ex:444
            </code>
            
            Alias
            <code>
            PhoneNumber somePhoneNumber = new PhoneNumber("1-800-FLOWERS");
            string myNum = somePhoneNumber.ToString("{AL}", System.Globalization.CultureInfo.CurrentCulture);
            returns: 1-800-FLOWERS
            
            myNum = somePhoneNumber.ToString("N", System.Globalization.CultureInfo.CurrentCulture);
            returns: (800) 356-9377
            </code>
            </example>
            <param name="format">The format string</param>
            <param name="formatProvider">format provider to use</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if Unicode character 0 or 1 is included in the 
            format string.</exception>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.DeviceTypeDisplayText">
            <summary>
            The displayable text for the <c>deviceType</c> code. The actual
            value returned is determined by the implementation of the 
            code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.LocationDisplayText">
            <summary>
            The displayable text for the <c>location</c> code. The actual
            value returned is determined by the implementation of the 
            code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.IsInternational">
            <summary>
            If <see langword="true"/>, this flag indicates that this number was parsed or entered as an
            international number.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.CountryCode">
            <summary>
            The country code of a phone number (for example, 1 for United states of
            America). This is used when dialing to a foreign country but is not
            necessary when dialing within that country. Formats of international 
            numbers usually include a + as a prefix to the country code (e.g. +44 for
            UK). This number is 3 digits in length
            </summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.AreaCode">
            <summary>
            The area code or city code if international. This number is optionally 
            surrounded by parenthesis. For North American numbers this is a three digit
            number (with expansion to 4 when new number format is introduced). 
            International codes vary in length.
            Note: reason for string here is that we don't want to loose a zero
            </summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.Prefix">
            <summary>
            The prefix (central office) of the local number. May be <see langword="null"/> in countries 
            that do not have central office concept. Note: the combination of the 
            prefix and local number is called the subscriber number. Currently in 
            north america this is a 3 digit number where the first digit is 
            restricted to 2-9 digits. However, their is an industry proposal to move
            to a new format which is in the process of being implemented that expands 
            this number to 4 digits with the evidential removal of the 0, 1 
            restriction to the old first digit.
            Note: reason for string here is that we don't want to loose a zero
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.LocalNumber">
            <summary>
            The local (line) number. In North America this is a 4 digit number.
            International numbers may vary in size though no more than 12 digits.
            Those countries that don't have prefix needs, have this as the sole 
            part of the subscriber number
            Note: reason for string here is that we don't want to loose a zero
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.Extension">
            <summary>
            The extension at the local number.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.EffectiveDate">
            <summary>
            The date that this Phone Number is available for use.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.EndDate">
            <summary>
            The date that this Phone Number is no longer available for use.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.Alias">
            <summary>
            The Alpha-Numeric version of the number (ex. 1-800-FLOWERS).
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.RawText">
            <summary>
            Provides the textual view of <see cref="T:Hca.Common.DataType.PhoneNumber"/> in the "F" format
            </summary>
            <remarks>
            This class is intended to be immutable and not updated via this property. It is only provided
            to allow fine grain control for XML serialization. There is not other way
            to achieve this control with .NET 1.1. .NET 2.0 provides support for mixing
            XML attributes and <see cref="T:System.Xml.Serialization.IXmlSerializable"/> methods.
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.IsInternational">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.RawPhoneNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.NumericPhoneNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.Alias">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.CountryCode">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.AreaCode">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.Prefix">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.LocalNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumberBase.ParsedPhoneNumber.Extension">
            <summary>
            extension
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumber.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.PhoneNumber"/>.</overloads>
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumber.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor that takes typical parts of the number. This treats the number
            as a North American number
            </summary>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumber.#ctor(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Constructor that takes typical parts of the number for both 
            international and North American.
            </summary>
            <param name="countryCode">the value of the country code</param>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumber.#ctor(System.String)">
            <summary>
            Constructor that takes a sting for the number and parses as a north american 
            number. If international number is desired to be parsed, call Constructor that
            takes the North American flag.
            </summary>
            <param name="phoneNumber">string value of phone number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumber.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor that takes a string representation of the phone number. This is
            parsed into the appropriate parts. 
            </summary>
            <remarks>
            If the format is non-determinate or invalid, a runtime exception is thrown. If <see langword="null"/> is passed, 
            this Constructor acts as if the default Constructor was called. Rules for parsing are contained
            in the regular expression library <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> and 
            <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/>.
            </remarks>
            <param name="phoneNumber">string value of phone number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumber.locationId">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumber.LocationId"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.PhoneNumber.deviceTypeId">
            <summary>
            <see cref="P:Hca.Common.DataType.PhoneNumber.DeviceTypeId"/>
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumber.LocationId">
            <summary>
            What type of number this is (e.g. Business, Home, Vacation, etc.)
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumber.LocationDisplayText">
            <summary>
            The displayable text for the <c>location</c> code. The actual
            value returned is determined by the implementation of the 
            code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumber.DeviceTypeId">
            <summary>
            The type of device this represents (e.g. land line, fax, cell, etc.)
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.PhoneNumber.DeviceTypeDisplayText">
            <summary>
            The displayable text for the <c>deviceType</c> code. The actual
            value returned is determined by the implementation of the 
            code provider that is registered.
            </summary>
            <remarks>
            Returns the current display text for the current culture for this context.
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.PhoneNumberConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.DataType.PhoneNumber"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.DataType.PhoneNumber"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <c>string</c> or <see cref="T:Hca.Common.DataType.PhoneNumber"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is string or assignable from <see cref="T:Hca.Common.DataType.PhoneNumber"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.PhoneNumberConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> can be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.PhoneNumberConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.PhoneNumberConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.DataType.PhoneNumber"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.TextAddress">
            <summary>
            This Concrete implementation of the <see cref="T:Hca.Common.DataType.AddressBase"/> class provides text-only
            representation of details about an address.
            </summary>
            <remarks>
            See <see cref="T:Hca.Common.DataType.AddressBase"/> remarks for additional information on when to use <see cref="T:Hca.Common.DataType.Address"/> as 
            opposed to <see cref="T:Hca.Common.DataType.TextAddress"/>.
            <para/>
            <b>TextAddress Property Semantics</b>
            <list type="table">
            	<listheader>
            		<term><b>Property</b></term>
            		<description><b>Usage</b></description>
            	</listheader>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.TextAddress.LocationText"/></term>
            		<description>
            			The place that is designated by the address such as home, business, etc.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.TextAddress.LocationDisplayText"/></term>
            		<description>The displayable text for the location.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.StateId"/></term>
            		<description>
            			The state of the address.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.TextAddress.StateDisplayText"/></term>
            		<description>The displayable text for the state.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountryId"/></term>
            		<description>
            			The country of the address.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.TextAddress.CountryDisplayText"/></term>
            		<description>The displayable text for the country.</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.Address.CountyId"/></term>
            		<description>
            			The county of the address.
            		</description>
            	</item>
            	<item>
            		<term><see cref="P:Hca.Common.DataType.TextAddress.CountyDisplayText"/></term>
            		<description>The displayable text for the county.</description>
            	</item>
            </list>
            </remarks>
            <example>
            Example that illustrates how to set values using the constructor.
            	<para/>
            	<hcaExample desc="Instantiating a TextAddress">
            		<code>		
            TextAddress b = new TextAddress("115 Center Street", "Apt.A", "Nashville", "37201", "TN", "Davidson", "USA", "Home");
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to set values using the property accessors.
            	<hcaExample desc="TextAddress Property Usage">
            		<code>
            TextAddress b = new TextAddress();
            b.StreetAddress = "115 Center Street";
            b.City = "Nashville"
            b.State = "TN";
            b.County = null;
            		</code>
            	</hcaExample>
            <para/>
            See <see cref="T:Hca.Common.DataType.Address"/> for <see cref="M:Hca.Common.DataType.AddressBase.ToString"/> examples.	
            </example>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.TextAddress"/>.</overloads>
            <summary>
            Default Constructor. See <see cref="T:Hca.Common.DataType.AddressBase"/> for more information
            on how the various fields are populated by default.
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(Hca.Common.DataType.TextAddress)">
            <summary>
            This constructor creates a new instance and uses the data from the specified
            <see cref="T:Hca.Common.DataType.TextAddress"/> to populate the new instance.
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.TextAddress"/> to 
            use to populate this instance.</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(Hca.Common.DataType.Address)">
            <summary>
            This constructor creates a new instance and uses the data from the specified
            <see cref="T:Hca.Common.DataType.Address"/> to populate the new instance.
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.Address"/> to 
            use to populate this instance.</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="state">The state of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="state">The state of the address.</param>
            <param name="country">The country of the address.</param>
            <param name="location">The address type such as 'cell' or 'landline'.</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="state">The state of the address.</param>
            <param name="county">The county in the state of the address.</param>
            <param name="country">The country of the address.</param>
            <param name="location">The address type such as 'cell' or 'landline'.</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This constructor creates a new address with the address elements specified.
            </summary>
            <param name="streetAddress">The street address.</param>
            <param name="addressLine2">The second line of the address.</param>
            <param name="city">The city of the address.</param>
            <param name="postalZone">The zip code (5 digit)</param>
            <param name="state">The state of the address.</param>
            <param name="county">The county in the state of the address.</param>
            <param name="country">The country of the address.</param>
            <param name="location">The address type such as 'cell' or 'landline'.</param>
            <param name="postalZonePlusFour">The plus-4 part of the zip code of the address.</param>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.FromAddress(Hca.Common.DataType.Address)">
            <summary>
            Creates a new instance of <see cref="T:Hca.Common.DataType.TextAddress"/>and uses the data from the specified
            <see cref="T:Hca.Common.DataType.Address"/> to populate the new instance.
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.Address"/> to 
            use to populate the new instance.</param>
            <returns>A new <see cref="T:Hca.Common.DataType.TextAddress"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.Populate(Hca.Common.DataType.AddressBase)">
            <summary>
            This method will set the values of this address to the values of the passed 
            address. 
            </summary>
            <param name="address">The instance of <see cref="T:Hca.Common.DataType.Address"/> to 
            use to populate this instance.</param>
            <remarks>
            If the argument passed is <see langword="null"/>, no change occurs to the current address. 
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.CalculateHashKey">
            <summary>
            <p>
            This method calculates a hash value for the value-part of an address.
            </p>
            </summary>
            <remarks>
            For general information refer to <see cref="M:Hca.Common.DataType.AddressBase.CalculateHashKey"/>.
            A textual address uses the text value of (State, Country, and County) for computing the hash. 
            <note>Changing the text for (State, Country, and County) will also change the hash so care should
            be taken if this is a requirement.</note>
            </remarks>
            <returns>A hash (<see langword="int"/> )for the current address value</returns>
        </member>
        <member name="M:Hca.Common.DataType.TextAddress.PopulateImpl(Hca.Common.DataType.AddressBase)">
            <summary>
            Populates the current instance with the values from <paramref name="addressValue"/>.
            </summary>
            <param name="addressValue">The <see cref="T:Hca.Common.DataType.TextAddress"/> instance to use to populate this instance.</param>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.LocationText">
            <summary>
            The location value.
            </summary>
            <remarks>
            Location is typically used for designating an address for a certain
            usage such as Home, Business, Vacation, etc.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.LocationDisplayText">
            <summary>
            The location text value.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.DataType.TextAddress.LocationText"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.StateText">
            <summary>
            The state value.
            </summary>
            <remarks>
            The state or Province is usually a standard abbreviation. For example,
            TN is more typical than Tennessee for specification on an address.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.StateDisplayText">
            <summary>
            The State text value.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.DataType.TextAddress.StateText"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.CountryText">
            <summary>
            The country value.
            </summary>
            <remarks>
            Usage of ISO 3166 3 letter abbreviations is typical. For example USA for the
            United States.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.CountryDisplayText">
            <summary>
            The country text value.
            </summary>
            <remarks>
            Refer to <see cref="P:Hca.Common.DataType.TextAddress.CountryText"/>
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.CountyText">
            <summary>
            The county value.
            </summary>
            <remarks>
            For example, Willamson in TN.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TextAddress.CountyDisplayText">
            <summary>
            The county text value.
            </summary>
            <remarks>
            Refer <see cref="P:Hca.Common.DataType.TextAddress.CountyText"/>
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.TextPhoneNumber">
            <summary>
            Phone number class provides non-code properties for DeviceType and Location.
            Use <see cref="T:Hca.Common.DataType.PhoneNumber"/> class if you need codified properties. See <see cref="T:Hca.Common.DataType.PhoneNumberBase"/>
            for more detail.
            </summary>
            <remarks>
            When a phone number is parsed or set the following attributes are not 
            effected and must be set via the corresponding property.
            <list type="bullet">
            	<item>location</item>
            	<item>deviceType</item>
            	<item>effectionDate</item>
            	<item>endDate</item>
            </list>
            NOTES:
            <list type="bullet">
            	<item>Extra attributes (e.g. location) are not considered when parsing</item>
            	<item>Extra attributes are not shown in the default display form.</item>
            	<item>Extra attributes are not serialized when sent to an xml stream.</item>
            </list>
            <p/>
            <see cref="T:Hca.Common.DataType.TextPhoneNumberConverter"/> is associated with this type allowing two-way conversion. 
            <seealso cref="T:System.ComponentModel.TypeConverter"/>
            </remarks>
            <example>
            	Example that illustrates how to set values using the properties:
            	<para/>
            	<hcaExample desc="Property Usage">
            		<code>
            // Creating a text phone number from a string.
            TextPhoneNumber number2 = new TextPhoneNumber("1-615-555-1212"); 
            
            // Creating a phone number from an alpha-numeric string.
            TextPhoneNumber number3 = new TextPhoneNumber("1-800-Flowers");
            string alias =  number3.Alias;	// alias = "1-800-Flowers"
            string dialable = number3.GetDisplayForm(false);	// dialable = "1 800-356-9377"
            
            // Creating a phone number using the phone number segments.
            TextPhoneNumber number4 = new TextPhoneNumber(1, "615", "555", "1212", false);
            		</code>
            	</hcaExample>
            	<para/>
            	Example that illustrates how to format the object into a string. This method generates a phone 
            	number in the standard format. Refer to the API guide for available format options.
            	<para/>
            	<hcaExample desc="Using the IFormattable ToString of PhoneNumber">
            		<code>
            TextPhoneNumber number = new TextPhoneNumber("1-800-Flowers");
            string output = number.ToString("N", CultureInfo.CurrentCulture);
            //returns: (800) 356-9377
            
            string output = number.ToString("{AL}", CultureInfo.CurrentCulture);
            // returns: 1-800-FLOWERS
            		</code>
            	</hcaExample>
            </example>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.TextPhoneNumber"/></overloads>
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(Hca.Common.DataType.TextPhoneNumber)">
            <summary>
            Copy constructor
            </summary>		
            <param name="number">number to create a new text phone number</param>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(Hca.Common.DataType.PhoneNumber)">
            <summary>
            Constructor that takes a <see cref="T:Hca.Common.DataType.PhoneNumber"/>
            </summary>		
            <param name="number">number to create a new text phone number</param>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor that takes typical parts of the number. This treats the number
            as a North American number
            </summary>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Constructor that takes typical parts of the number for both 
            international and North American.
            </summary>
            <param name="countryCode">the value of the country code</param>
            <param name="areaCode">String version of area code</param>
            <param name="prefix">String version of prefix</param>
            <param name="localNumber">String version of the line number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(System.String)">
            <summary>
            Constructor that takes a sting for the number and parses as a north american 
            number. If international number is desired to be parsed, call Constructor that
            takes the North American flag.
            </summary>
            <param name="phoneNumber">string value of phone number</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumber.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor that takes a string representation of the phone number. This is
            parsed into the appropriate parts. 
            </summary>
            <remarks>
            If the format is non-determinate or invalid, a runtime exception is thrown. If <see langword="null"/> is passed, 
            this Constructor acts as if the default Constructor was called. Rules for parsing are contained
            in the regular expression library <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> and 
            <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/>.
            </remarks>
            <param name="phoneNumber">string value of phone number</param>
            <param name="isInternational"><see langword="true"/> if treat as international</param>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if improper input values</exception>
        </member>
        <member name="F:Hca.Common.DataType.TextPhoneNumber.locationText">
            <summary>
            <see cref="P:Hca.Common.DataType.TextPhoneNumber.LocationText"/>
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TextPhoneNumber.deviceTypeText">
            <summary>
            <see cref="P:Hca.Common.DataType.TextPhoneNumber.DeviceTypeText"/>
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TextPhoneNumber.LocationText">
            <summary>
            What type of number this is (e.g. Business, Home, Vacation, etc.)
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TextPhoneNumber.LocationDisplayText">
            <summary>
            The location text value.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TextPhoneNumber.DeviceTypeText">
            <summary>
            The type of device this represents (e.g. land line, fax, cell, etc.)
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TextPhoneNumber.DeviceTypeDisplayText">
            <summary>
            The displayable text value.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.TextPhoneNumberConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.DataType.TextPhoneNumber"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.DataType.TextPhoneNumber"/> type to and from other types. See
            its converter methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is string or <see cref="T:Hca.Common.DataType.TextPhoneNumber"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is string or assignable from <see cref="T:Hca.Common.DataType.TextPhoneNumber"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>.<see cref="T:System.ComponentModel.TypeConverter"/>
            for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.TextPhoneNumberConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.TextPhoneNumberConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TextPhoneNumberConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.DataType.TextPhoneNumber"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeOfDay">
            <summary>Represents a time in the 24-hour day in hours, minutes, seconds, and milliseconds.</summary>
            <remarks>This class is unaware of time zones - all comparisons to the current system time use 
            the time zone of the system clock.
            <see cref="T:Hca.Common.DataType.TimeOfDayConverter"/> is associated with this type allowing two-way conversion. 
            <seealso cref="T:System.ComponentModel.TypeConverter"/>
            </remarks>
        </member>
        <member name="F:Hca.Common.DataType.TimeOfDay.innerSpan">
            <summary>Internal representation of the time of day.</summary>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor">
            <overloads>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/>.</overloads>
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> at 00:00:00.000.</summary>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.String)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> at 00:00:00.000.</summary>
            <param name="value">time of day to parse</param>	
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.Int32,System.Int32)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> at the specified hour and minute.</summary>
            <param name="hour">The hour of the day - up to 23.</param>
            <param name="minute">The minute in the hour - up to 59.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> at the specified hour, minute and second.</summary>
            <param name="hour">The hour of the day - up to 23.</param>
            <param name="minute">The minute in the hour - up to 59.</param>
            <param name="second">The second in the minute - up to 59.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> at the specified hour, minute, second and millisecond.</summary>
            <param name="hour">The hour of the day - up to 23.</param>
            <param name="minute">The minute in the hour - up to 59.</param>
            <param name="second">The second in the minute - up to 59.</param>
            <param name="millisecond">The millisecond in the second - up to 999.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.TimeSpan)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> from the Hours, Minutes, Seconds, and Milliseconds parts of a <see cref="T:System.TimeSpan"/>.</summary>
            <param name="timeSpan">The TimeSpan to use.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(System.DateTime)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> from the Hour, Minute, Second, and Millisecond part of a <see cref="T:System.DateTime"/>.</summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> to use.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.#ctor(Hca.Common.DataType.UtcDateTime)">
            <summary>
            Constructs an instance of <see cref="T:Hca.Common.DataType.TimeOfDay"/> from the Hour, Minute, Second and Millisecond properties of a <see cref="T:Hca.Common.DataType.UtcDateTime"/>.</summary>	
            <param name="utcDateTime">The <see cref="T:Hca.Common.DataType.UtcDateTime"/> to use.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.SetHour(System.Int32)">
            <summary>
            Performs validation and sets Hour field.
            </summary>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.SetMinute(System.Int32)">
            <summary>
            Performs validation and sets Minute field.
            </summary>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.SetSecond(System.Int32)">
            <summary>
            Performs validation and sets Second field.
            </summary>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.SetMillisecond(System.Int32)">
            <summary>
            Performs validation and sets Millisecond field.
            </summary>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.ToTimeSpan">
            <summary>Converts the time of day to a <see cref="T:System.TimeSpan"/>.</summary>
            <returns>A TimeSpan between 00:00:00.000 and 23:59:59:999, inclusive.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.GetNextOccurrence">
            <summary>Computes the next DateTime that this <see cref="T:Hca.Common.DataType.TimeOfDay"/> will be current.</summary>
            <returns>A <see cref="T:System.DateTime"/> no more than than 23 hours, 59 minutes, 59 seconds, and 999 milliseconds from <see cref="P:System.DateTime.Now"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.GetTimeUntilNextOccurrence">
            <summary>Computes the amount of time until the next <see cref="T:System.DateTime"/> that this <see cref="T:Hca.Common.DataType.TimeOfDay"/> will be current.</summary>
            <returns>A TimeSpan no greater than 23 hours, 59 minutes, 59 seconds, and 999 milliseconds.</returns>
            <remarks>A 100ms offset is included in the calculation to prevent the clock passing the next occurrence before the call returns.</remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.CompareTo(System.Object)">
            <summary>
            Two <see cref="T:Hca.Common.DataType.TimeOfDay"/> Compare equal if their <see cref="T:System.TimeSpan"/> values compare equal
            </summary>
            <param name="obj"></param>
            <returns>
            <list type="table">
            <listheader>
            	<term>Value</term>
            	<term>Description</term>
            </listheader>
            <item>
            	<description>Less than zero</description>
            	<description>This instance is less than value.</description>
            </item>
            <item>
            	<description>Zero</description>
            	<description>This instance is equal to value.</description>
            </item>
            <item>
            	<description>Greater than zero</description>
            	<description>This instance is greater than value, or value is <see langword="null"/>.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if type is not a <see cref="T:Hca.Common.DataType.TimeOfDay"/></exception>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.ToString">
            <summary>
            Converts the value of this instance to its equivalent string.
            </summary>
            <remarks>
            This prints the <see cref="T:System.TimeSpan"/> [-][d.]hh:mm:ss[.ff]
            </remarks>
            <returns>A string representation.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_GreaterThan(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.DataType.TimeOfDay"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_LessThan(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.DataType.TimeOfDay"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_GreaterThanOrEqual(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.DataType.TimeOfDay"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_LessThanOrEqual(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.DataType.TimeOfDay"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.Equals(System.Object)">
            <summary>
            Overrides the Equals method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_Equality(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Overloads the == operator
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.op_Inequality(Hca.Common.DataType.TimeOfDay,Hca.Common.DataType.TimeOfDay)">
            <summary>
            Overloads the != operator
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDay.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all
            of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly
            the same values.
            </remarks>
            <returns>The HashCode of the object's concatenated values.</returns>
        </member>
        <member name="P:Hca.Common.DataType.TimeOfDay.Hour">
            <summary>Gets or sets the hour of the day - up to 23.</summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">When setting, the value specified falls outside the valid range of 0-23.</exception>
        </member>
        <member name="P:Hca.Common.DataType.TimeOfDay.Minute">
            <summary>Gets or sets the minute in the hour - up to 59.</summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">When setting, the value specified falls outside the valid range of 0-59.</exception>
        </member>
        <member name="P:Hca.Common.DataType.TimeOfDay.Second">
            <summary>Gets or sets the second in the minute - up to 59.</summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">When setting, the value specified falls outside the valid range of 0-59.</exception>
        </member>
        <member name="P:Hca.Common.DataType.TimeOfDay.Millisecond">
            <summary>Gets or sets the millisecond in the second - up to 999.</summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">When setting, the value specified falls outside the valid range of 0-999.</exception>
        </member>
        <member name="P:Hca.Common.DataType.TimeOfDay.RawText">
            <summary>
            Provides the textual view of Time Of Day.
            </summary>
            <remarks>
            This class is intended to be immutable and not updated via this property. It is only provided
            to allow fine grain control for XML serialization. There is not other way
            to achieve this control with .NET 1.1. .NET 2.0 provides support for mixing
            XML attributes and <see cref="T:System.Xml.Serialization.IXmlSerializable"/> methods.
            </remarks>
        </member>
        <member name="T:Hca.Common.DataType.TimeOfDayConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.DataType.TimeOfDayConverter"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.DataType.TimeOfDay"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <c>string</c>, <see cref="T:Hca.Common.DataType.TimeOfDay"/>, <see cref="T:System.TimeSpan"/>, or <see cref="T:Hca.Common.DataType.UtcDateTime"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is <c>string</c> or assignable from <see cref="T:Hca.Common.DataType.TimeOfDay"/>, or <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.TimeOfDayConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.TimeOfDayConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.TimeOfDayConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.DataType.TimeOfDay"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo">
            <summary>
            This class represents a specific Time Zone.  
            It stores the information about the time offset from 
            UTC (Universal Time Constant; aka Greenwich Mean Time)
            and Daylight Savings Time settings.
            </summary>
            
            
            	<para><b>Functional Requirements</b></para>
            	This set of classes needs to:
            	<list type="bullet">
            		<item>Provide a date-only representation.</item>
            		<item>Provide an absolute date and time (a universally specific moment in time).</item>
            		<item>
            			Convert a date and time between two given time zones (including UTC).
            			<hcaNote>
            				UTC is the Universal Time Constant time zone, which was previously referred to 
            				as Greenwich Mean Time.
            			</hcaNote>
            		</item>
            		<item>Handle Daylight Savings Time (DST) during conversions.</item>
            	</list>
            
            	<para><b>Tenets</b></para>
            	The user should attempt to use values for only legitimate dates and times.  Invalid values 
            	generate an error. For example, January 43, 2004 is not a valid date and 31:78AM is an 
            	invalid time.
            
            	<para><b>Design</b></para>
            	<h4 class="dtH4">Date</h4>
            	<see cref="T:Hca.Common.DataType.Date"/> is a custom data type that stores the elements of a date 
            	(year, month, and day). This class does not have time elements. It is intended to be used when 
            	the developer is only concerned with the date segments of <see cref="T:System.DateTime"/>.
            	<para/>
            	<see cref="T:Hca.Common.DataType.Date"/> uses <see cref="T:System.DateTime"/> internally to validate, 
            	manipulate, and output the values. It strips out any time-specific values.
            
            	<h4 class="dtH4">UtcDateTime</h4>
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> is a custom data type that represents a date and 
            	time in UTC. It is intended to be used by all applications that need a timestamp so that the 
            	information is handled in a consistent manner, especially for custom data objects (Value Objects) 
            	that are passed between tiers and/or are persistent.
            	<para/>
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> inherits from <see cref="T:Hca.Common.DataType.Date"/> 
            	and extends its functionality to include the time elements. The values are always stored internally 
            	as a UTC date and time.  
            	<para/>
            	It also has a set of static methods that convert to and from any time zone.
            
            	<h4 class="dtH4">TimeZoneInfo</h4>
            	<see cref="T:Hca.Common.DataType.TimeZoneInfo"/> is a custom data type that represents a Time Zone. 
            	It is intended to be used by all applications that need to convert dates and times to and from 
            	time zones, including UTC.	<see cref="T:Hca.Common.DataType.TimeZoneInfo"/> handles the standard 
            	offset from UTC as well as daylight savings time (DST).
            	<para/>
            	Time zones rarely change, so it's not very likely that time zone information needs to be 
            	persistent. However, this data type can represent any time zone and could be used as a value 
            	object (e.g. a persistent data type).
            	<para/>
            	<see cref="T:Hca.Common.DataType.TimeZoneInfo"/> also contains a pre-defined list of time zones, 
            	which are accessed with the <see cref="M:Hca.Common.DataType.TimeZoneInfo.GetTimeZoneInfo(Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName)"/> method.  This is a 
            	complete list of all time zones (2001 release). A planned future release of this class will 
            	dynamically load this data from a resource file, which is built from the data files that 
            	constitute the time zone data.
            
            	<para><b>Usage</b></para>
            	<see cref="T:Hca.Common.DataType.Date"/> and <see cref="T:Hca.Common.DataType.UtcDateTime"/> should 
            	be used in any Value Object that requires a date-only or date-time property, respectively. They 
            	should be used instead of <see cref="T:System.DateTime"/> because <see cref="T:System.DateTime"/> 
            	does not store any time zone information.
            	<para/>
            	Variables typed for these classes can also be set to <see langword="null"/>, indicating a <i>not-set</i> 
            	state. This is useful as data types for properties of any class that requires a partial update. 
            	<para/>
            	<see cref="T:Hca.Common.DataType.TimeZoneInfo"/> should be used with the static conversion methods 
            	of <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to convert dates from one time zone to another.
            	<para/>
            	Generally, <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> is initialized by requesting one of its 
            	pre-defined time zones.  If a time zone is requested that does not exist in this list, then code 
            	throws an exception.
            	<para/>
            	Exceptions are also thrown when <see cref="T:Hca.Common.DataType.Date"/> or 
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> instances are initialized with invalid dates and/or times.
            	<para/>
            	<hcaNote>Use <see cref="T:Hca.Common.DataType.Date"/> or <see cref="T:Hca.Common.DataType.UtcDateTime"/> 
            	instead of .NET's <see cref="T:System.DateTime"/>.
            	</hcaNote>
            
            	<para><b>Best Practices</b></para>
            	Use <see cref="T:Hca.Common.DataType.Date"/> and <see cref="T:Hca.Common.DataType.UtcDateTime"/> as data 
            	types for properties of Value Objects instead of <see cref="T:System.DateTime"/>. Additionally, when 
            	only a date is needed (such as representing a date of birth), use <see cref="T:Hca.Common.DataType.Date"/> 
            	since it ensures that time components are not valued. Similarly, if you need to represent something 
            	like a status time or change date, use <see cref="T:Hca.Common.DataType.UtcDateTime"/>.
            
            
            
            
            <example>
            	<hcaExample desc="Example 14: Converting to a specific time zone">
            		<code>
            TimeZoneInfo timezone = TimeZoneInfo.GetTimeZoneInfo(TimeZoneInfo.CommonTimeZoneCode.EST);
            UtcDateTime utc = new UtcDateTime(2004,2,14,8,45,0,0); 
            DateTime eastern = UtcDateTime.ConvertFromUtc(utc, timezone);
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Example 15: Getting a time zone from the pre-defined list">
            		<code>
            TimeZoneInfo timezone = TimeZoneInfo.GetTimeZoneInfo(TimeZoneInfo.CommonTimeZoneCode.EST);
            TimeZoneInfo info = TimeZoneInfo.GetTimeZoneInfo(TimeZoneInfo.CommonTimeZoneNames.AmericaPacificStandardTime);
            TimeZoneInfo info = TimeZoneInfo.GetTimeZoneInfo("Europe/Madrid");
            		</code>
            	</hcaExample>
            </example>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.MILLISECONDS_PER_SECOND">
            <summary>
            The number of milliseconds per second. (1000)
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.MILLISECONDS_PER_MINUTE">
            <summary>
            The number of milliseconds per minute. (60000)
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.MILLISECONDS_PER_HOUR">
            <summary>
            The number of milliseconds per hour. (3600000)
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.MILLISECONDS_PER_DAY">
            <summary>
            The number of milliseconds per day. (86400000)
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.MonthDayLength">
            <summary>
            An array that contains the number of days in each month of the year.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.LeapYearMonthDayLength">
            <summary>
            An array that contains the number of days in each month of a leap year.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.#ctor(System.Int32,System.String)">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.TimeZoneInfo"/>.</overloads>
            <summary>
            Constructor that only take the required parameters.
            </summary>
            <param name="offset">The number of Milliseconds from UTC time.</param>
            <param name="identifier">The Id (Name) of the <see cref="T:System.TimeZone"/>.</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor that uses a default of 1 hour for the Daylight Savings Time (DST) offset
            and the default of 'WALL' DST time mode.
            </summary>
            <param name="offset">The number of Milliseconds from UTC time.</param>
            <param name="identifier">The Id (Name) of the <see cref="T:System.TimeZone"/>.</param>
            <param name="startMonth">The month that DST starts.</param>
            <param name="startDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST starts.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST starts on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summary)
            </param>
            <param name="startDayOfWeek">
            Zero indicates DST starts on a specific day of the month.
            Greater than Zero indicates the day of the week that DST starts (values 1 to 7).
            Less than Zero indicates DST starts on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summaries)
            </param>
            <param name="startTime">The time of day that DST starts (in milliseconds).</param>
            <param name="endMonth">The month that DST ends.</param>
            <param name="endDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST ends.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST ends on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summary)
            </param>
            <param name="endDayOfWeek">
            Zero indicates DST ends on a specific day of the month.
            Greater than Zero indicates the day of the week that DST ends (values 1 to 7).
            Less than Zero indicates DST ends on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summaries)
            </param>
            <param name="endTime">The time of day that DST ends (in milliseconds).</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor that uses the default of 'WALL' DST time mode.
            </summary>
            <param name="offset">The number of Milliseconds from UTC time.</param>
            <param name="identifier">The Id (Name) of the <see cref="T:System.TimeZone"/>.</param>
            <param name="startMonth">The month that DST starts.</param>
            <param name="startDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST starts.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST starts on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summary)
            </param>
            <param name="startDayOfWeek">
            Zero indicates DST starts on a specific day of the month.
            Greater than Zero indicates the day of the week that DST starts (values 1 to 7).
            Less than Zero indicates DST starts on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summaries)
            </param>
            <param name="startTime">The time of day that DST starts (in milliseconds).</param>
            <param name="endMonth">The month that DST ends.</param>
            <param name="endDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST ends.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST ends on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summary)
            </param>
            <param name="endDayOfWeek">
            Zero indicates DST ends on a specific day of the month.
            Greater than Zero indicates the day of the week that DST ends (values 1 to 7).
            Less than Zero indicates DST ends on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summaries)
            </param>
            <param name="endTime">The time of day that DST ends (in milliseconds).</param>
            <param name="daylightSaving">The additional offset used during DST (in milliseconds).</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor that takes all parameters.
            </summary>
            <param name="offset">The number of Milliseconds from UTC time.</param>
            <param name="identifier">The Id (Name) of the <see cref="T:System.TimeZone"/>.</param>
            <param name="startMonth">The month that DST starts.</param>
            <param name="startDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST starts.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST starts on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summary)
            </param>
            <param name="startDayOfWeek">
            Zero indicates DST starts on a specific day of the month.
            Greater than Zero indicates the day of the week that DST starts (values 1 to 7).
            Less than Zero indicates DST starts on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartDay"/> property summaries)
            </param>
            <param name="startTime">The time of day that DST starts (in milliseconds).</param>
            <param name="startTimeMode">The time mode when DST starts (WALL=0, STANDARD=1, UTC=2).</param>
            <param name="endMonth">The month that DST ends.</param>
            <param name="endDay">
            If <see cref="T:System.DayOfWeek"/> = 0 then the day of the month that DST ends.
            If <see cref="T:System.DayOfWeek"/> &gt; 0 then the 1st, 2nd, last, etc. Day of Week in the month.
            If <see cref="T:System.DayOfWeek"/> &lt; 0 then DST ends on the <see cref="T:System.DayOfWeek"/> on, before, or after this day of the month.
            Zero indicates No Daylight Saving Time.
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summary)
            </param>
            <param name="endDayOfWeek">
            Zero indicates DST ends on a specific day of the month.
            Greater than Zero indicates the day of the week that DST ends (values 1 to 7).
            Less than Zero indicates DST ends on this day of the week before, after, or on 
            the day of the month (values -1 to -7).
            (see the <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDayOfWeek"/> and <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndDay"/> property summaries)
            </param>
            <param name="endTime">The time of day that DST ends (in milliseconds).</param>
            <param name="endTimeMode">The time mode when DST ends (WALL=0, STANDARD=1, UTC=2).</param>
            <param name="daylightSaving">The additional offset used during DST (in milliseconds).</param>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the specified month of the specified
            year. Leap years are accounted for.
            </summary>
            <remarks>
            The month index is 1-based so January = 1, December = 12.
            </remarks>
            <param name="month">1-based month to check</param>
            <param name="year">the year to check.</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.GetTimeZoneInfo(Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName)">
            <overloads>Gets a <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object from the pre-defined list of TimeZones.</overloads>
            <summary>
            Gets a <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object from the pre-defined list of TimeZones based on the common time zone name.
            </summary>
            <param name="name">The Name of the <see cref="T:System.TimeZone"/>.</param>
            <returns>A <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.GetTimeZoneInfo(Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode)">
            <summary>
            Gets a <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object from the pre-defined list of TimeZones based on the time zone code.
            </summary>
            <param name="code">The <see cref="T:System.TimeZone"/> Code.</param>
            <returns>A <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.GetTimeZoneInfo(System.String)">
            <summary>
            Gets a <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object from the pre-defined list of TimeZones based on the time zone identifier.
            </summary>
            <param name="identifier">The <see cref="T:System.TimeZone"/> Identifier.</param>
            <returns>A <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> object.</returns>
        </member>
        <member name="M:Hca.Common.DataType.TimeZoneInfo.ToString(System.String,System.IFormatProvider)">
            <summary>
            This method provides specialized formatting of a <see cref="T:System.TimeZone"/> based
            on the passed character(s) in the format argument.
            </summary>
            <remarks>
            There are two formatting options.
            <list>
            <item>
            <term>N (Name)</term>
            <description>(default if not specified)   returns the name of the timezone; the Id field</description>
            </item>
            <item>
            <term>V (Verbose)</term>
            <description>Returns a listing of the values of all fields.</description>
            </item>
            </list>
            </remarks>
            <param name="format">The format string</param>
            <param name="formatProvider">Not currently used.</param>
            <returns></returns>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.UseDaylightSavings">
            <summary>
            <see langword="true"/> if this <see cref="T:System.TimeZone"/> uses Daylight Savings Time (DST).
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.Offset">
            <summary>
            The number of milliseconds to add or subtract from UTC for this <see cref="T:System.TimeZone"/>.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.Id">
            <summary>
            The identifier for this <see cref="T:System.TimeZone"/>.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartMode">
            <summary>
            The method this <see cref="T:System.TimeZone"/> uses to determine when DST starts.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartMonth">
            <summary>
            The month this <see cref="T:System.TimeZone"/> starts DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartDay">
            <summary>
            This field has two possible meanings:
            1. If <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartMode"/> = <see cref="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekInMonth"/> then
            		this is the 1st, 2nd, etc. day of week in the month
            		(valid values are: -5 to 5)
            		
            2. If <see cref="P:Hca.Common.DataType.TimeZoneInfo.StartMode"/> != <see cref="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekInMonth"/> then
            		this is the day that DST starts on, before, or after
            		(valid values are: 1 to 28,30, or 31)
            </summary>
            <remarks>
            Example:
            <code>
            	StartMode = DayOfMonth
            	StartMonth = March
            	StartDay = 16
            		
            	DST starts on March 16.
            </code>
            Example:
            <code>
            	StartMode = DayOfWeekInMonth
            	StartDayOfWeek = Sunday
            	StartMonth = March
            	
            	If StartDay = 2 then
            		DST starts on the 2nd Sunday in March
            	
            	If StartDay = -1 then
            		DST starts on the last Sunday in March
            		
            </code>
            Example:
            <code>
            	StartMode = DayOfWeekAfterDayOfMonth
            	StartDayOfWeek = Sunday
            	StartMonth = March
            	StartDay = 16
            	
            	DST starts on the first Sunday on or after March 16.
            		
            </code>
            Example:
            <code>
            	StartMode = DayOfWeekBeforeDayOfMonth
            	StartDayOfWeek = Sunday
            	StartMonth = March
            	StartDay = 16
            		
            	DST starts on the first Sunday on or before March 16.
            </code>
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartDayOfWeek">
            <summary>
            The Day of Week this <see cref="T:System.TimeZone"/> starts DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartTime">
            <summary>
            The time of day this <see cref="T:System.TimeZone"/> starts DST (in milliseconds).
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.StartTimeMode">
            <summary>
            The time mode (WALL, STANDARD, UTC) this <see cref="T:System.TimeZone"/> starts DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndMode">
            <summary>
            The method this <see cref="T:System.TimeZone"/> uses to determine when DST ends.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndMonth">
            <summary>
            The month this <see cref="T:System.TimeZone"/> ends DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndDay">
             <summary>
             This field has two possible meanings:
             1. If <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndMode"/> = <see cref="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekInMonth"/> then
            			this is the 1st, 2nd, etc. day of week in the month
            			(valid values are: -5 to 5)
            			
            	2. If <see cref="P:Hca.Common.DataType.TimeZoneInfo.EndMode"/> != <see cref="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekInMonth"/> then
            			this is the day that DST ends on, before, or after
            			(valid values are: 1 to 28,30, or 31)
             </summary>
             <remarks>
            	Example:
            	<code>
            		EndMode = DayOfMonth
            		EndMonth = October
            		EndDay = 16
            			
            		DST ends on October 16.
            	</code>	
             Example:
            	<code>
            		EndMode = DayOfWeekInMonth
            		EndDayOfWeek = Sunday
            		EndMonth = October
            		
            		If EndDay = 2 then
            			DST ends on the 2nd Sunday in October
            		
            		If EndDay = -1 then
            			DST ends on the last Sunday in October
            	</code>	
             Example:
            	<code>
            		EndMode = DayOfWeekAfterDayOfMonth
            		EndDayOfWeek = Sunday
            		EndMonth = October
            		EndDay = 16
            		
            		DST ends on the first Sunday on or after October 16.
            	</code>	
             Example:
            	<code>
            		EndMode = DayOfWeekBeforeDayOfMonth
            		EndDayOfWeek = Sunday
            		EndMonth = October
            		EndDay = 16
            			
            		DST ends on the first Sunday on or before October 16.
            	</code>	
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndDayOfWeek">
            <summary>
            The Day of Week this <see cref="T:System.TimeZone"/> ends DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndTime">
            <summary>
            The time of day this <see cref="T:System.TimeZone"/> ends DST (in milliseconds).
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.EndTimeMode">
            <summary>
            The time mode (WALL, STANDARD, UTC) this <see cref="T:System.TimeZone"/> ends DST.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.TimeZoneInfo.DaylightSaving">
            <summary>
            The additional offset to apply when this <see cref="T:System.TimeZone"/> is in DST.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth">
            <summary>
            A listing of the months of the year with a "Not Set" value.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.NotSet">
            <summary>The "Not Set" state.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.January">
            <summary>January</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.February">
            <summary>February</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.March">
            <summary>March</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.April">
            <summary>April</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.May">
            <summary>May</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.June">
            <summary>June</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.July">
            <summary>July</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.August">
            <summary>August</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.September">
            <summary>September</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.October">
            <summary>October</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.November">
            <summary>November</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneMonth.December">
            <summary>December</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay">
            <summary>
            A listing of the days of the week with a "Not Set" value.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.NotSet">
            <summary>The "Not Set" state.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Sunday">
            <summary>Sunday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Monday">
            <summary>Monday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Tuesday">
            <summary>Tuesday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Wednesday">
            <summary>Wednesday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Thursday">
            <summary>Thursday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Friday">
            <summary>Friday</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.TimeZoneWeekDay.Saturday">
            <summary>Saturday</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode">
            <summary>
            The method to use to determine how to calculate the start or end 
            of Daylight Saving Time (DST).
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.NotSet">
            <summary>The "Not Set" state.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfMonth">
            <summary>Exact day of month (March 1)</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekInMonth">
            <summary>Day of week in month (the 1st Sunday, the last Thursday, etc.)</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekAfterDayOfMonth">
            <summary>Day of week after a day of month (the 1st Sunday after the 15th of the month)</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode.DayOfWeekBeforeDayOfMonth">
            <summary>Day of week before a day of month (the 1st Sunday before the 21st of the month)</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.DaylightSavingTimeMode">
            <summary>
            The <see cref="T:System.TimeZone"/> to use for the Time of Day when DST starts or ends.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingTimeMode.NotSet">
            <summary>The "Not Set" state.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingTimeMode.Wall">
            <summary>"Wall Time" uses Standard time when DST begins and daylight time when DST ends.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingTimeMode.Standard">
            <summary>Always uses Standard time.</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.DaylightSavingTimeMode.UTC">
            <summary>Always uses UTC time.</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode">
            <summary>
            A list of commonly used <see cref="T:System.TimeZone"/> Codes.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.PST">
            <summary>America: Pacific Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.MST">
            <summary>America: Mountain Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.PNT">
            <summary>America: Phoenix</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.CST">
            <summary>America: Central Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.EST">
            <summary>America: Eastern Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.IET">
            <summary>America: Indianapolis</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.PRT">
            <summary>America: Puerto Rico</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.CNT">
            <summary>America: St. Johns</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.AGT">
            <summary>America: Buenos Aires</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.BET">
            <summary>America: Sao Paulo</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.MIT">
            <summary>Pacific: Apia</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.HST">
            <summary>America: Hawaiian Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.AST">
            <summary>America: Alaska Standard Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.GMT">
            <summary>Greenwich Mean Time</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.UTC">
            <summary>Universal Time Constant</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.WET">
            <summary>Europe: Western</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.ECT">
            <summary>Europe: Paris</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.ART">
            <summary>Africa: Cairo</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.CAT">
            <summary>Africa: Harare</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.EET">
            <summary>Europe: Eastern</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.EAT">
            <summary>Africa: Addis Ababa</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.MET">
            <summary>Asia: Tehran</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.NET">
            <summary>Asia: Yerevan</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.PLT">
            <summary>Asia: Karachi</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.IST">
            <summary>Asia: Calcutta</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.BST">
            <summary>Asia: Dhaka</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.VST">
            <summary>Asia: Saigon</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.CTT">
            <summary>Asia: Shanghai</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.JST">
            <summary>Asia: Tokyo</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.ACT">
            <summary>Australia: Darwin</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.AET">
            <summary>Australia: Sydney</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.SST">
            <summary>Pacific: Guadalcanal</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneCode.NST">
            <summary>Pacific: Auckland</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName">
            <summary>
            A list of commonly used <see cref="T:System.TimeZone"/> Names.
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaPacificStandardTime">
            <summary>PST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaMountainStandardTime">
            <summary>MST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaPhoenix">
            <summary>PNT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaCentralStandardTime">
            <summary>CST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaEasternStandardTime">
            <summary>EST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaIndianapolis">
            <summary>IET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaPuertoRico">
            <summary>PRT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaStJohns">
            <summary>CNT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaBuenosAires">
            <summary>AGT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaSaoPaulo">
            <summary>BET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.PacificApia">
            <summary>MIT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaHawaiianStandardTime">
            <summary>HST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AmericaAlaskaStandardTime">
            <summary>AST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.GreenwichMeanTime">
            <summary>GMT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.UniversalTimeConstant">
            <summary>UTC</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.EuropeWestern">
            <summary>WET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.EuropeParis">
            <summary>ECT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AfricaCairo">
            <summary>ART</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AfricaHarare">
            <summary>CAT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.EuropeEastern">
            <summary>EET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AfricaAddisAbaba">
            <summary>EAT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaTehran">
            <summary>MET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaYerevan">
            <summary>NET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaKarachi">
            <summary>PLT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaCalcutta">
            <summary>IST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaDhaka">
            <summary>BST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaSaigon">
            <summary>VST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaShanghai">
            <summary>CTT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AsiaTokyo">
            <summary>JST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AustraliaDarwin">
            <summary>ACT</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.AustraliaSydney">
            <summary>AET</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.PacificGuadalcanal">
            <summary>SST</summary>
        </member>
        <member name="F:Hca.Common.DataType.TimeZoneInfo.CommonTimeZoneName.PacificAuckland">
            <summary>NST</summary>
        </member>
        <member name="T:Hca.Common.DataType.TimeZoneInfo.TimeZoneParams">
            <summary>
            This is a very this structure used to help performance.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.UtcDateTime">
            <summary>
            This class represents a time in Universal Time Coordinated (UTC). 
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            This means any value set without explicitly indicating that it is a
            local time will be treated as UTC. For example, when we are on Daylight
            Savings Time (DST), the offset of local to UTC in the central timezone
            is -6 hours. When using this class with XML serialization, note that the time shown
            is also in UTC. Hence, if you want to show the time as local time, you
            must covert it yourself. In addition, the fractional seconds are included
            since to keep the type in tack, it must be included. However, the precision
            of these fractional seconds is set such that this type is useful when storing
            datetimes in a database. Since SqlServer precision is only down to 3.33 
            milliseconds, we chose this as our default precision. If you desire another
            precision, choose one of the other available value in the <see cref="T:Hca.Common.DataType.UtcDateTime.Precision"/> Enum and
            pass that into the constructor so that values will be kept at the
            correct resolution. Note that any method which adds or subtracts milliseconds 
            or ticks may result in zero being added or subtracted given the value 
            presented is less than the current precision.
            When creating a new instance of this class via the default Constructor or through
            an existing time, if the time for existing time values is <see langword="null"/>, the current
            Utc time is used with the default precision.
            
            
            	<para><b>Functional Requirements</b></para>
            	This class needs to:
            	<list type="bullet">
            		<item>Provide an absolute date and time (a universally specific moment in time).</item>
            		<item>
            			Convert a date and time between two given time zones (including UTC).
            			<hcaNote>
            				UTC is the Universal Time Constant time zone, which was previously referred to 
            				as Greenwich Mean Time.
            			</hcaNote>
            		</item>
            		<item>Handle Daylight Savings Time (DST) during conversions.</item>
            	</list>
            
            	<para><b>Tenets</b></para>
            	The user should attempt to use values for only legitimate dates and times.  Invalid values 
            	generate an error. For example, January 43, 2004 is not a valid date and 31:78AM is an 
            	invalid time.
            
            	<para><b>Design</b></para>
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> is a custom data type that represents a date and 
            	time in UTC. It is intended to be used by all applications that need a timestamp so that the 
            	information is handled in a consistent manner, especially for custom data objects (Value Objects) 
            	that are passed between tiers and/or are persistent.
            	<para/>
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> inherits from <see cref="T:Hca.Common.DataType.Date"/> 
            	and extends its functionality to include the time elements. The values are always stored internally 
            	as a UTC date and time.  
            	<para/>
            	It also has a set of static methods that convert to and from any time zone.
            
            	<para><b>Usage</b></para>
            	<see cref="T:Hca.Common.DataType.UtcDateTime"/> should 
            	be used in any Value Object that requires a date-time property. This 
            	should be used instead of <see cref="T:System.DateTime"/> because <see cref="T:System.DateTime"/> 
            	does not store any time zone information.
            	<para/>
            	Variables typed for this can also be set to <see langword="null"/>, indicating a <i>not-set</i> 
            	state. This is useful as data types for properties of any class that requires a partial update. 
            	<para/>
            	Generally, <see cref="T:Hca.Common.DataType.TimeZoneInfo"/> is initialized by requesting one of its 
            	pre-defined time zones.  If a time zone is requested that does not exist in this list, then code 
            	throws an exception.
            	<para/>
            	Exceptions are also thrown when <see cref="T:Hca.Common.DataType.UtcDateTime"/> instances are 
            	initialized with invalid dates and/or times.
            	<para/>
            	<hcaNote>
            	Use <see cref="T:Hca.Common.DataType.UtcDateTime"/> instead of .NET's <see cref="T:System.DateTime"/>.
            	</hcaNote>
            
            	<para><b>Best Practices</b></para>
            	Use <see cref="T:Hca.Common.DataType.UtcDateTime"/> as a data type for properties of Value Objects 
            	instead of <see cref="T:System.DateTime"/>. Additionally, if you need to represent something 
            	like a status time or change date, use <see cref="T:Hca.Common.DataType.UtcDateTime"/>.
            
            
            <see cref="T:Hca.Common.DataType.UtcDateTimeConverter"/> is associated with this type allowing two-way conversion. 
            <seealso cref="T:System.ComponentModel.TypeConverter"/>
            </remarks>
            <example>
            	<hcaExample desc="Example 12: Setting the values through the constructor - individual values">
            		<code>
            // Feb 14, 2004 at 8:45 AM
            UtcDateTime utc = new UtcDateTime(2004,2,14,8,45,0,0);
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Example 13: Setting the values through the constructor - using a DateTime instance">
            		<code>
            DateTime now = DateTime.Now;
            			
            // the second parameter indicates whether the time is Local (true) or UTC (false).
            UtcDateTime ts = new UtcDateTime(now, true);
            		</code>
            	</hcaExample>
            </example>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.DataType.UtcDateTime"/>.</overloads>
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the current UTC 
            date and time with default precision.
            </summary>
            <remarks>
            Uses the default precision of Sql Server (3.33 msecs).
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the current UTC 
            date and time with the given precision.
            </summary>
            <param name="precision">The precision to use for time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second with default precision. 
            </summary>
            <remarks>
            The Time component arguments are interpreted to be in UTC time.
            If you pass local time values, you will be off by the current 
            timezone setting.
            </remarks>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second with specified precision. 
            </summary>
            <remarks>
            The Time component arguments are interpreted to be in UTC time.
            If you pass local time values, you will be off by the current 
            timezone setting.
            </remarks>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
            <param name="precision">The precision for the time</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second. The time is interpreted 
            to be in UTC time. Default precision is used.
            </summary>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
            <param name="millisecond">The milliseconds (0 through 999)</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second. The time is interpreted 
            to be in UTC time.
            </summary>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
            <param name="millisecond">The milliseconds (0 through 999)</param>
            <param name="precision">The precision to use for time</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second. The time is convert to
            UTC time if the flag localTime is <see langword="true"/>. Uses default precision.
            </summary>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
            <param name="millisecond">The milliseconds (0 through 999)</param>
            <param name="isLocalTime">If <see langword="true"/> then the <see cref="T:System.DateTime"/> contains a Local Time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Hca.Common.DataType.UtcDateTime.Precision,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            year, month, day, hour, minute, and second. The time is converted to
            UTC time if the flag <paramref name="isLocalTime"/> is <see langword="true"/>.
            </summary>
            <param name="year">The year (1 through 9999)</param>
            <param name="month">The month (1 through 12)</param>
            <param name="day">The day (1 through the number of days in month)</param>
            <param name="hour">The hours (0 through 23)</param>
            <param name="minute">The minutes (0 through 59)</param>
            <param name="second">The seconds (0 through 59)</param>
            <param name="millisecond">The milliseconds (0 through 999)</param>
            <param name="isLocalTime">If <see langword="true"/> then the <see cref="T:System.DateTime"/> contains a Local Time.</param>
            <param name="precision">The precision for the time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.String)">
            <summary>
            Sets the time given a string value of the time with default precision.
            </summary>
            <remarks>
            This version will not support milliseconds in the string value since
            the underlying <see cref="T:System.DateTime"/> structure has a bug which does not consider
            milliseconds on a Parse. If this is needed, use the version of the
            constructor that takes the format string.
            </remarks>
            <param name="value">The string value to parse</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.String,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Sets the time given a string value of the time with given precision.
            </summary>
            <remarks>
            This version will not support milliseconds in the string value since
            the underlying <see cref="T:System.DateTime"/> structure has a bug which does not consider
            milliseconds on a Parse. If this is needed, use the version of the
            constructor that takes the format string.
            </remarks>
            <param name="value">The string value to parse</param>
            <param name="precision">The precision of the time.</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.String,System.String)">
            <summary>
            Sets the time given a string value of the time given the passed
            format with default precision.
            </summary>
            <param name="value">The string value to parse</param>
            <param name="format">The format to use to parse</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.String,System.String,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Sets the time given a string value of the time given the passed
            format and precision.
            </summary>
            <param name="value">The string value to parse</param>
            <param name="format">The format to use to parse</param>
            <param name="precision">The precision of the time</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.String,System.String,Hca.Common.DataType.UtcDateTime.Precision,System.Boolean)">
            <summary>
            Sets the time given a string value of the time given the passed
            format and precision.
            </summary>
            <param name="value">The string value to parse</param>
            <param name="format">The format to use to parse</param>
            <param name="precision">The precision of the time</param>
            <param name="isLocalTime">If <see langword="true"/> then the string specifies a Local Time.
            If <see langword="false"/> then the string specifies a UTC Time.</param>
            <exception cref="T:Hca.Common.BaseException.InvalidDataException">If string does not represent a date in a valid format</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(Hca.Common.DataType.UtcDateTime)">
            <summary>
            Constructor that takes a reference <see cref="T:Hca.Common.DataType.UtcDateTime"/> object.
            </summary>
            <param name="value">The reference time</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Constructor that takes a reference <see cref="T:Hca.Common.DataType.UtcDateTime"/> object and precision.
            </summary>
            <param name="value">The reference time</param>
            <param name="precision">The precision of the time</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            UTC date and time with default precision.
            </summary>
            <remarks>
            The passed argument MUST be in UTC time. If you pass a local time, your 
            time value will be off by the timezone you currently are in...
            </remarks>
            <param name="value">The UTC Date to initialize from.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.DateTime,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            UTC date and time with given precision.
            </summary>
            <remarks>
            The passed argument MUST be in UTC time. If you pass a local time, your 
            time value will be off by the timezone you currently are in...
            </remarks>
            <param name="value">The UTC Date to initialize from.</param>
            <param name="precision">The precision of the time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.DateTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            local date and time if local time is <see langword="true"/>, else UTC time with default
            precision.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> to initialize from.</param>
            <param name="isLocalTime">If <see langword="true"/> then the <see cref="T:System.DateTime"/> contains a Local Time.
            If <see langword="false"/> then the <see cref="T:System.DateTime"/> contains a UTC Time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.#ctor(System.DateTime,Hca.Common.DataType.UtcDateTime.Precision,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Hca.Common.DataType.UtcDateTime"/> class to the specified 
            date and time with given precision.
            </summary>
            <param name="value">The UTC Date to initialize from.</param>
            <param name="precision">The precision to use for time.</param>
            <param name="isLocalTime">If <see langword="true"/> then the <see cref="T:System.DateTime"/> contains a Local Time.
            If <see langword="false"/> then the <see cref="T:System.DateTime"/> contains a UTC Time.</param>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToLocalTime">
            <summary>
            Converts the current coordinated universal time (UTC) to local time.
            </summary>
            <returns>
            The <see cref="T:System.DateTime"/> equivalent to the current UTC time, 
            adjusted to the local time zone and daylight saving time.
             -or-
            MaxValue if the current UTC time is too large to be represented as a <see cref="T:System.DateTime"/>.
             -or-
            MinValue if the current UTC time is too small to be represented as a <see cref="T:System.DateTime"/>.
            </returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToTimeSpan">
            <summary>
            Gets the <see cref="T:System.TimeSpan"/> for this instance.
            </summary>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddDays(System.Double)">
            <summary>
            Adds the specified number of days to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional days. The <paramref name="value"/> parameter can 
            be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented by this 
            instance and the number of days represented by value.</returns>
            <remarks>
            This method hides the <see cref="M:Hca.Common.DataType.Date.#ctor"/> method so that a <see cref="T:Hca.Common.DataType.UtcDateTime"/> object can be returned. 
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddMonths(System.Int32)">
            <summary>
            Adds the specified number of months to the value of this instance.
            </summary>
            <param name="value">A number of months. The months parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented by this instance and months.</returns>
            <remarks>
            This method hides the <see cref="M:Hca.Common.DataType.Date.#ctor"/> method so that a <see cref="T:Hca.Common.DataType.UtcDateTime"/> object can be returned. 
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddYears(System.Int32)">
            <summary>
            Adds the specified number of years to the value of this instance.
            </summary>
            <param name="value">A number of years. The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented by 
            this instance and the number of years represented by value.</returns>
            <remarks>
            This method hides the <see cref="M:Hca.Common.DataType.Date.#ctor"/> method so that a <see cref="T:Hca.Common.DataType.UtcDateTime"/> object can be returned. 
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.Add(System.TimeSpan)">
            <summary>
            Adds the value of the specified <see cref="T:System.TimeSpan"/> to the value of this instance.
            </summary>
            <param name="value">A <see cref="T:System.TimeSpan"/> that contains the interval to add.</param>
            <returns>A <see cref="T:System.DateTime"/> whose value is the sum of the date and time represented 
            by this instance and the time interval represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddHours(System.Double)">
            <summary>
            Adds the specified number of hours to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional hours. 
            The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented by this 
            instance and the number of hours represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddMilliseconds(System.Double)">
            <summary>
            Adds the specified number of milliseconds to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional milliseconds. 
            The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented 
            by this instance and the number of milliseconds represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddMinutes(System.Double)">
            <summary>
            Adds the specified number of minutes to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional minutes. 
            The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented 
            by this instance and the number of minutes represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddSeconds(System.Double)">
            <summary>
            Adds the specified number of seconds to the value of this instance.
            </summary>
            <param name="value">A number of whole and fractional seconds. 
            The <paramref name="value"/> parameter can be negative or positive.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and time represented 
            by this instance and the number of seconds represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AddTicks(System.Int64)">
            <summary>
            Adds the specified number of ticks to the value of this instance.
            </summary>
            <param name="value">A number of 100-nanosecond ticks. 
            The <paramref name="value"/> parameter can be positive or negative.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> whose value is the sum of the date and 
            time represented by this instance and the time represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.Subtract(System.TimeSpan)">
            <summary>
            Subtracts the specified duration from this instance.
            </summary>
            <param name="value">An instance of <see cref="T:System.TimeSpan"/>.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> equal to the date and time represented by 
            this instance minus the time interval represented by value.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToLongTimeString">
            <summary>
            Converts the value of this instance to its equivalent long time string representation.
            </summary>
            <remarks>
            This time is formatted in the current cultures format.
            </remarks>
            <returns>A string containing the name of the day of the week, the name of the month, 
            the numeric day of the hours, minutes, and seconds equivalent to the time value 
            of this instance.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToShortTimeString">
            <summary>
            Converts the value of this instance to its equivalent short time string representation.
            </summary>
            <remarks>
            This time is formatted in the current cultures format.
            </remarks>
            <returns>A string containing the name of the day of the week, the name of the month, 
            the numeric day of the hours, minutes, and seconds equivalent to the time value 
            of this instance.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToString">
            <overloads> Converts the value of this instance to its equivalent string.</overloads>
            <summary>
            Converts the value of this instance to its equivalent string with no formatting.
            </summary>
            <remarks>
            This prints the date and time using a universal format (yyyy-MM-ddTH:mm:ss.fffffffzzz) 
            that provides full precision as well as timezone offset.
            </remarks>
            <returns>A string representation.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ToString(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to its equivalent string with formatting.
            </summary>
            <remarks>
            This prints the date and time using a universal format (yyyy-MM-ddTH:mm:ss.fffffffzzz) 
            that provides full precision as well as timezone offset. Because a universal pattern is 
            used, formatProvider is inconsequential.
            </remarks>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information.
            Because a universal pattern is used, this parameter is inconsequential.</param>
            <returns>A string representation of value of this instance as specified by provider.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">If the format provider is not valid.</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ConvertToUtc(System.DateTime,Hca.Common.DataType.TimeZoneInfo)">
            <overloads>Converts a <see cref="T:System.DateTime"/> object from the specified <see cref="T:System.TimeZone"/> to UTC.</overloads>
            <summary>
            Converts a <see cref="T:System.DateTime"/> object from the specified <see cref="T:System.TimeZone"/> to UTC with no precision..
            </summary>
            <param name="dateTime">A <see cref="T:System.DateTime"/> object in the specified <see cref="T:System.TimeZone"/>.</param>
            <param name="fromTimeZone">The <see cref="T:System.TimeZone"/> to convert from.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> object.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ConvertToUtc(System.DateTime,Hca.Common.DataType.TimeZoneInfo,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> object from the specified <see cref="T:System.TimeZone"/> to UTC with a specified precision.
            </summary>
            <param name="dateTime">A <see cref="T:System.DateTime"/> object in the specified <see cref="T:System.TimeZone"/>.</param>
            <param name="fromTimeZone">The <see cref="T:System.TimeZone"/> to convert from.</param>
            <param name="precision">The precision of the time.</param>
            <returns>A <see cref="T:Hca.Common.DataType.UtcDateTime"/> object.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ConvertFromUtc(System.DateTime,Hca.Common.DataType.TimeZoneInfo)">
            <overloads>Converts a date time object from UTC to the specified <see cref="T:System.TimeZone"/>.</overloads>
            <summary>
            Converts a <see cref="T:System.DateTime"/> object from UTC to the specified <see cref="T:System.TimeZone"/>.
            </summary>
            <param name="dateTime">A <see cref="T:System.DateTime"/> object in UTC.</param>
            <param name="toTimeZone">The <see cref="T:System.TimeZone"/> to convert to.</param>
            <returns>A <see cref="T:System.DateTime"/> object in the specified <see cref="T:System.TimeZone"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.ConvertFromUtc(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.TimeZoneInfo)">
            <summary>
            Converts a <see cref="T:Hca.Common.DataType.UtcDateTime"/> object to the specified <see cref="T:System.TimeZone"/>.
            </summary>
            <param name="dateDateTime">A <see cref="T:Hca.Common.DataType.UtcDateTime"/> to convert from.</param>
            <param name="toTimeZone">The <see cref="T:System.TimeZone"/> to convert to.</param>
            <returns>A <see cref="T:System.DateTime"/> object in the specified <see cref="T:System.TimeZone"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.Convert(System.DateTime,Hca.Common.DataType.TimeZoneInfo,Hca.Common.DataType.TimeZoneInfo)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> object from one <see cref="T:System.TimeZone"/> to another.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> object to convert.</param>
            <param name="fromTimeZone">The <see cref="T:System.TimeZone"/> to convert from.</param>
            <param name="toTimeZone">The <see cref="T:System.TimeZone"/> to convert to.</param>
            <returns>A <see cref="T:System.DateTime"/> object in the specified <see cref="T:System.TimeZone"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.GetOffset(System.DateTime,Hca.Common.DataType.TimeZoneInfo)">
            <summary>
            Gets the Offset in milliseconds from UTC time for the specified date in the specified timezone.
            The offset is adjusted for daylight savings time.  This is the offset to add TO UTC to get
            local time. To convert local time to UTC time, subtract this offset from the local time.
            </summary>
            <remarks>
            There was a validation section in this method in a previous version of this
            class, but I removed it since we are passing in a valid date, now, instead of
            a list of date elements (year, month, etc.).
            </remarks>
            <param name="dateTime">The date-time to find the offset for.</param>
            <param name="info">The timezone that the date is specified in.</param>
            <returns>The offset in milliseconds to add TO UTC time.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.compareToRule(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Hca.Common.DataType.TimeZoneInfo.DaylightSavingMode,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Compare a given date in the year to a rule. Return 1, 0, or -1, depending
            on whether the date is after, equal to, or before the rule date. The
            millis are compared directly against the <paramref name="ruleMillis"/>, so any
            standard-daylight adjustments must be handled by the caller.
            </summary>
            <exception cref="T:System.OverflowException">If any of the comparison expressions overflow.</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.AdjustForPrecision(System.Int64,Hca.Common.DataType.UtcDateTime.Precision)">
            <summary>
            This method adjusts the given time to the precision as
            set on this instance.
            </summary>
            <param name="ticks">The current ticks to adjust.</param>
            <param name="precision">The precision to use to adjust the time</param>
            <returns>The adjusted number of ticks for the current precision</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.CompareTo(System.Object)">
            <summary>
            Two <see cref="T:Hca.Common.DataType.UtcDateTime"/> Compare equal if their datetime values compare equal
            </summary>
            <param name="obj"></param>
            <returns>
            <list type="table">
            <listheader>
            	<term>Value</term>
            	<term>Description</term>
            </listheader>
            <item>
            	<description>Less than zero</description>
            	<description>This instance is less than value.</description>
            </item>
            <item>
            	<description>Zero</description>
            	<description>This instance is equal to value.</description>
            </item>
            <item>
            	<description>Greater than zero</description>
            	<description>This instance is greater than value, or value is <see langword="null"/>.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if type is not a <see cref="T:Hca.Common.DataType.UtcDateTime"/></exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.op_GreaterThan(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.UtcDateTime)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.DataType.UtcDateTime"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.op_LessThan(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.UtcDateTime)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.DataType.UtcDateTime"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.op_GreaterThanOrEqual(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.UtcDateTime)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.DataType.UtcDateTime"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.op_LessThanOrEqual(Hca.Common.DataType.UtcDateTime,Hca.Common.DataType.UtcDateTime)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.DataType.UtcDateTime"/>
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTime.System#IConvertible#ToDateTime(System.IFormatProvider)">
            <summary>
            Implemented to support the <see cref="T:System.IConvertible"/> interface, using <see cref="T:System.DateTime"/>'s implementation. 
            The <see cref="T:System.DateTime"/> returned will be UTC, not local time.
            </summary>
            <param name="provider">Not used.</param>
            <returns>A <see cref="T:System.DateTime"/> whose value is expressed in terms of UTC.</returns>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Date">
            <summary>
            Gets the date component of this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Hour">
            <summary>
            Gets the hour component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Millisecond">
            <summary>
            Gets the milliseconds component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Minute">
            <summary>
            Gets the minute component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Second">
            <summary>
            Gets the second component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.Ticks">
            <summary>
            Gets the number of ticks that represent the date and time of this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.TimeOfDay">
            <summary>
            Gets the TimeOfDay component of this instance.
            </summary>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.RawText">
            <summary>
            Provides the textual view of UtcDateTime in the "yyyy-MM-ddTH:mm:ss.fffffffzzz" format
            </summary>
            <remarks>
            This class is intended to be immutable and not updated via this property. It is only provided
            to allow fine grain control for XML serialization. There is not other way
            to achieve this control with .NET 1.1. .NET 2.0 provides support for mixing
            XML attributes and <see cref="T:System.Xml.Serialization.IXmlSerializable"/> methods.
            </remarks>
        </member>
        <member name="P:Hca.Common.DataType.UtcDateTime.InternalValue">
            <summary>
            This overrides the base class' setter so that the time elements aren't trimmed.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.UtcDateTime.Precision">
            <summary>
            This class defines the precision to use when storing a time value
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.UtcDateTime.Precision.SqlServer">
            <summary>
            Sets the precision to ~ 10^3 or 3.33 msec
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.UtcDateTime.Precision.Db2">
            <summary>
            Sets the precision to 10^6
            </summary>
        </member>
        <member name="F:Hca.Common.DataType.UtcDateTime.Precision.Full">
            <summary>
            Sets the precision to 10^9 which is .NET's value for <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="T:Hca.Common.DataType.UtcDateTimeConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.DataType.UtcDateTime"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.DataType.UtcDateTime"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <c>string</c>, <see cref="T:Hca.Common.DataType.Date"/>, <see cref="T:System.DateTime"/>, or <see cref="T:Hca.Common.DataType.UtcDateTime"/> is assignable from <paramref name="sourceType"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is string or assignable from <see cref="T:Hca.Common.DataType.Date"/>, <see cref="T:System.DateTime"/>, or <see cref="T:Hca.Common.DataType.UtcDateTime"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.UtcDateTimeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.DataType.UtcDateTimeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.DataType.UtcDateTimeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.DataType.Date"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.Logger.ForcedLogger">
            <summary>
            Provides the capability to override a logger's configured level.
            </summary>
            <remarks>
            Loggers are configured to log at a certain level and higher.
            This configuration is usually in a <c>config</c> file. At times,
            especially during unit testing, it may be convenient to override
            a default log setting. This class supports forcing a logger
            to a <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level remembering its original level.
            <p/>
            This class is a disposable class so it may be used in a using statement.
            </remarks>
            <example>
            An example use without a using statement:
            <code>
            HcaLogger.ForcedDebugOn(typeof(HashCodeGenerator));
            int hash1 = HashCodeGenerator.CalculateHashCode(ATrain1);
            log.Debug("++++++++++++++++++++++++++++++++++++++");
            int hash2 = HashCodeGenerator.CalculateHashCode(ATrain2);
            HcaLogger.ForcedDebugOff(typeof(HashCodeGenerator));
            </code>
            An example use with a using statement:
            <code>
            using (HcaLogger.ForcedDebugOn(typeof(ValueComparator)))
            {
              bool isEqual1 = ValueComparator.IsEqual(passTrain1, passTrain2);
              Assert.IsTrue(isEqual1, "The TestClassWithReciprocalRelationships test #1 was not true");
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Logger.ForcedLogger.#ctor(System.String)">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Logger.ForcedLogger"/>.</overloads>
            <summary>
            Constructor that takes the name of the logger to toggle.
            </summary>	
            <param name="name">The name of the logger to toggle.</param>
        </member>
        <member name="M:Hca.Common.Logger.ForcedLogger.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor that takes the name of the logger to toggle and a flag to turn on debugging.
            </summary>	
            <param name="name">The name of the logger to toggle.</param>
            <param name="toggleOn"><see langword="true"/> if debug should be turned on. <see langword="false"/> will restore the original level.</param>
        </member>
        <member name="M:Hca.Common.Logger.ForcedLogger.ToggleDebug(System.Boolean)">
            <summary>
            Turn debug on or off
            </summary>
            <param name="toggleOn"><see langword="true"/> for on</param>
        </member>
        <member name="M:Hca.Common.Logger.ForcedLogger.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Hca.Common.Logger.HcaLogger">
            <summary>
            This class is the logger that should be used in all situations. It is a wrapper
            around the actual logging framework.
            </summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <p>
            This class is the logger that should be used for all classes. It wraps the 
            actual logging framework. This is a wrapper delegating the calls to the lower
            logging framework. It allows a consistent method to invoke logging while allowing
            the capability to change out the actual implementation at a later time. At this time
            the framework wraps Log4net, <see href="http://www.sf.net/projects/log4net"/>.</p>
            
            <p>
            The severity of logging level is the following: <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/>, <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/>, 
            <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/>, <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/>, <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/>. So, if you
            set the severity to WARN, then only FATAL, ERROR, and WARN messages will be logged.</p>
            
            <p>
            By default, all objects passed to the logger will have their <c>ToString()</c> called unless
            a specific object renderer has been defined for that object type.</p>
            
            <p>
            You should configure the logger with a file ending in HcaDevBlockCommon.dll.log4net 
            in the app domain's base directory. The logger will configure itself and 
            watch the file for any changes.	
            </p>
            
            <p>
            If you need to interleave log messages based on context, then see log4net's NDC.
            </p>
            </remarks>	
            <example>
            The typical usage for <see cref="T:Hca.Common.Logger.HcaLogger"/> is the following:
            	<hcaExample desc="Logger Usage">
            	<code>
            	public class Class1
            	{
            		private static readonly HcaLogger log = HcaLogger.GetLogger(typeof(Class1));
            	
            		#region other things
            		// ...
            		#endregion
            	}
            	</code>
            	</hcaExample>
            </example>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.#cctor">
            <overloads><see cref="T:Hca.Common.Logger.HcaLogger"/> constructors.</overloads>
            <summary>
            <see langword="static"/> constructor to initialize the logger.
            </summary>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ForcedDebugOn(System.String)">
            <overloads>Force a logger level to <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/>.</overloads>
            <summary>
            Force a logger specified by name to <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level. 
            </summary>
            <remarks>
            <see cref="T:Hca.Common.Logger.HcaLogger"/> will return the original
            logger level and will restore it on a toggle
            off. Note that you can toggle by log hierarchies.
            For instance, you can toggle "Hca" or "Hca.Common" or ...
            </remarks>
            <param name="name">The name of the logger to toggle.</param>
            <returns><see cref="T:System.IDisposable"/> so it can be used in using statement</returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ForcedDebugOff(System.String)">
            <overloads>Force a logger level from <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> to its original level.</overloads>
            <summary>
            Force a logger specified by name from <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> to its original level. 
            </summary>
            <remarks>
            <see cref="T:Hca.Common.Logger.HcaLogger"/> will return the original
            logger level and will restore it on a toggle
            off. Note that you can toggle by log hierarchies.
            For instance, you can toggle "Hca" or "Hca.Common" or ...
            </remarks>
            <param name="name">The name of the logger to toggle.</param>
            <returns><see cref="T:System.IDisposable"/> so it can be used in using statement</returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ForcedDebugOn(System.Type)">
            <summary>
            Force a logger specified by <see cref="T:System.Type"/> to <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.
            </summary>
            <remarks>
            <see cref="T:Hca.Common.Logger.HcaLogger"/> will return the original
            logger level and will restore it on a toggle
            off. Note that you can toggle by log hierarchies.
            For instance, you can toggle "Hca" or "Hca.Common" or ...
            </remarks>
            <param name="type">The type of the logger to toggle.</param>
            <returns><see cref="T:System.IDisposable"/> so it can be used in using statement</returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ForcedDebugOff(System.Type)">
            <summary>
            Force a logger specified by <see cref="T:System.Type"/> from <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> to its original level. 
            </summary>
            <remarks>
            <see cref="T:Hca.Common.Logger.HcaLogger"/> will return the original
            logger level and will restore it on a toggle
            off. Note that you can toggle by log hierarchies.
            For instance, you can toggle "Hca" or "Hca.Common" or ...
            </remarks>
            <param name="type">The type of the logger to toggle.</param>
            <returns><see cref="T:System.IDisposable"/> so it can be used in using statement</returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.GetLogger(System.String)">
            <overloads>Retrieves a logger.</overloads>
            <summary>
            Return a logger for the given name.
            </summary>
            <param name="name">Name of logger</param>
            <returns><see cref="T:Hca.Common.Logger.HcaLogger"/></returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.GetLogger(System.Type)">
            <summary>
            Return a logger for the given type.
            </summary>
            <param name="type">Name of logger. Type will resolve to a logger with dot notation.
            </param>
            <returns><see cref="T:Hca.Common.Logger.HcaLogger"/></returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ConfigureLoggingSystem">
            <summary>
            Configure logging system.
            </summary>
            <remarks>
            This method will first check and see if a configuration setting is available with a
            key of <c>Hca.Common.Logger.LogConfigurationFile</c>. If found, then its
            value is used to indicate the path and file name for the configuration file.
            Otherwise, it will look for a file in AppDomain's base directory that ends in 
            logging.config. If it does not find one, 
            then a basic configuration will be setup that outputs to the console only.
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ResetConfiguration">
            <summary>
            Reset logging configuration so it can be reconfigured.
            </summary>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ConfigureLoggingSystem(System.IO.Stream)">
            <summary>
            Configure logging system with DOM configuration stream.
            </summary>
            <param name="domConfigStream">Stream to configure system.</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ConfigureLoggingSystem(System.IO.FileInfo)">
            <summary>
            Configure logging system with DOM file.
            </summary>
            <param name="domConfigFile">File to configure system.</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.ConfigureLoggingSystemAndWatchFile(System.IO.FileInfo)">
            <summary>
            Configure logging system with DOM file and watch it for changes.
            </summary>
            <param name="domConfigFile">File to configure system.</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.NDCPush(System.String)">
            <summary>
            Create a nested diagnostic context.
            </summary>
            <remarks>
            You can use this in a using statement so it will pop automatically.
            
            </remarks>
            <param name="message">Name of context.</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.NDCPop">
            <summary>
            Pop current NDC
            </summary>
            <returns>name of context popped</returns>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.Object)">
            <overloads>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.</overloads>
            
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.</summary>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.Object)">
            <overloads>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level.</overloads>
            
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level.</summary>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.Object)">
            <overloads>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level.</overloads>
            
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level.</summary>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.Object)">
            <overloads>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level.</overloads>
            
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level.</summary>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.Object)">
            <overloads>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level.</overloads>
            
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level.</summary>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.Exception,System.Object)">
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="value">The value to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.Exception,System.Object)">
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="value">The value to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.Exception,System.Object)">
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="value">The value to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.Exception,System.Object)">
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="value">The value to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.Exception,System.Object)">
            <summary>Logs a value at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="value">The value to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.String)">
            <overloads>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.</overloads>
            
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.</summary>
            <param name="message">The message to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.String)">
            <overloads>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level.</overloads>
            
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level.</summary>
            <param name="message">The message to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.String)">
            <overloads>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level.</overloads>
            
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level.</summary>
            <param name="message">The message to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.String)">
            <overloads>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level.</overloads>
            
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level.</summary>
            <param name="message">The message to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.String)">
            <overloads>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level.</overloads>
            
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level.</summary>
            <param name="message">The message to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.Exception,System.String)">
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.Exception,System.String)">
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.Exception,System.String)">
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.Exception,System.String)">
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.Exception,System.String)">
            <summary>Logs a message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Debug(System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Info(System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Warn(System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Error(System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Fatal(System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="message">The parameterized message to log.</param>
            <param name="ex">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.Object)">
            <overloads>Logs a value at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.</overloads>
            
            <summary>Logs a value at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="value">The value to log.</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.Exception,System.Object)">
            <summary>Logs a value at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="value">The value to log.</param>
            <param name="exc">The <see cref="T:System.Exception"/> to log</param>
            <remarks>ToString() will not be called if the log level is not enabled.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.String)">
            <summary>Logs a message at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="message">The message to log.</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.Exception,System.String)">
            <summary>Logs a message at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="message">The message to log.</param>
            <param name="exc">The <see cref="T:System.Exception"/> to log</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.String,System.Object[])">
            <summary>Logs a parameterized message at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="message">The parameterized message to log.</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)"/>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.WriteIfEnabled(Hca.Common.Logger.HcaLogger.LogLevel,System.Exception,System.String,System.Object[])">
            <summary>Logs a parameterized message at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>, including the stack trace of the specified <see cref="T:System.Exception"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="message">The parameterized message to log.</param>
            <param name="exc">The <see cref="T:System.Exception"/> to log</param>
            <param name="formatArgs">The parameters to use when formatting <paramref name="message"/>.</param>
            <remarks>
            <para>Neither ToString() nor Format() will be called if the log level is not enabled.</para>
            <para>This method is implemented in terms of <see cref="M:System.String.Format(System.String,System.Object)"/>. If that method throws an exception, then <paramref name="message"/> will be output without formatting.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Write(Hca.Common.Logger.HcaLogger.LogLevel,System.Object)">
            <summary>Logs a value at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>.</summary>
            <param name="level">The level at which to log.</param>
            <param name="value">The value to log.</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.Write(Hca.Common.Logger.HcaLogger.LogLevel,System.Exception,System.Object)">
            <summary>Logs a value at the specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/>, including the stack trace of the exception.</summary>
            <param name="level">The level at which to log.</param>
            <param name="value">The value to log.</param>
            <param name="exc">The <see cref="T:System.Exception"/> to log</param>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.SafeStringFormat(System.String,System.Object[])">
            <summary>Attempts a <see cref="M:System.String.Format(System.String,System.Object)"/> without throwing any exceptions.</summary>
            <param name="format">A string containing zero or more format items.</param>
            <param name="args">An object array containing zero or more objects to format.</param>
            <returns>A copy of <paramref name="format"/> in which the format items have been replaced by the string equivalent of the corresponding instances of object in <paramref name="args"/>.</returns>
            <remarks>If <see cref="M:System.String.Format(System.String,System.Object)">String.Format</see> throws an exception, then <paramref name="format"/> will be returned without formatting.</remarks>
        </member>
        <member name="M:Hca.Common.Logger.HcaLogger.IsEnabled(Hca.Common.Logger.HcaLogger.LogLevel)">
            <summary>Is a specified <see cref="T:Hca.Common.Logger.HcaLogger.LogLevel"/> enabled?</summary>
            <param name="level">The level to check.</param>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.Configured">
            <summary>
            A property that indicates if the logger repository has been configured.
            </summary>
            <remarks>
            A configured repository means that the logger has digested a configuration
            file telling it what appenders and in what format to emit a log.  
            </remarks>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.IsDebugEnabled">
            <summary>
            Is debug enabled?
            </summary>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.IsInfoEnabled">
            <summary>
            Is info enabled? 
            </summary>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.IsWarnEnabled">
            <summary>
            Is warn enabled? 
            </summary>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.IsErrorEnabled">
            <summary>
            Is error enabled? 
            </summary>
        </member>
        <member name="P:Hca.Common.Logger.HcaLogger.IsFatalEnabled">
            <summary>
            Is fatal enabled? 
            </summary>
        </member>
        <member name="T:Hca.Common.Logger.HcaLogger.LogLevel">
            <summary>This is the Logging Levels as wrapped by this logger.</summary>
        </member>
        <member name="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug">
            <summary>The <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level is the lowest level used for diagnostics.</summary>
        </member>
        <member name="F:Hca.Common.Logger.HcaLogger.LogLevel.Info">
            <summary>The <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/> level is intended for information detail.</summary>
        </member>
        <member name="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn">
            <summary>The <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> level is intended to indicate potential problems.</summary>
        </member>
        <member name="F:Hca.Common.Logger.HcaLogger.LogLevel.Error">
            <summary>The <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> level is intended to indicate a condition that may cause system failure or bad data if not handled.</summary>
        </member>
        <member name="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal">
            <summary>The <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> level is intended to indicate a condition cannot be recovered from by the application.</summary>
        </member>
        <member name="T:Hca.Common.Logger.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	Logging is an essential software component that provides important diagnostic information to both 
            	application authors and system administrators. This section describes the requirements that shaped 
            	the design and implementation of the logging component located in the <see cref="N:Hca.Common.Logger"/> namespace.
            	<hcaNote>
            		HCA logging uses Log4Net to implement logging functionality. Log4Net contains 
            		in-depth documentation on configuration and usage. This information is not duplicated here. 
            		For more information about Log4Net, refer to the Log4Net documentation on their 
            		website.
            	</hcaNote>
            
            	<h3 class="dtH3">References</h3>
            	The following works are referenced in this SDK:
            	<para/>
            	<i>Table 1: Referenced Works</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Label</th>
            				<th width="50%">Title</th>
            				<th width="30%">Reference</th>
            			</tr>
            			<tr>
            				<td>LOG4NET</td>
            				<td>Log4Net Website</td>
            				<td>
            					<see href="http://logging.apache.org/index.html"/> (future)
            					<br/>
            					<see href="http://sf.net/projects/log4net"/>
            				</td>
            			</tr>
            			<tr>
            				<td>FAQ</td>
            				<td>Log4Net FAQ</td>
            				<td><see href="http://log4net.sourceforge.net/release/1.2.0.30714/doc/manual/faq.html"/></td>
            			</tr>
            			<tr>
            				<td>LOG4J</td>
            				<td>Log4J Website</td>
            				<td><see href="http://logging.apache.org/"/></td>
            			</tr>
            			<tr>
            				<td>APPENDERS</td>
            				<td>Log4Net Appenders Examples</td>
            				<td>
            					<see href="http://log4net.sourceforge.net/release/1.2.0.30714/doc/manual/example-config-appender.html"/>
            				</td>
            			</tr>
            			<tr>
            				<td>BARETAIL</td>
            				<td>BareTail software</td>
            				<td><see href="http://www.baremetalsoft.com/baretail/index.php"/></td>
            			</tr>
            			<tr>
            				<td>TEXTPAD</td>
            				<td>TextPad software</td>
            				<td><see href="http://www.textpad.com"/></td>
            			</tr>
            			<tr>
            				<td>CYGWIN</td>
            				<td>CYGWIN software</td>
            				<td><see href="http://www.cygwin.com"/></td>
            			</tr>
            		</table>
            	</div>
            
            	<h3 class="dtH3">Requirements</h3>
            	The following requirements describe the constraints and functional needs placed on Logging:
            	<list type="bullet">
            		<item>
            			Logging statements should reside in deployed code without adversely effecting the
            			application.
            		</item>
            		<item>It should support multiple logging sources and output sinks.</item>
            		<item>It should allow selective control of output with arbitrary granularity.</item>
            		<item>It should be easy to configure and be able to reconfigure at runtime.</item>
            		<item>It should provide a logging context to handle interleaving log sources.</item>
            		<item>
            			It should wrap as best it can the underlying logging implementation decoupling
            			it from the calling system.
            		</item>
            	</list>
            
            	<h3 class="dtH3">Tenets</h3>
            	Users of the framework should adhere to the following items:
            	<list type="bullet">
            		<item>
            			Use a <c>RollingFileAppender</c> to log output for developer's purposes. By default, 
            			no <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> logging should be occurring within production. Don't forget that your 
            			web application must have rights to write to this directory which by default is 
            			<i>Log</i>.
            		</item>
            		<item>
            		Use <c>TraceAppender</c> to log output to Visual Studio's Output window.
            	</item>
            		<item>
            			All system exceptions should be logged. Logging of Application Exceptions is 
            			dependent on the application's design.
            		</item>
            		<item>
            			Debug statements should first check that debug is enabled in situations where 
            			performance is crucial. This ensures that the log string is not needlessly 
            			constructed.
            		</item>
            		<item>
            			Do not configure the logger through an application or web configuration file by 
            			using <c>Log4Net</c>'s configuration mechanism but use the configuration techniques 
            			provided by this component. This means the configuration of the logging system 
            			is through a file located at the application domain's base directory or through 
            			a configuration setting in the application or web config file.
            			<hcaNote>
            				An application configuration file is an <c>applicationname.exe.config</c> file where a web 
            				configuration file is <c>web.config</c>. These files are used by the applications to abstract 
            				out configuration information.
            			</hcaNote> 
            		</item>
            		<item>
            			The default production setup should be as follows.  Keep in mind that the logging
            		configuration file can be edited in production to assist with problem resolution.
            		<list type="bullet">
            				<item>
            				Applications should log only <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/>
            				and higher events to a <c>RollingFileAppender</c>.
            				</item>
            				<item>
            				Events of types <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> and
            				<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> should
            				be the only events logged to the <c>EventLogAppender</c>.  This allows BSSC to
            				monitor the application and open trouble tickets for the application stating
            				the description of the log message. The levels are used to set ticket severity levels.
            				</item>
            		</list>
            		</item>
            	</list>
            
            	<h2 class="dtH2">Design</h2>
            	HCA Logger consists of one component that wraps the underlying logging framework. This 
            	design was chosen to insulate applications, frameworks, and class libraries from being 
            	coupled to any specific logging framework. This is especially important since loggers 
            	are used throughout most classes and coupling to any logging framework would require 
            	massive code changes.
            	<h3 class="dtH3">HcaLogger</h3>
            	This class defines each of the following log levels:
            	<i>Table 2: Logging Levels</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Level</th>
            				<th width="80%">Purpose</th>
            			</tr>
            			<tr>
            				<td><see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/></td>
            				<td>Diagnostic logging</td>
            			</tr>
            			<tr>
            				<td><see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/></td>
            				<td>Communicate information logging</td>
            			</tr>
            			<tr>
            				<td><see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/></td>
            				<td>Indicates a potential problem</td>
            			</tr>
            			<tr>
            				<td><see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/></td>
            				<td>Indicates a potential severe problem or bad data</td>
            			</tr>
            			<tr>
            				<td><see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/></td>
            				<td>Indicates that the application is broken</td>
            			</tr>
            		</table>
            	</div>
            	<para/>
            	Each log event has a log level. The levels are used to filter log events for each 
            	appender. An appender is a logging sink that consumes log events. An appender defines
            	what range of log level events it consumes and the format of its output. 
            	<see cref="T:Hca.Common.Logger.HcaLogger"/> wraps [log4net], a logger ported from [log4j]. 
            	Log4j has been ported to 12 languages and is considered the premier logging system for 
            	applications and frameworks. It is a hierarchical logging system that makes it an ideal 
            	design for component-based development, allowing each component to have its own logger. 
            	This fine grain control allows selective output of logging events. It supports easy 
            	configuration through a XML file or direct programmatic control. Finally, it can collect 
            	logging context data and attach it to log messages. 
            	<para/>
            	You configure the logging framework through a XML file found with the Common 
            	Framework DLL or you can add a configuration setting indicating the location of this 
            	file. If a configuration file is not found, the logger will output a message to 
            	<see cref="T:System.Diagnostics.Trace"/> and <see cref="T:System.Diagnostics.Debug"/>, indicating 
            	that the logger was not configured. If the file is found, then it is digested and watched for 
            	any future changes. This allows you to modify the logger at runtime.
            
            	<h2 class="dtH2">Usage</h2>
            	This section describes the configuration of HCA logger and its typical usage.
            
            	<h3 class="dtH3">Configuration</h3>
            	HCA logger looks for a file named <c>logging.config</c>. This file should reside with 
            	the Common DLL or an application/web configuration setting should be made 
            	which indicates the location of this file (see example 1 below). If an application/web 
            	configuration setting is used, then the configuration file may have any name. The 
            	logging file is the configuration file used to configure Log4Net and subsequently 
            	HCA Logger (see example 2 below).
            	<para/>
            	<hcaExample desc="Application Configuration">
            		<code>
            <![CDATA[<?xml version="1.0" encoding="utf-8"?>
            <configuration>
            	<appSettings>
            		<add key="Hca.Common.Logger.LogConfigurationFile" value="E:\net-projects\SBBCommon\LogExample\logging.config"/>
            	</appSettings>
            </configuration>]]>
            		</code>
            	</hcaExample>
            	<para/>
            <para>
            	Following is an example from the DevPack templates of the default logging configuration for production.
            	</para>
            	<hcaExample desc="Production Logging Configuration">
            		<code>
            <![CDATA[<?xml version="1.0" ?>
            	<log4net threshold="ALL">
            		<appender name="AppRollingFileAppender" type="log4net.Appender.RollingFileAppender">
            			<param name="Threshold" value="ALL"/>
            			<param name="File" value="Log\\log-file.txt" />
            			<param name="AppendToFile" value="true" />
            			<param name="MaxSizeRollBackups" value="-1" />
            			<param name="RollingStyle" value="Date" />
            			<param name="StaticLogFileName" value="true" />
            			<param name="CountDirection" value="-1" />
            			<param name="DatePattern" value="yyyyMMdd" />
            			<layout type="log4net.Layout.PatternLayout">
            				<param name="ConversionPattern" value="%date [%level] %property{log4net:HostName} (%thread) %logger [%ndc] - %message%newline" />
            			</layout>
            		</appender>
            
            		<!-- Event Appenders -->
            		<appender name="AppEventLogAppender" type="log4net.Appender.EventLogAppender">
            			<param name="Threshold" value="ERROR"/>
            			<param name="LogName" value="zMonitor"/>
            			<param name="ApplicationName" value="@project.short.name@"/>
            			<layout type="log4net.Layout.PatternLayout">
            				<param name="ConversionPattern" value="DevBlocks : %date [%level] %property{log4net:HostName} (%thread) %logger [%ndc] - %.1200message%newline" />
            			</layout>
            		</appender>
            
            		<!-- Application Sink loggers -->
            		<root>
            			<appender-ref ref="AppRollingFileAppender" />
            			<appender-ref ref="AppEventLogAppender"/>
            		</root>
            
            		<!-- DevBlocks Sink loggers -->
            		<logger name="Hca.Common">
            			<level value="ERROR" />
            		</logger>
            		<logger name="Hca.Framework">
            			<level value="ERROR" />
            		</logger>
            		<logger name="Hca.Facility">
            			<level value="ERROR" />
            		</logger>
            	</log4net>]]>
            	</code>	
            	</hcaExample>
            <para>
            	This file can serve as a good introduction to the structure of a logging configuration
            	file.  It is basically the bare minimum necessary to configure production logging.  It
            	includes two appenders, a <c>RollingFileAppender</c> and an <c>EventLogAppender</c>.  Additionally,
            	it includes several event sinks.
            	</para>
            	<para>
            	The <c>RollingFileAppender</c> is configured to accept events of any type.  The events are
            	filtered at another location that will be discussed shortly.  Currently, it writes its events to
            	a file name <c>log-file.txt</c> in a folder named <c>Log</c> at the application root.  At
            	production deployment time, you should include a build step to change this value to the appropriate
            	logging location for the environment.  Consult WinTel deployment procedures for more information.
            	</para>
            	<para>
            	The <c>EventLogAppender</c> is configured to accept events only of type
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> or 
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/>.  It writes them to a special Windows Event
            	Log named <c>zMonitor</c>.  This event log is monitored by devices that will open trouble tickets for the application
            	with the event message.  The value of the <c>ApplicationName</c> is
            	configurable for your application.  It is the value that will appear in the Windows Event Log
            	source and is the value by which the monitoring tool uses to deliver the trouble ticket.
            	</para>
            	<para>
            	The <c>root</c> element is the default configuration for event log sinks.  This element is required by
            	log4net.  The current configuration filters events only to those of type
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> and higher and forwards those to both
            	the <c>RollingFileAppender</c> and the <c>EventLogAppender</c>.  Again, for this example, those
            	appenders then filter based on their rules.  The <c>RollingFileAppender</c> will log anything that
            	comes to it, and the <c>EventLogAppender</c> will only log
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> or
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> events.
            	</para>
            	<para>
            	The individual <c>logger</c> elements are used to impose additional filtering limitations on
            	DevBlocks, as they will use this logging configuration as well.  This is also a feature that you
            	can customize for your purposes if you need to set different filtering levels for different namespaces
            	in your solution.
            	</para>
            	<h3 class="dtH2">Further Examples</h3>
            	<hcaExample desc="Logging Configuration">
            		<code>
            <![CDATA[<?xml version="1.0" ?>
            <log4net>
            	<!-- Define some output appenders -->
            	<appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender">
            		<layout type="log4net.Layout.PatternLayout">
            			<param name="ConversionPattern" value="%d [%t] %-5p [%c{1}] [%x] &lt;%X{auth}&gt; - %m%n" />
            		</layout>
            	</appender>
            	<appender name="TraceAppender" type="log4net.Appender.TraceAppender">
            		<layout type="log4net.Layout.PatternLayout">
            			<param name="ConversionPattern" value="%d [%t] %-5p [%c{1}] [%x] &lt;%X{auth}&gt; - %m%n" />
            		</layout>
            	</appender>		
            				
            	<!-- Setup the root category, add the appenders and set the default level -->
            	<root>
            		<level value="WARN" />
            		<appender-ref ref="ConsoleAppender" />
            		<appender-ref ref="TraceAppender" />
            	</root>
            				
            	<!-- Specify the level for some specific categories -->
            	<logger name="Hca">
            		<level value="ALL" />
            	</logger>
            	    <logger name="Hca.MyApp.Web">
            			<level value="ERROR" />
            	    </logger>
            	    <logger name="Hca.MyApp.SomeService">
            			<level value="WARN" />
            	    </logger>
            </log4net>]]>
            		</code>
            	</hcaExample>
            	<para/>
            	Some highlights from this configuration file include:
            	<list type="bullet">
            		<item>
            			Two appenders defined - <c>Console</c> and <c>Trace</c>. These communicate to the 
            			console and trace output. <c>Trace</c> is used to see output within Visual Studio's output 
            			screen.
            			<hcaNote>
            				<c>TRACE</c> constant must be defined as a conditional compilation constant for 
            				your project to see output.
            			</hcaNote>
            		</item>
            		<item>
            			For both appenders, the log output pattern will produce the following output: 
            			<br/>
            			<code>2004-01-19 08:06:32,274 [STATestRunner] INFO  [HcaLogger] [] &lt;&gt; - message.</code>
            		</item>
            		<item>
            			Two special loggers are defined to customize the logging for "MyApp".  Class is the
            			<c>Hca.MyApp.Web</c> namespace will only write events of type
            			<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/> and higher.  Whereas classes
            			in the namespace <c>Hca.MyApp.SomeService</c> write events of type
            			<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> and higher.
            		</item>
            	</list>
            	<para/>
            	For more information on log output pattern, see Log4Net API for <c>PatternLayout</c> class. 
            	For a more complete logging configuration file, see the <c>logging.config</c> supplied in 
            	the distribution file for <see cref="N:Hca.Common"/>.
            
            	<h2 class="dtH2">Best Practices</h2>
            	Logging is an essential part of any application, framework, or class library. It 
            	provides important diagnostic information to the user and developer. Determining what 
            	to see and where to output the log events is normally the most difficult part in logging
            	and determined by the needs of developers and system administrators. It is important to 
            	log as much diagnostic information as possible.
            
            	<h3 class="dtH3">Configuration</h3>
            	The best practice for the logger configuration includes:
            	<list type="bullet">
            		<item>
            			Determine what appenders need to be defined. [Appenders] are log events sinks. 
            			Log4net comes with many out-of-the-box appenders and the ability to define new ones.
            		</item>
            		<item>Define the root logger.</item>
            		<item>Define any application-level loggers.</item>
            	<item>
            		Refer to the documentation for any other DevBlocks that you consume.  They may have
            		additional logging configuration requirements.  
            		</item>
            	</list>	
            	
            	<h3 class="dtH3">Defining a Logger</h3>
            	Typically, a logger is defined for each class. The logger is named with the class' fully 
            	qualified name. This allows fine-grain control over what is and is not logged to appenders. 
            	If you would like to use a logger that represents a tier or a component that covers a set 
            	of classes, then define it with an appropriate name.
            	<para/>
            	<hcaExample desc="Defining a Logger">
            	<code>
            	public class Class1
            	{
            		private static readonly HcaLogger log = HcaLogger.GetLogger(typeof(Class1));
            	
            		#region other things
            		// ...
            		#endregion
            	}
            	</code>
            	</hcaExample>
            
            	<h3 class="dtH3">Using a Logger</h3>
            	Once a logger is defined, it can now be used to output diagnostic information.
            	<para/>
            	<hcaExample desc="Using a Logger">
            		<code>
            			log.Debug("A debug message.");
            		</code>
            	</hcaExample>
            	<para/>
            <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> will ensure debugging is enabled before logging debug messages, so 
            under normal usage it is not necessary to check that debugging is enabled before usage. However, if a series of operations need to be 
            performed for <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> logging, 
            it is recommended to wrap those operations in a conditional branch. 
            	<para/>
            	<hcaExample desc="Using a a debug Logger wrapped in a conditional">
            		<code>
            if(log.IsDebugEnabled)
            {
            	StringBuilder sb = new StringBuilder();
            	sb.Append("This is some simple debugging");
            	sb.Append(System.Environment.NewLine);
            	sb.Append("This is some more simple debugging information.");
            	log.Debug(sb.ToString());
            }
            		</code>
            	</hcaExample>
            
            	<h4 class="dtH4">Rolling File Logging</h4>
            	This appender provides an array of settings, making it very attractive to use as a production 
            	appender. The following sample differs from the recommended setup, but is expanded and documented
            as a demonstration of capabilities:
            	<para/>
            	<hcaExample desc="Defining a Rolling File Appender">
            		<code>
            <![CDATA[<appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
            	<param name="Threshold" value="ALL"/>
            	<param name="File" value="Log\\MyApp.log" />	
            	<param name="AppendToFile" value="true" />
            						
            	<!-- An alternate output encoding can be specified -->
            	<!-- <param name="Encoding" value="unicodeFFFE" /> -->
            						
            	<!-- keep 10 backups before erasing oldest -->
            	<param name="MaxSizeRollBackups" value="10" />
            						
            	<!-- maximum file size is 100 MB-->
            	<param name="MaximumFileSize" value="100MB" />
            	<!-- roll based on date then size -->
            	<param name="RollingStyle" value="Date"/>
            						
            	<!-- We do want to log to the same file. -->
            	<param name="StaticLogFileName" value="false" />
            						
            	<!-- Recommended for infinite backups. It means that the higher number is the latest log. -->
            	<param name="CountDirection" value="-1" />		
            			
            	<!-- This is the default date pattern. This means the roll point would be by day.  -->
            	<param name="DatePattern" value="yyyyMMdd" />	
            	<layout type="log4net.Layout.PatternLayout">
            		<param name="ConversionPattern" value="%d [%t] %-5p [%c{1}] [%x] &lt;%X{auth}&gt; - %m%n" />
            	</layout>
            </appender>]]>
            		</code>
            	</hcaExample>
            	<para/>
            	Highlights from this setup include:
            	<list type="bullet">
            		<item>The appender will append its log output to the current log file.</item>
            		<item>Only 10 backups will be kept after that the oldest backups will be removed.</item>
            		<item>The maximum size for a backup file is 100MB.</item>
            		<item>Backups will be rolled based on the date.</item>
            		<item>The appender will log to the current date log file.</item>
            		<item>The date pattern to use and subsequent determination to roll by date is <b>YYYYMMdd</b>.</item>
            	</list>
            
            	<h4 class="dtH4">Tailing a Log File</h4>
            	If you want to watch a log file for diagnostic purposes, it is helpful to view the log 
            	file with a tool that does not lock the file and outputs the file as it changes. This 
            	is often referred to as <i>tailing the log</i>. Several tools can be used to tail a 
            	log. One is the shareware tool [TEXTPAD]. TextPad informs you if the file changes, 
            	allowing you to refresh the file and look at the current contents. However, a better 
            	method is to use a true tail program such as [BARETAIL]. This is a Windows specific 
            	tail tool. Here is a sample look at tailing a log with BareTail.
            	<para/>
            	<i>Figure 1: Tailing a File with BareTail</i>
            	<br/>
            	<img src="baretail.gif"/>
            	<para/>
            	A final tool that might be used to tail a log file is [CYGWIN]. This is a UNIX 
            	emulating tool. By default, UNIX provides a <i>tail</i> program so users using CYGWIN can 
            	just use the built-in tail program.
            	<para/>
            	<i>Figure 2: Tailing a File with Cygwin</i>
            	<br/>
            	<img src="cygwin.gif"/>
            	<para/>	
            	<h3 class="dtH3">Logging to the Windows Event System</h3>
            	The Windows Event System is used to send application events. These events are sent to 
            	an application source setup in the event system. The application source must be setup 
            	by a user with administrative privileges. The package release of <c>DevPack</c> or <c>ServerPack</c> provides a 
            	console EXE that will create an application event source. Administrative personnel can 
            	run this EXE to create application event sources.  Refer to those distributions for more information.  Also,
            remember that the recommended setup for production is to only log
            <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Fatal"/> events to the custom event log <c>zMonitor</c>.  If
            your solution requires your own event log for other purposes, this will likely require additional
            documentation and approvals.
            	<para/>
            	<hcaExample desc="Logging to the Windows Event System">
            		<code>
            <![CDATA[C:\Program Files\HCA\DevPack\EventSourceBuilder>eventsourcebuilder
            Purpose: Create or delete an event source and / or
            event log on the current machine.
            Usage: EventSourceBuilder.exe [ [/l | /dl] log ]
            			                    [ [/s | /ds | /qs] source ]
            			                    [ /t message]
            Options:
            /l log             Append or create an event log.
                               Must be used in conjunction with /s.
            /dl log            Delete an event log and all registered sources.
            /s source          Create event source.
            /ds source         Delete event source.
            /qs source         Query event source registration.
            /t message         Write test message to the event source.
                               Must be used in conjunction with /s or /qs.
            Examples:
            > EventSourceBuilder /l NewLogName /s NewSourceName
            > EventSourceBuilder /l NewLogName /s NewSourceName /t "hello world!"
            > EventSourceBuilder /ds DeleteSourceName
            > EventSourceBuilder /dl DeleteLogName
            > EventSourceBuilder /qs QuerySourceName]]>
            		</code>
            	</hcaExample>
            	<para/>
            	After setting up an application event source, the <c>EventLogAppender</c> 
            	can now log to it.
            	<para/>
            	<hcaExample desc="Event Log Configuration">
            		<code>
            <![CDATA[<appender name="EventLogAppender" type="log4net.Appender.EventLogAppender">
            	<!-- Only allow WARN and higher levels to be logged -->
            	<param name="Threshold" value="WARN"/>
            	<layout type="log4net.Layout.PatternLayout">
            		<param name="ConversionPattern" value="%d [%t] %-5p [%c{1}] [%x] &lt;%X{auth}&gt; - %m%n" />
            	</layout>
            </appender>]]>
            		</code>
            	</hcaExample>
            	<para/>
            	Notice in the configuration of the <c>EventLogAppender</c>, that a 
            	threshold of <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> was used indicating that only <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> and higher event levels 
            	will be logged. The event log should not be used to output <c>DEBUG</c> or <c>INFO</c> levels. 
            	A file log is a better source for these events.
            	<para/>
            	Let's say your application has a project short name of <i>Hca.DevBlocks.Common</i> and you 
            	want to send all <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/> or higher events to the application event log. 
            	<hcaNote>
            		Project short name refers to the build property that is equivalent to the application's 
            		DLL name.
            	</hcaNote>
            	<para/>
            	To set this up you can use the <c>EventSourceBuilder.exe</c> and type in the following:
            	<hcaExample>
            		<code escaped="true">
            eventsourcebuilder /l zMonitor /s Common
            		</code> 
            	</hcaExample>
            	<para/>
            	Remember that you need administrator privileges. This will create an event source in the 
            	<i>zMonitor</i> log. Your logging configuration defined through DevPack will provide you 
            	with an <c>EventLogAppender</c> setup to log to <i>zMonitor</i> 
            	and source project short name.
            	<para/>
            	Don't forget that you need to repeat the event log setup for all environments – DEV, QA, PROD.
            	<hcaNote>
            		The Event Logging system only considers the first eight characters of the event log sink for 
            		uniqueness. Keep that in mind as you provide the sink name.
            	</hcaNote>
            
            	<h3 class="dtH3">Logging to ASPNET Trace</h3>
            	ASP.NET allows developers to write out diagnostic information to the ASP page.
            
            	<h4 class="dtH4">ASP.NET Header</h4>
            	In order to output to an ASP.NET page, a page directive must be set or the <c>web.config</c> 
            	trace for all ASP.NET pages needs to be turned on. You can view the output of the ASP.NET trace
            	by browsing to your applications URI with 'trace.axd'. For instance, if you application is
            	deployed locally and named 'petstore' then you can view the trace output by browsing to
            	'http://localhost/petstore/trace.axd'.		
            	<para/>
            	<hcaExample desc="ASP.NET Trace Logging Configuration">
            		<code>
            &lt;%@ Page language="c#" Codebehind="WebForm1.aspx.cs" AutoEventWireup="false" 
            Inherits="DevBlocksTesting.WebForm1" trace="True"&gt;
            		</code>
            	</hcaExample>
            	<para/>
            	In order to output to ASP.NET trace, an ASP.NET appender must be defined in the logging 
            	configuration file.
            	<para/>
            	<hcaExample desc="ASP.NET Trace Logging Configuration">
            		<code>
            <![CDATA[<appender name="ASPNetTraceAppender" type="log4net.Appender.ASPNetTraceAppender" >
            	<layout type="log4net.Layout.PatternLayout">
            		<param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" />
            	</layout>
            </appender>
            <appender name="ASPNetTraceAppender" type="log4net.Appender.ASPNetTraceAppender" >
            	<layout type="log4net.Layout.PatternLayout">
            		<param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" />
            	</layout>
            </appender>]]>
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="ASP.NET Code-behind Log Call">
            		<code>
            private void Button1_Click(object sender, System.EventArgs e)
            {
            	HcaLogger log = HcaLogger.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);	
            	log.Debug("Message is logged."); 
            	log.Debug("Next message."); 
            	Class1 test = new Class1();
            	test.test();
            	log.Debug("Next message2."); 
            }
            		</code>
            	</hcaExample>
            
            	<i>Figure 3: ASP.NET Trace Output</i>
            	<br/>
            	<img src="trace_output.gif"/>
            
            	<h3 class="dtH3">Forced Debug Logging</h3>
            	Loggers are typically configured through a log configuration file. This file defines the 
            	levels for specified loggers including defining log appenders. Log levels are hierarchical, 
            	ranging from <c>ALL</c>, <c>TRACE</c>, <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/>, 
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Info"/>, <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Warn"/>, 
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Error"/>, <c>CRITICAL</c>, and <c>FATAL</c>. 
            	Loggers may be explicitly or implicitly defined for a 
            	particular level through the hierarchy of another logger. At least one logger  - <c>ROOT</c> 
            	logger - has a level defined. Applications define the log levels its loggers should write 
            	output for consuming appenders. Though not normal, there are occasions that an application's 
            	logger's particular defined level should be overwritten and forced to a <see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/> level. 
            	Normally, you should modify the configuration file. 
            	<para/>
            	HCA logger is able to override a log's level configuration and force the logger's level to 
            	<see cref="F:Hca.Common.Logger.HcaLogger.LogLevel.Debug"/>. The override retains the original level, allowing you to restore it later. 
            	<para/>
            	<hcaExample desc="Forced Debugging">
            		<code>
            HcaLogger.ForcedDebugOn(typeof(HashCodeGenerator));
            int hash1 = HashCodeGenerator.CalculateHashCode(ATrain1);
            log.Debug("++++++++++++++++++++++++++++++++++++++");
            int hash2 = HashCodeGenerator.CalculateHashCode(ATrain2);
            HcaLogger.ForcedDebugOff(typeof(HashCodeGenerator));
            			
            using (HcaLogger.ForcedDebugOn(typeof(ValueComparator)))
            {
            	bool isEqual1 = ValueComparator.IsEqual(passTrain1, passTrain2);
            	Assert.IsTrue(isEqual1, "The TestClassWithReciprocalRelationships test #1 was not true"); 
            }
            		</code>
            	</hcaExample> 
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	Value types cannot be set to null in .NET (i.e. <see cref="T:System.Int32"/>, <see cref="T:System.Boolean"/>, <see cref="T:System.Single"/>, etc.). 
            	Generally, this isn't a problem. However, when you're writing custom data objects (Value 
            	Objects) that are passed between tiers and/or persistent, you need some way to set the state 
            	of a property to <i>not set</i>. This enables the problem of partial updates to be solved 
            	easily. To meet this need, the value types have been wrapped into objects that can be set to 
            	<see langword="null"/>. 
            
            	<h3 class="dtH3">Requirements</h3>
            	<list type="bullet">
            		<item>These classes must be <i>nullable</i> (able to be set to <see langword="null"/>).</item>
            		<item>
            			They must implicitly and explicitly convert to and from their corresponding value 
            			type.
            		</item>
            		<item>
            			They must be immutable (i.e. a change of value creates a new object when assigned).  
            			That is not to say that variables cannot point to the same reference, but that when 
            			one reference's value is changed, the other variable's value is not changed.
            		</item>
            	</list>
            
            	<h3 class="dtH3">Tenets</h3>
            	These classes should only be used when the developer needs a <i>not set</i> state. Any other 
            	time, the standard value types are more appropriate. The typical case of use is when creating 
            	value objects.
            
            	<h2 class="dtH2">Design</h2>
            	All of the following classes can be <see langword="null"/> or any value that is valid for 
            	its corresponding value type.  Each class also overrides the conversion, comparable, and 
            	equality operators, so that they can be assigned to and from the corresponding value type. 
            	Additionally, appropriate operators are overloaded based on type. Most implement the 
            	relational operators for greater and less than comparisons. All arithmetic types implement 
            	addition, subtraction, multiplication, division, and remainder. The <see cref="T:System.Boolean"/> type implements 
            	the logical operators.
            	<para/>
            	The use of these types within XML serialization has also been supported. Each type implements 
            	the <see cref="T:System.Xml.Serialization.IXmlSerializable"/> interface to correctly marshal 
            	their values in a stream. This is an issue for these types since the normal contract for XML 
            	serialization is that included members must be public, which breaks the immutable contract of 
            	these types.
            	<para/>
            	<i>Table 1: Nullable Types</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Type</th>
            				<th width="80%">Description</th>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nbool"/></td>
            				<td>This class wraps a <see cref="T:System.Boolean"/> object.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nchar"/></td>
            				<td>This class wraps a <see cref="T:System.Char"/> object.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.ndecimal"/></td>
            				<td>This class wraps a <see cref="T:System.Decimal"/> object.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.ndouble"/></td>
            				<td>This class wraps a <see cref="T:System.Double"/> object.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nfloat"/></td>
            				<td>This class wraps a <see cref="T:System.Single"/> object.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nint"/>, <see cref="T:Hca.Common.NullableValueType.nuint"/></td>
            				<td>These classes wrap the <see cref="T:System.Int32"/> and <see cref="T:System.UInt32"/> objects.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nlong"/>, <see cref="T:Hca.Common.NullableValueType.nulong"/></td>
            				<td>These classes wrap the <see cref="T:System.Int64"/> and <see cref="T:System.UInt64"/> objects.</td>
            			</tr>
            			<tr valign="top">
            				<td><see cref="T:Hca.Common.NullableValueType.nshort"/>, <see cref="T:Hca.Common.NullableValueType.nushort"/></td>
            				<td>These classes wrap the <see cref="T:System.Int16"/> and <see cref="T:System.UInt16"/> objects.</td>
            			</tr>
            		</table>
            	</div>
            
            	<h2 class="dtH2">Usage</h2>
            	In general, the developer can treat these classes as if they are interchangeable with the 
            	value types.  However, there are two main considerations:
            	<para/>
            	These classes are reference objects that have more overhead than the corresponding 
            	primitive value types.
            	<para/>
            	When comparing these data types to literal values, the literal's data type must be 
            	explicitly specified either by casting the value (<c>myNShort == (short)123</c>) or by 
            	using a literal type character (<c>myNDecimal == 123.45m</c>). The reason is that an 
            	integral value is of type <see cref="T:System.Int32"/> and a floating-point number is of type <see cref="T:System.Double"/> 
            	by default. Consequently, when compared with a literal, the compiler is looking for an 
            	appropriate equality operator and will at most try one implicit conversion before 
            	considering the call ambiguous. In this case, it takes more than one conversion to find 
            	a suitable method. Consequently,  the call is considered ambiguous. By specifying the type 
            	information, the correct conversion can be found. Note that the <see cref="T:System.Int16"/> data type 
            	does not have a literal type character, so it must always be cast. 
            
            	<h2 class="dtH2">Best Practices</h2>
            	If you have created a value object class and must represent a primitive member, use the 
            	corresponding nullable type so that the <i>not set</i> value can be consistently represented. 
            	The <see cref="T:Hca.Common.NullableValueType.nushort"/> and <see cref="T:Hca.Common.NullableValueType.nshort"/> types should also comply with overflow/underflow 
            	semantics of throwing an exception if the range is exceeded by a calculation. This is not 
            	true with the normal <see cref="T:System.UInt16"/> and <see cref="T:System.Int16"/> types, since the values are first 
            	converted to <see cref="T:System.Int32"/> and the result returned as an <see cref="T:System.Int32"/> (you must explicitly 
            	handle the condition of overflow/underflow.)
            
            	<h2 class="dtH2">Examples</h2>
            	<hcaExample desc="Example 1: Assigning Values TO">
            		<code>
            int trueInt = 567;
            nint myVal = null;
            myVal = 123;
            myVal = trueInt;		// myVal = 567
            nint myVal2 = myVal;	// myVal2 = 567
            
            bool trueBool = true;
            nbool myBool = trueBool;
            myBool = false;
            myBool = null;
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Example 2: Assigning Values FROM">
            		<code>
            nint myVal = 123;
            int trueInt = myVal;	// trueInt = 123
            myVal = null;
            trueInt = myVal;		// trueInt = 0
            
            Assignment creates a new object:
            nint value1;
            nint value2 = 123;
            value1 = value2;	// value1 = 123
            value2 = 456;		// value1 = 123 , value2 = 456
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Operators">
            		<code>
            <![CDATA[nshort myVal1 = 1234, myVal2 = 1234;
            short myVal3 = 1234;
            
            // Can compare the data type to other like data types.
            if(myVal1 == myVal2 || myVal1 == myVal3)
            {. . .}
            
            // Compare by casting the literal
            if( myVal1 == (short)1234 ) 
            {. . .}
            
            // Compare by using a literal type character
            ndecimal myVal4 = 123.45m;
            if( myVal4 == 123.34m )
            {. . .}
            
            // Comparison of null equates to true
            nbool myVal4 = null;
            nbool myVal5 = null;
            if (myVal4 == myVal5)  // equates to true.
            {. . .}
            
            // greater than and less than also support
            if (myVal1 >= myVal2)
            {
            	// This block would be executed.
            }
            
            // Overflow exception would be thrown here
            nshort bad = myVal1 * myVal2;
            
            // For bools
            myVal4=true;
            myVal5=false;
            Assert.IsTrue(myVal4 ^ myVal5);
            Assert.IsFalse(myVal4 & myVal5);]]>
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Xml Serialization">
            		<code>
            // Xml Serialization also supported.
            nshort nsVal1 = new nshort(32767);
            XmlSerializer s = new XmlSerializer(typeof(nshort));
            StringWriter writer = new StringWriter();
            s.Serialize(writer, nsVal1);
            StringReader reader = new StringReader(writer.ToString());
            nshort newVal = (nshort)s.Deserialize(reader);
            Assert.AreEqual(nsVal1, newVal);
            		</code>
            	</hcaExample>
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nbool">
             <summary>
             This class is a nullable version of the <see cref="T:System.Boolean"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
             <p>
            	Example:
            	<code>
            	nbool nBool = true;
            	bool myBool = nBool;
            	Debug.Assert(myBool == true);
            	nBool = false;
            	myBool = Convert.ToBoolean( nBool );
            	Debug.Assert(myBool == false);
            	nBool = null;
            	Debug.Assert(nBool == null);
            	</code>
            	</p>
            			
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nbool"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nbool"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
             <p>
            	Example:
            	<code>
            	nbool nBool = true;
            	bool myBool = nBool;
            	nBool = false;
            	Debug.Assert(myBool == true);
            	Debug.Assert(nBool == false);
            	
            	nbool nBool1 = true;
            	// nBool1 and nBool2 share same reference
            	nbool nBool2 = nBool1;
            	// nBool1 now gets a new nBool allocated and nBool1 does not 
            	// share the same reference with nBool2
            	nBool1 = false;
            	Debug.Assert(nBool2 == true);
            	Debug.Assert(nBool1 == false);
             </code>
             </p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nbool"/>.</overloads>
            <summary>
            Default Constructor which values the <see cref="T:System.Boolean"/> to <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.#ctor(System.Boolean)">
            <summary>
            Constructor that takes a <see cref="T:System.Boolean"/> assignment.
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Implicit(System.Boolean)~Hca.Common.NullableValueType.nbool">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Boolean"/> to <see cref="T:Hca.Common.NullableValueType.nbool"/>
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to convert from.</param>
            <returns>An "nbool" object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Implicit(Hca.Common.NullableValueType.nbool)~System.Boolean">
            <summary>
            Declare an implicit conversion from a nbool to bool
            </summary>
            <param name="value">The "nbool" value to convert from.</param>
            <returns>An <see cref="T:System.Boolean"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Equality(Hca.Common.NullableValueType.nbool,Hca.Common.NullableValueType.nbool)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Equality(Hca.Common.NullableValueType.nbool,System.Boolean)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Boolean"/> and a <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Boolean"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Equality(System.Boolean,Hca.Common.NullableValueType.nbool)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Boolean"/> and a <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Boolean"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Inequality(Hca.Common.NullableValueType.nbool,Hca.Common.NullableValueType.nbool)">
            <overloads>Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nbool"/>.</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Boolean"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Inequality(Hca.Common.NullableValueType.nbool,System.Boolean)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Boolean"/> and a <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Boolean"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_Inequality(System.Boolean,Hca.Common.NullableValueType.nbool)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Boolean"/> and a <see cref="T:Hca.Common.NullableValueType.nbool"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Boolean"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nbool"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nbool.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_LogicalNot(Hca.Common.NullableValueType.nbool)">
            <summary>
            Return the negation of the current <see cref="T:Hca.Common.NullableValueType.nbool"/>. 
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nbool"/> to negate.</param>
            <returns>bool</returns>
            <exception cref="T:System.NullReferenceException">If <see langword="null"/> is negated.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_BitwiseOr(Hca.Common.NullableValueType.nbool,Hca.Common.NullableValueType.nbool)">
            <summary>
            Return the logical or of two <see cref="T:Hca.Common.NullableValueType.nbool"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>bool</returns>
            <exception cref="T:System.NullReferenceException">If <see langword="null"/> is a target of logically or</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_BitwiseAnd(Hca.Common.NullableValueType.nbool,Hca.Common.NullableValueType.nbool)">
            <summary>
            Return the logical and of two <see cref="T:Hca.Common.NullableValueType.nbool"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>bool</returns>
            <exception cref="T:System.NullReferenceException">If <see langword="null"/> is a target of logically and</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.op_ExclusiveOr(Hca.Common.NullableValueType.nbool,Hca.Common.NullableValueType.nbool)">
            <summary>
            Return the exclusive or of two <see cref="T:Hca.Common.NullableValueType.nbool"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>bool</returns>
            <exception cref="T:System.NullReferenceException">If <see langword="null"/> is a target of logically exclusive or</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.ToString">
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Boolean"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Boolean"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nbool.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="T:Hca.Common.NullableValueType.NboolConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nbool"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nbool"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nbool"/> or <see cref="T:System.ComponentModel.BooleanConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nbool"/> or 
            <see cref="T:System.ComponentModel.BooleanConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NboolConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NboolConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NboolConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nbool"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nchar">
             <summary>
             This class is a nullable version of the 'char' value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nchar nChar = 'A';
            	char myChar = nChar;
            	Debug.Assert(myChar == 'A');
            	nChar = 'B';
            	myChar = Convert.ToChar( nChar );
            	Debug.Assert(myChar == 'B');
            	nChar = null;
            	Debug.Assert(nChar == null);
            </code>
            	</p>
            	
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nchar"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nchar"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
             Example:
            <code>
            	nchar nChar = 'A';
            	char myChar = nChar;
            	nChar = 'B';
            	Debug.Assert(myChar == 'A');
            	Debug.Assert(nChar == 'B');
            	
            	nchar nChar1 = 'A';
            	// nChar2 shares ref with nChar1
            	nchar nChar2 = nChar1;
            	// nChar1 gets new nChar
            	nChar1 = 'B';
            	Debug.Assert(nChar2 == 'A');
            	Debug.Assert(nChar1 == 'B');
            </code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nchar"/>.</overloads>
            <summary>
            Default Constructor which values the char to <see cref="F:System.Char.MinValue"/>.
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.#ctor(System.Char)">
            <summary>
            Constructor that takes a <see cref="T:System.Char"/> assignment.
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nushort">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nushort"/> 
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An "nushort" object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nint">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nint"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nuint">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nuint"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nuint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>A <see cref="T:Hca.Common.NullableValueType.nlong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nulong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nulong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nulong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nchar"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(System.Char)~Hca.Common.NullableValueType.nchar">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Char"/> to <see cref="T:Hca.Common.NullableValueType.nchar"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Implicit(Hca.Common.NullableValueType.nchar)~System.Char">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nchar"/> to <see cref="T:System.Char"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Equality(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nchar"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Equality(Hca.Common.NullableValueType.nchar,System.Char)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nchar"/> and a <see cref="T:System.Char"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Char"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Equality(System.Char,Hca.Common.NullableValueType.nchar)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nchar"/> and a <see cref="T:System.Char"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Char"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Inequality(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nchar"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Inequality(Hca.Common.NullableValueType.nchar,System.Char)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nchar"/> and a <see cref="T:System.Char"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Char"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_Inequality(System.Char,Hca.Common.NullableValueType.nchar)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nchar"/> and a <see cref="T:System.Char"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Char"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nchar"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nchar.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_GreaterThan(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <summary>
            Determine the greater of two nchar
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_LessThan(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nchar"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nchar"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.op_LessThanOrEqual(Hca.Common.NullableValueType.nchar,Hca.Common.NullableValueType.nchar)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nchar"/>s.
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.ToString">
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Char"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Char"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nchar.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="T:Hca.Common.NullableValueType.NcharConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nchar"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nchar"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nchar"/> or <see cref="T:System.ComponentModel.CharConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nchar"/> or 
            <see cref="T:System.ComponentModel.CharConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NcharConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NcharConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NcharConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nchar"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.ndecimal">
             <summary>
             This class is a nullable version of the <see cref="T:System.Decimal"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	ndecimal nDecimal = 14.6m;
            	decimal myDecimal = nDecimal;
            	Debug.Assert(myDecimal == 14.6m);
            	nDecimal = 76.9m;
            	myDecimal = Convert.ToDecimal( nDecimal );
            	Debug.Assert(myDecimal == 76.9m);
            	nDecimal = null;
            	Debug.Assert(nDecimal == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.ndecimal"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.ndecimal"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
             Example:
             <code>
            	ndecimal nDecimal = 14.6m;
            	decimal myDecimal = nDecimal;
            	nDecimal = 76.9m;
            	Debug.Assert(myDecimal == 14.6m);
            	Debug.Assert(nDecimal == 76.9m);
            	
            	ndecimal nDecimal1 = 14.6m;
            	// nDecimal shares ref with nDecimal2
            	ndecimal nDecimal2 = nDecimal1;
            	// nDecimal1 gets new ndecimal
            	nDecimal1 = 76.9m;
            	Debug.Assert(nDecimal2 == 14.6m);
            	Debug.Assert(nDecimal1 == 76.9m);
             </code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.</overloads>
            <summary>
            Default Constructor which values the <see cref="T:System.Decimal"/> to MinValue
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.#ctor(System.Decimal)">
            <summary>
            Constructor that takes a <see cref="T:System.Decimal"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Implicit(System.Decimal)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Decimal"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Implicit(Hca.Common.NullableValueType.ndecimal)~System.Decimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.ndecimal"/> to <see cref="T:System.Decimal"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Equality(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Equality(System.Decimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Decimal"/> and a <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Decimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Equality(Hca.Common.NullableValueType.ndecimal,System.Decimal)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Decimal"/> and a <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Decimal"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Inequality(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Inequality(Hca.Common.NullableValueType.ndecimal,System.Decimal)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Decimal"/> and a <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Decimal"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Inequality(System.Decimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Decimal"/> and a <see cref="T:Hca.Common.NullableValueType.ndecimal"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Decimal"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.ndecimal.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Increment(Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Decrement(Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Addition(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Subtraction(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Multiply(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Division(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_Modulus(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndecimal"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_GreaterThan(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_LessThan(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_GreaterThanOrEqual(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.op_LessThanOrEqual(Hca.Common.NullableValueType.ndecimal,Hca.Common.NullableValueType.ndecimal)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.ndecimal"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Default string representation.
            </summary>
            <returns>A <see cref="T:System.String"/> representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo"/> 
            and <see cref="T:System.Globalization.CultureInfo"/> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters 
            to use for decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, 
            such as the position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains
            the default formatting information in a specific culture, including the numeric format information and 
            date- and time-related formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Decimal"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Decimal"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndecimal.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="T:Hca.Common.NullableValueType.NdecimalConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.ndecimal"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.ndecimal"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.ndecimal"/> or <see cref="T:System.ComponentModel.DecimalConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.ndecimal"/> or 
            <see cref="T:System.ComponentModel.DecimalConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NdecimalConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NdecimalConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdecimalConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.ndecimal"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.ndouble">
             <summary>
             This class is a nullable version of the <see cref="T:System.Double"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	ndouble nDouble = 14.5;
            	double myDouble = nDouble;
            	Debug.Assert(myDouble == 14.5);
            	nDouble = 76.8;
            	myDouble = Convert.ToDouble( nDouble );
            	Debug.Assert(myDouble == 76.8);
            	nDouble = null;
            	Debug.Assert(nDouble == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.ndouble"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.ndouble"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	ndouble nDouble = 14.5;
            	double myDouble = nDouble;
            	nDouble = 76.8;
            	Debug.Assert(myDouble == 14.5);
            	Debug.Assert(nDouble == 76.8);
            	
            	ndouble nDouble1 = 14.5;
            	// nDouble1 and nDouble2 share ref
            	ndouble nDouble2 = nDouble1;
            	// nDouble1 gets new ndouble
            	nDouble1 = 76.8;
            	Debug.Assert(nDouble2 == 14.5);
            	Debug.Assert(nDouble1 == 76.8);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.ndouble"/>.</overloads>
            <summary>
            Default Constructor which values the double to MinValue
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.#ctor(System.Double)">
            <summary>
            Constructor that takes a <see cref="T:System.Double"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Implicit(System.Double)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Double"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Implicit(Hca.Common.NullableValueType.ndouble)~System.Double">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.ndouble"/> to <see cref="T:System.Double"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Equality(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.ndouble"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Equality(System.Double,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.ndecimal"/> and a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Double"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Equality(Hca.Common.NullableValueType.ndouble,System.Double)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.ndecimal"/> and a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Double"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Inequality(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.ndouble"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Inequality(Hca.Common.NullableValueType.ndouble,System.Double)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.ndecimal"/> and a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Double"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Inequality(System.Double,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.ndecimal"/> and a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Double"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.ndouble.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Increment(Hca.Common.NullableValueType.ndouble)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Decrement(Hca.Common.NullableValueType.ndouble)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Addition(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Subtraction(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Multiply(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Division(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_Modulus(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_GreaterThan(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.ndouble"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_LessThan(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_GreaterThanOrEqual(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.op_LessThanOrEqual(Hca.Common.NullableValueType.ndouble,Hca.Common.NullableValueType.ndouble)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.ndouble"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.ToString">
            <overloads>Returns a string representation of the current object.</overloads>
            <summary>
            Default string representation.
            </summary>
            <returns>A String representation of the object's value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use for 
            decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, 
            such as the position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> 
            contains the default formatting information in a specific culture, including the numeric format information and 
            date- and time-related formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Double"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Double"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.ndouble.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="T:Hca.Common.NullableValueType.NdoubleConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.ndouble"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.ndouble"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.ndouble"/> or <see cref="T:System.ComponentModel.DoubleConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.ndouble"/> or 
            <see cref="T:System.ComponentModel.DoubleConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NdoubleConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NdoubleConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NdoubleConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.ndouble"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nfloat">
             <summary>
             This class is a nullable version of the <see paramref="float"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nfloat nFloat = 14.5f;
            	float myFloat = nFloat;
            	Debug.Assert(myFloat == 14.5f);
            	nFloat = 76.8f;
            	myFloat = Convert.ToFloat( nFloat );
            	Debug.Assert(myFloat == 76.8f);
            	nFloat = null;
            	Debug.Assert(nFloat == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see paramref="nfloat"/> is assigned to 
            		another <see paramref="nfloat"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nfloat nFloat = 14.5f;
            	float myFloat = nFloat;
            	nFloat = 76.8f;
            	Debug.Assert(myFloat == 14.5f);
            	Debug.Assert(nFloat == 76.8f);
            	
            	nfloat nFloat1 = 14.5f;
            	// nFloat1 and nFloat2 share ref
            	nfloat nFloat2 = nFloat1;
            	// nFloat1 gets new nfloat
            	nfloat1 = 76.8f;
            	Debug.Assert(nFloat2 == 14.5f);
            	Debug.Assert(nFloat1 == 76.8f);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.#ctor">
            <overloads>Initializes a new instance of <see paramref="nfloat"/>.</overloads>
            <summary>
            Default Constructor which values the float to MinValue
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.#ctor(System.Single)">
            <summary>
            Constructor that takes a <see cref="T:System.Single"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Implicit(Hca.Common.NullableValueType.nfloat)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nfloat"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nfloat"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Implicit(System.Single)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Single"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Implicit(Hca.Common.NullableValueType.nfloat)~System.Single">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nfloat"/> to <see cref="T:System.Single"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Equality(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nfloat"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Equality(System.Single,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nfloat"/> and a <see cref="T:System.Single"/>.
            </summary>
            <param name="value1">A <see cref="T:System.Single"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Equality(Hca.Common.NullableValueType.nfloat,System.Single)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nfloat"/> and a <see cref="T:System.Single"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Single"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Inequality(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nfloat"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Inequality(Hca.Common.NullableValueType.nfloat,System.Single)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nfloat"/> and a <see cref="T:System.Single"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Single"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Inequality(System.Single,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nfloat"/> and a <see cref="T:System.Single"/>.
            </summary>
            <param name="value1">A <see cref="T:System.Single"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nfloat.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Increment(Hca.Common.NullableValueType.nfloat)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Decrement(Hca.Common.NullableValueType.nfloat)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Addition(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Subtraction(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Multiply(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Division(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_Modulus(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nfloat"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_GreaterThan(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_LessThan(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.op_LessThanOrEqual(Hca.Common.NullableValueType.nfloat,Hca.Common.NullableValueType.nfloat)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nfloat"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use for 
            decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, 
            such as the position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains 
            the default formatting information in a specific culture, including the numeric format information and date- and time-related 
            formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, including the 
            numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Single"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Single"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nfloat.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="T:Hca.Common.NullableValueType.NfloatConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nfloat"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nfloat"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nfloat"/> or <see cref="T:System.ComponentModel.SingleConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nfloat"/> or 
            <see cref="T:System.ComponentModel.SingleConverter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NfloatConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NfloatConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NfloatConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nfloat"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nint">
             <summary>
             This class is a nullable version of the <see cref="T:System.Int32"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nint nInt = 56;
            	int myInt = nInt;
            	Debug.Assert(myInt == 56);
            	nInt = 14;
            	myInt = Convert.ToInt32( nInt );
            	Debug.Assert(myInt == 14);
            	nInt = null;
            	Debug.Assert(nInt == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nint"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nint"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nint nInt = 56;
            	int myInt = nInt;
            	nInt = 14;
            	Debug.Assert(myInt == 56);
            	Debug.Assert(nInt == 14);
            	
            	nint nInt1 = 56;
            	// nInt1 shares ref with nInt2
            	nint nInt2 = nInt1;
            	// nInt1 gets new nint
            	nInt1 = 14;
            	Debug.Assert(nInt2 == 56);
            	Debug.Assert(nInt1 == 14);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nint"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.#ctor(System.Int32)">
            <summary>
            Constructor that takes a int assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(System.Int32)~Hca.Common.NullableValueType.nint">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Int32"/> to <see cref="T:Hca.Common.NullableValueType.nint"/>
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(Hca.Common.NullableValueType.nint)~System.Int32">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nint"/> to <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nint"/> value to convert from.</param>
            <returns>An <see cref="T:System.Int32"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(Hca.Common.NullableValueType.nint)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nint"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nint"/> value to convert from.</param>
            <returns>A <see cref="T:Hca.Common.NullableValueType.nlong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(Hca.Common.NullableValueType.nint)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nint"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(Hca.Common.NullableValueType.nint)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nint"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Implicit(Hca.Common.NullableValueType.nint)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nint"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Increment(Hca.Common.NullableValueType.nint)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Decrement(Hca.Common.NullableValueType.nint)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Addition(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Subtraction(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Multiply(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Division(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Modulus(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nint"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_GreaterThan(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_LessThan(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_LessThanOrEqual(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Equality(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Equality(System.Int32,Hca.Common.NullableValueType.nint)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Int32"/> and a <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value1">An <see cref="T:System.Int32"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Equality(Hca.Common.NullableValueType.nint,System.Int32)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Int32"/> and a <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <param name="value2">An int object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Inequality(Hca.Common.NullableValueType.nint,Hca.Common.NullableValueType.nint)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Inequality(Hca.Common.NullableValueType.nint,System.Int32)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Int32"/> and a <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.Int32"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.op_Inequality(System.Int32,Hca.Common.NullableValueType.nint)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Int32"/> and a <see cref="T:Hca.Common.NullableValueType.nint"/>.
            </summary>
            <param name="value2">An <see cref="T:System.Int32"/> object to compare.</param>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nint"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nint.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use for 
            decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, 
            such as the position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains 
            the default formatting information in a specific culture, including the numeric format information and date- and time-related 
            formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Int32"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Int32"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nint.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NintConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nint"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nint"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nint"/> or <see cref="T:System.ComponentModel.Int32Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nint"/> or 
            <see cref="T:System.ComponentModel.Int32Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NintConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NintConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NintConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nint"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nlong">
             <summary>
             This class is a nullable version of the <see cref="T:System.Int64"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nlong nLong = 476;
            	long myLong = nLong;
            	Debug.Assert(myLong == 476L);
            	nLong = 32;
            	myLong = Convert.ToInt64( nLong );
            	Debug.Assert(myLong == 32);
            	nLong = null;
            	Debug.Assert(nLong == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nlong"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nlong"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nlong nLong = 476;
            	long myLong = nLong;
            	nLong = 32;
            	Debug.Assert(myLong == 476L);
            	Debug.Assert(nLong == 32L);
            	
            	nlong nLong1 = 476;
            	// nLong1 and nLong2 share ref
            	nlong nLong2 = nLong1;
            	// nLong1 gets new nlong
            	nLong1 = 32;
            	Debug.Assert(nLong2 == 476L);
            	Debug.Assert(nLong1 == 32L);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nlong"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.#ctor(System.Int64)">
            <summary>
            Constructor that takes a <see cref="T:System.Int64"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Implicit(Hca.Common.NullableValueType.nlong)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nlong"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nlong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Implicit(Hca.Common.NullableValueType.nlong)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nlong"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nlong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Implicit(Hca.Common.NullableValueType.nlong)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nlong"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nlong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Implicit(System.Int64)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Int64"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Implicit(Hca.Common.NullableValueType.nlong)~System.Int64">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nlong"/> to <see cref="T:System.Int64"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Increment(Hca.Common.NullableValueType.nlong)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nlong"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Decrement(Hca.Common.NullableValueType.nlong)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nlong"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Addition(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nlong</returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Subtraction(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nlong</returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Multiply(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nlong</returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Division(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nlong</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Modulus(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nlong</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_GreaterThan(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_LessThan(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_LessThanOrEqual(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nlong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Equality(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nlong"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Equality(System.Int64,Hca.Common.NullableValueType.nlong)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nlong"/> and a <see cref="T:System.Int64"/>.
            </summary>
            <param name="value1">A <see cref="T:System.Int64"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Equality(Hca.Common.NullableValueType.nlong,System.Int64)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nlong"/> and a <see cref="T:System.Int64"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Int64"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Inequality(Hca.Common.NullableValueType.nlong,Hca.Common.NullableValueType.nlong)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nlong"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Inequality(Hca.Common.NullableValueType.nlong,System.Int64)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nlong"/> and a <see cref="T:System.Int64"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Int64"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.op_Inequality(System.Int64,Hca.Common.NullableValueType.nlong)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nlong"/> and a <see cref="T:System.Int64"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Int64"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nlong.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use for 
            decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, such as the 
            position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains the 
            default formatting information in a specific culture, including the numeric format information and date- and 
            time-related formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Int64"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Int64"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nlong.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NlongConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nlong"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nlong"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nlong"/> or <see cref="T:System.ComponentModel.Int64Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nlong"/> or 
            <see cref="T:System.ComponentModel.Int64Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NlongConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NlongConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NlongConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nlong"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nshort">
             <summary>
             This class is a nullable version of the <see cref="T:System.Int16"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nshort nShort = 476;
            	short myShort = nShort;
            	Debug.Assert(myShort == 476);
            	nShort = 32;
            	myShort = Convert.ToInt16( nShort );
            	Debug.Assert(myShort == 32);
            	nShort = null;
            	Debug.Assert(nShort == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nshort"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nshort"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nshort nShort = 476;
            	short myShort = nShort;
            	nShort = 32;
            	Debug.Assert(myShort == 476);
            	Debug.Assert(nShort == (short)32);
            	
            	nshort nShort1 = 476;
            	// nShort1 and nShort2 share ref
            	nshort nShort2 = nShort1;
            	// nShort1 gets new nlong
            	nShort1 = 32;
            	Debug.Assert(nShort2 == (short)476);
            	Debug.Assert(nShort1 == (short)32);
            	</code>
            	</p>
            	<p>
            	<b>Important Casting Note:</b> There is no notation that specifies a literal as type <see cref="T:System.Int16"/>.
            	Therefore, literals must be cast as <see cref="T:System.Int16"/> during comparisons.
            	<code>
            	nshort x = 123;
            	if(x == (short)123)
            	{...}
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.#ctor">
            <overloads>Initializes a new instance of a <see cref="T:Hca.Common.NullableValueType.nshort"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.#ctor(System.Int16)">
            <summary>
            Constructor that takes a <see cref="T:System.Int16"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nshort"/> value to convert from.</param>
            <returns>A <see cref="T:Hca.Common.NullableValueType.nlong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nshort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nshort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nshort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~Hca.Common.NullableValueType.nint">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:Hca.Common.NullableValueType.nint"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nshort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(System.Int16)~Hca.Common.NullableValueType.nshort">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Int16"/> to <see cref="T:Hca.Common.NullableValueType.nshort"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Implicit(Hca.Common.NullableValueType.nshort)~System.Int16">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nshort"/> to <see cref="T:System.Int16"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Increment(Hca.Common.NullableValueType.nshort)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Decrement(Hca.Common.NullableValueType.nshort)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Addition(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Subtraction(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Multiply(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Division(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Modulus(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nshort"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_GreaterThan(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_LessThan(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_LessThanOrEqual(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nshort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Equality(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nshort"/>. 
            </summary>
            <param name="value1">An nshort object to compare.</param>
            <param name="value2">An nshort object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Equality(System.Int16,Hca.Common.NullableValueType.nshort)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Int16"/> and a <see cref="T:Hca.Common.NullableValueType.nshort"/>.
            </summary>
            <param name="value1">An short object to compare.</param>
            <param name="value2">An nshort object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.Int16"/>.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Equality(Hca.Common.NullableValueType.nshort,System.Int16)">
            <summary>
            Overloads the == operator between a <see cref="T:System.Int16"/> and a <see cref="T:Hca.Common.NullableValueType.nshort"/>.
            </summary>
            <param name="value1">An nshort object to compare.</param>
            <param name="value2">An short object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.Int16"/>.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Inequality(Hca.Common.NullableValueType.nshort,Hca.Common.NullableValueType.nshort)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nshort"/>. 
            </summary>
            <param name="value1">An nshort object to compare.</param>
            <param name="value2">An nshort object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Inequality(Hca.Common.NullableValueType.nshort,System.Int16)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Int16"/> and a <see cref="T:Hca.Common.NullableValueType.nshort"/>.
            </summary>
            <param name="value1">An nshort object to compare.</param>
            <param name="value2">An short object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.Int16"/>.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.op_Inequality(System.Int16,Hca.Common.NullableValueType.nshort)">
            <summary>
            Overloads the != operator between a <see cref="T:System.Int16"/> and a <see cref="T:Hca.Common.NullableValueType.nshort"/>.
            </summary>
            <param name="value1">An short object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.Int16"/>.</param>
            <param name="value2">An nshort object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nshort.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use 
            for decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, such as the 
            position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains the 
            default formatting information in a specific culture, including the numeric format information and date- and time-related 
            formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.Int16"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.Int16"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nshort.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NshortConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nshort"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nshort"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nshort"/> or <see cref="T:System.ComponentModel.UInt16Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nshort"/> or 
            <see cref="T:System.ComponentModel.UInt16Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NshortConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NshortConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NshortConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nshort"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nuint">
             <summary>
             This class is a nullable version of the <see cref="T:System.UInt32"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nuint nUInt = 56;
            	uint myUInt = nUInt;
            	Debug.Assert(myUInt == 56);
            	nUInt = 14;
            	myUInt = Convert.ToUInt32( nUInt );
            	Debug.Assert(myUInt == 14);
            	nUInt = null;
            	Debug.Assert(nUInt == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nuint"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nuint"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nuint nUInt = 56;
            	uint myUInt = nUInt;
            	nUInt = 14;
            	Debug.Assert(myUInt == 56);
            	Debug.Assert(nUInt == 14);
            	
            	nuint nUInt1 = 56;
            	// nUInt1 shares ref with nUInt2
            	nuint nUInt2 = nUInt1;
            	// nUInt1 gets new nuint
            	nUInt1 = 14;
            	Debug.Assert(nUInt2 == 56);
            	Debug.Assert(nUInt1 == 14);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.#ctor">
            <overloads>Initialize an instance of <see cref="T:Hca.Common.NullableValueType.nuint"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.#ctor(System.UInt32)">
            <summary>
            Constructor that takes a uint assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(System.UInt32)~Hca.Common.NullableValueType.nuint">
            <summary>
            Declare an implicit conversion from a uint to <see cref="T:Hca.Common.NullableValueType.nuint"/>
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nuint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>A <see cref="T:Hca.Common.NullableValueType.nlong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~Hca.Common.NullableValueType.nulong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:Hca.Common.NullableValueType.nulong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nulong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Implicit(Hca.Common.NullableValueType.nuint)~System.UInt32">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nuint"/> to <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nuint"/> value to convert from.</param>
            <returns>An <see cref="T:System.Int32"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Increment(Hca.Common.NullableValueType.nuint)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nuint"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Decrement(Hca.Common.NullableValueType.nuint)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nuint"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Addition(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nuint</returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Subtraction(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nuint</returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Multiply(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nuint</returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Division(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nuint</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Modulus(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns>nuint</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_GreaterThan(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_LessThan(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_LessThanOrEqual(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nuint"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Equality(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nuint"/>. 
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Equality(System.UInt32,Hca.Common.NullableValueType.nuint)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nuint"/> and a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value1">An <see cref="T:System.UInt32"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Equality(Hca.Common.NullableValueType.nuint,System.UInt32)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nuint"/> and a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.UInt32"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Inequality(Hca.Common.NullableValueType.nuint,Hca.Common.NullableValueType.nuint)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nuint"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Inequality(Hca.Common.NullableValueType.nuint,System.UInt32)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nuint"/> and a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.UInt32"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.op_Inequality(System.UInt32,Hca.Common.NullableValueType.nuint)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nuint"/> and a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value1">An <see cref="T:System.UInt32"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nuint"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nuint.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to 
            use for decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, such as the 
            position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains the 
            default formatting information in a specific culture, including the numeric format information and date- and time-related 
            formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, including 
            the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.UInt32"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.UInt32"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nuint.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="obj"/>.</returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NuintConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nuint"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nuint"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nuint"/> or <see cref="T:System.ComponentModel.UInt32Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nuint"/> or 
            <see cref="T:System.ComponentModel.UInt32Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NuintConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NuintConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NuintConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nuint"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nulong">
             <summary>
             This class is a nullable version of the <see cref="T:System.UInt64"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nulong nULong = 476;
            	ulong myULong = nULong;
            	Debug.Assert(myULong == 476L);
            	nULong = 32;
            	myULong = Convert.ToUInt64( nULong );
            	Debug.Assert(myULong == 32);
            	nULong = null;
            	Debug.Assert(nULong == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nulong"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nulong"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nulong nULong = 476;
            	ulong myULong = nULong;
            	nULong = 32;
            	Debug.Assert(myULong == 476L);
            	Debug.Assert(nULong == 32L);
            	
            	nulong nULong1 = 476;
            	// nULong1 and nULong2 share ref
            	nulong nULong2 = nULong1;
            	// nULong1 gets new nulong
            	nULong1 = 32;
            	Debug.Assert(nULong2 == 476L);
            	Debug.Assert(nULong1 == 32L);
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nulong"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.#ctor(System.UInt64)">
            <summary>
            Constructor that takes a <see cref="T:System.Int64"/> assignment
            </summary>
            <param name="value">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Implicit(Hca.Common.NullableValueType.nulong)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nulong"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nulong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Implicit(Hca.Common.NullableValueType.nulong)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nulong"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nulong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Implicit(Hca.Common.NullableValueType.nulong)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nulong"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nulong"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Implicit(System.UInt64)~Hca.Common.NullableValueType.nulong">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.Int64"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Implicit(Hca.Common.NullableValueType.nulong)~System.UInt64">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nlong"/> to <see cref="T:System.Int64"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Increment(Hca.Common.NullableValueType.nulong)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Decrement(Hca.Common.NullableValueType.nulong)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Addition(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Subtraction(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Multiply(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Division(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Modulus(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nulong"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_GreaterThan(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_LessThan(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_LessThanOrEqual(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nulong"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Equality(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nlong"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nulong"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nulong"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Equality(System.UInt64,Hca.Common.NullableValueType.nulong)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nulong"/> and a <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value1">An <see cref="T:System.UInt64"/> object to compare.</param>
            <param name="value2">An <see cref="T:Hca.Common.NullableValueType.nulong"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Equality(Hca.Common.NullableValueType.nulong,System.UInt64)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nulong"/> and a <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value1">An <see cref="T:Hca.Common.NullableValueType.nulong"/> object to compare.</param>
            <param name="value2">An <see cref="T:System.UInt64"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Inequality(Hca.Common.NullableValueType.nulong,Hca.Common.NullableValueType.nulong)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nlong"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Inequality(Hca.Common.NullableValueType.nulong,System.UInt64)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nulong"/> and a <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Int64"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.op_Inequality(System.UInt64,Hca.Common.NullableValueType.nulong)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nulong"/> and a <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nlong"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.Int64"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nulong.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use for 
            decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, such as the position 
            of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains the default 
            formatting information in a specific culture, including the numeric format information and date- and 
            time-related formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.UInt64"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.UInt64"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nulong.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="obj">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>
            <list type="table">
            <listheader>
            	<term>Value</term>
            	<term>Description</term>
            </listheader>
            <item>
            	<description>Less than zero</description>
            	<description>This instance is less than value.</description>
            </item>
            <item>
            	<description>Zero</description>
            	<description>This instance is equal to value.</description>
            </item>
            <item>
            	<description>Greater than zero</description>
            	<description>This instance is greater than value, or value is <see langword="null"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NulongConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nulong"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nulong"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nulong"/> or <see cref="T:System.ComponentModel.Int64Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nulong"/> or 
            <see cref="T:System.ComponentModel.Int64Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NulongConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NulongConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NulongConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nulong"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.NullableValueType.nushort">
             <summary>
             This class is a nullable version of the <see cref="T:System.UInt16"/> value type.
             The main purpose of this class is to be used by Value Objects (user-defined data classes)
             that have a 'value type' property which needs a "Not Set" state (<see langword="null"/>).
             There is no need to use this class for an variable or property that will
             always have a legitimate value.
             </summary>
             <threadsafety static="true" instance="false"/>
             <remarks>
             1. This class explicitly and implicitly converts to and from the value type.
            	<p>
            	Example:
            	<code>
            	nushort nUShort = 476;
            	ushort myUShort = nUShort;
            	Debug.Assert(myUShort == 476);
            	nUShort = 32;
            	myUShort = Convert.ToUInt16( nUShort );
            	Debug.Assert(myUShort == 32);
            	nUShort = null;
            	Debug.Assert(nUShort == null);
            	</code>
            	</p>
            	2. This class creates a new instance when it is assigned from a primitive 
            		value.  Additionally, when a reference <see cref="T:Hca.Common.NullableValueType.nushort"/> is assigned to 
            		another <see cref="T:Hca.Common.NullableValueType.nushort"/>, it shares the same object reference until either
            		value is changed. At that point, the changing value creates a new object
            		and it is assigned to that object's reference. In this way, these wrapper
            		primitives that are assigned to each other can share that memory but 
            		ensure that on change, the other reference is not effected.
            	<p>
            	Example:
            	<code>
            	nushort nUShort = 476;
            	ushort myUShort = nUShort;
            	nUShort = 32;
            	Debug.Assert(myUShort == 476);
            	Debug.Assert(nUShort == (ushort)32);
            	
            	nushort nUShort1 = 476;
            	// nUShort1 and nUShort2 share ref
            	nushort nUShort2 = nUShort1;
            	// nUShort1 gets new nushort
            	nUShort1 = 32;
            	Debug.Assert(nUShort2 == (ushort)476);
            	Debug.Assert(nUShort1 == (ushort)32);
            	</code>
            	</p>
            	<p>
            	<b>Important Casting Note:</b> There is no notation that specifies a literal as type <see cref="T:System.UInt16"/>.
            	Therefore, literals must be cast as <see cref="T:System.UInt16"/> during comparisons.
            	<code>
            	nushort x = 123;
            	if(x == (ushort)123)
            	{...}
            	</code>
            	</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.NullableValueType.nushort"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.#ctor(System.UInt16)">
            <summary>
            Constructor that takes a <see cref="T:System.UInt16"/> assignment
            </summary>
            <param name="input">An initialization value.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.nlong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.nlong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>A <see cref="T:Hca.Common.NullableValueType.nlong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.nulong">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.nulong"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nulong"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.ndouble">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.ndouble"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndouble"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.ndecimal">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.ndecimal"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.ndecimal"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.nfloat">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.nfloat"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nfloat"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.nint">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.nint"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~Hca.Common.NullableValueType.nuint">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:Hca.Common.NullableValueType.nuint"/>
            </summary>
            <param name="value">The <see cref="T:Hca.Common.NullableValueType.nushort"/> value to convert from.</param>
            <returns>An <see cref="T:Hca.Common.NullableValueType.nuint"/> object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(System.UInt16)~Hca.Common.NullableValueType.nushort">
            <summary>
            Declare an implicit conversion from a <see cref="T:System.UInt16"/> to <see cref="T:Hca.Common.NullableValueType.nushort"/> 
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Implicit(Hca.Common.NullableValueType.nushort)~System.UInt16">
            <summary>
            Declare an implicit conversion from a <see cref="T:Hca.Common.NullableValueType.nushort"/> to <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">The value to convert from.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Increment(Hca.Common.NullableValueType.nushort)">
            <summary>
            Add support for increment unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Decrement(Hca.Common.NullableValueType.nushort)">
            <summary>
            Add support for decrement unary operator
            </summary>
            <param name="value"></param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Addition(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Add two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
            <exception cref="T:System.OverflowException">If addition exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Subtraction(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Subtract two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
            <exception cref="T:System.OverflowException">If subtraction exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Multiply(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            multiply two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
            <exception cref="T:System.OverflowException">If multiplication exceeds range of type.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Division(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            divide two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Modulus(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            remainder two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see cref="T:Hca.Common.NullableValueType.nushort"/></returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_GreaterThan(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Determine the greater of two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_LessThan(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Determine the lesser of two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_GreaterThanOrEqual(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Determine the greater or equal of two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_LessThanOrEqual(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <summary>
            Determine the lesser or equal of two <see cref="T:Hca.Common.NullableValueType.nushort"/>s
            </summary>
            <param name="value1">left-hand instance to compare</param>
            <param name="value2">right-hand instance to compare</param>
            <returns><see langword="true"/> if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>.</returns>
            <exception cref="T:System.DivideByZeroException">If division is by zero.</exception>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Equality(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <overloads>Overloads the == operator</overloads>
            <summary>
            Overloads the == operator between two <see cref="T:Hca.Common.NullableValueType.nushort"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Equality(System.UInt16,Hca.Common.NullableValueType.nushort)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nushort"/> and a <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value1">A <see cref="T:System.UInt16"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.UInt16"/>.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Equality(Hca.Common.NullableValueType.nushort,System.UInt16)">
            <summary>
            Overloads the == operator between a <see cref="T:Hca.Common.NullableValueType.nushort"/> and a <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.UInt16"/> object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.UInt16"/>.</param>
            <returns>Whether the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Inequality(Hca.Common.NullableValueType.nushort,Hca.Common.NullableValueType.nushort)">
            <overloads>Overloads the != operator</overloads>
            <summary>
            Overloads the != operator between two <see cref="T:Hca.Common.NullableValueType.nushort"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Inequality(Hca.Common.NullableValueType.nushort,System.UInt16)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nushort"/> and a <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value1">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <param name="value2">A <see cref="T:System.UInt16"/> object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.UInt16"/>.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.op_Inequality(System.UInt16,Hca.Common.NullableValueType.nushort)">
            <summary>
            Overloads the != operator between a <see cref="T:Hca.Common.NullableValueType.nushort"/> and a <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value1">A <see cref="T:System.UInt16"/> object to compare. You must
            explicitly cast this value so it knows it is a <see cref="T:System.UInt16"/>.</param>
            <param name="value2">A <see cref="T:Hca.Common.NullableValueType.nushort"/> object to compare.</param>
            <returns>Whether the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.Equals(System.Object)">
            <summary>
            Overrides the <see cref="M:System.Object.Equals(System.Object)"/> method
            </summary>
            <param name="target">The object to compare.</param>
            <returns>Whether the objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.GetHashCode">
            <summary>
            Overrides the <see cref="M:System.Object.GetHashCode"/> method.  
            </summary>
            <remarks>
            This is only needed because the <see cref="M:Hca.Common.NullableValueType.nushort.Equals(System.Object)"/> method is overridden.
            </remarks>
            <returns>An <see cref="T:System.Int32"/> value that represents the objects HashCode.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.ToString">
            <overloads>Returns a <see cref="T:System.String"/> that represents the current object.</overloads>
            <summary>
            Gets the default string representation of the object's value.
            </summary>
            <returns>A String representation of the object's value</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <remarks>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/>
            , <see cref="T:System.Globalization.DateTimeFormatInfo">DateTimeFormatInfo</see> 
            and <see cref="T:System.Globalization.CultureInfo">CultureInfo</see> implement the
            <see cref="T:System.IFormatProvider"/> interface.
            </p>
            <p>
            <see cref="T:System.Globalization.NumberFormatInfo"/> supplies numeric formatting information, such as the characters to use 
            for decimal and thousand separators and the spelling and placement of currency symbols in monetary values.
            </p>
            <p>
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> supplies date- and time-related formatting information, such as 
            the position of the month, the day and the year in a date pattern. <see cref="T:System.Globalization.CultureInfo"/> contains 
            the default formatting information in a specific culture, including the numeric format information and 
            date- and time-related formatting information.
            </p>
            <p>
            <see cref="T:System.Globalization.CultureInfo"/> contains the default formatting information in a specific culture, 
            including the numeric format information and date- and time-related formatting information.
            </p>
            </remarks>
            <param name="format">
            <p>The <see cref="T:System.String"/> specifying the format to use.</p>
            <p>-or-</p>
            <p><see langword="null"/> to use the default format
            defined for the type of the <see cref="T:System.IFormattable"/> implementation.</p>
            </param>
            <param name="formatProvider">
            <p>The <see cref="T:System.IFormatProvider"/> to use to format the value.</p>
            <p>-or-</p>
            <p><see langword="null"/> to obtain the numeric format information
            from the current locale setting of the operating system.</p>
            </param>
            <returns>A <see cref="T:System.String"/> containing the value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.ToString(System.String)">
            <summary>
            Converts the numeric value of this instance to its 
            equivalent string representation, using the specified format.
            </summary>
            <param name="format">A format string.</param>
            <returns>The string representation of the value of this instance 
            as specified by <paramref name="format"/>.</returns>
            <remarks>
            <p>If <paramref name="format"/> is <see langword="null"/> or an 
            empty string (""), the return value of this instance is formatted 
            with the general format specifier ("G").</p>
            <p>The return value of this instance 
            is formatted with the <see cref="T:System.Globalization.NumberFormatInfo"/> for the current culture.</p>
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.ReadXml(System.Xml.XmlReader)">
            <summary>
            Handle reading this object from a node as Xml
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Handle writing this object to a node as Xml
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized. </param>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.GetSchema">
            <summary>
            Generate the xml schema for this object as a node.
            </summary>
            <returns>Xml schema for this object as a node.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for value type <see cref="T:System.UInt16"/>.
            </summary>
            <returns>The enumerated constant, <see cref="F:System.TypeCode.UInt16"/>.</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.nushort.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="target">An object to compare to this instance, or <see langword="null"/>.</param>
            <returns>A signed integer that indicates the relative order of this instance and <paramref name="target"/>.</returns>
        </member>
        <member name="T:Hca.Common.NullableValueType.NushortConverter">
            <summary>
            Converter for <see cref="T:Hca.Common.NullableValueType.nushort"/> data type.
            </summary>
            <remarks>
            The converter provides methods to convert <see cref="T:Hca.Common.NullableValueType.nushort"/> type to and from other types. See
            its methods for specific types supported.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.Equals(System.Object)">
            <summary>
            Determine if passed in object is equal to this object
            </summary>
            <param name="obj">object to compare</param>
            <returns><see langword="true"/> if equals</returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.GetHashCode">
            <summary>
            Calculate hash code for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="sourceType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if source type is <see cref="T:Hca.Common.NullableValueType.nushort"/> or <see cref="T:System.ComponentModel.UInt16Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Determines if <paramref name="destinationType"/> is allowed. <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Returns <see langword="true"/> if destination type is assignable from <see cref="T:Hca.Common.NullableValueType.nushort"/> or 
            <see cref="T:System.ComponentModel.UInt16Converter"/> returns <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Checks to see if can convert from <paramref name="value"/>'s type before converting from <paramref name="value"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NushortConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Checks to see if <paramref name="value"/> be converted to <paramref name="destinationType"/> before converting <paramref name="value"/> to type. 
            <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
            <remarks>
            Check <see cref="M:Hca.Common.NullableValueType.NushortConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)"/> and if <see langword="true"/> perform conversion.
            </remarks>
        </member>
        <member name="M:Hca.Common.NullableValueType.NushortConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Takes <paramref name="value"/>'s string and sees if it is a valid <see cref="T:Hca.Common.NullableValueType.nushort"/>. 
            See <see cref="T:System.ComponentModel.TypeConverter"/> for more details.
            </summary>
        </member>
        <member name="T:Hca.Common.Resource.HcaResourceManager">
            <summary>A singleton class that wraps a <see cref="T:Hca.Common.Resource.ResourceHelper"/> and associates it with a default Resource store.</summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para>The resource-access semantics provided by this class are identical to those of the HCA <see cref="T:Hca.Common.Resource.ResourceHelper"/>.</para>
            <para>The inner <see cref="T:Hca.Common.Resource.ResourceHelper"/> is configured using the <see cref="T:Hca.Common.Resource.ResourceConfig"/> 
            entries in the null configuration context. (For more information on the configuration store, 
            see the <see cref="N:Hca.Common.Configuration"/> namespace.)</para>
            <para>The singleton object is instantiated lazily, that is, the class' configuration will not be loaded until the first 
            request to get <see cref="P:Hca.Common.Resource.HcaResourceManager.Instance"/>. The advantage is that no processing will be wasted loading its configuration if it 
            is never used. However, the side-effect is that the first request for the <see cref="P:Hca.Common.Resource.HcaResourceManager.Instance"/> will be more expensive 
            than those following.</para>
            </remarks>
            <example>
            <para>For example .config file XML syntax, please see <see cref="T:Hca.Common.Resource.ResourceConfig"/>.</para>
            <para>For an example of usage, please see <see cref="T:Hca.Common.Resource.ResourceHelper"/>.</para>
            </example>
        </member>
        <member name="T:Hca.Common.Resource.IResourceHelper">
            <summary>An interface that furnishes access to string resources.</summary>
            <remarks>
            <para>
            This interface exists primarily to enforce similar access signatures 
            for <see cref="T:Hca.Common.Resource.HcaResourceManager">HcaResourceManagers</see> and <see cref="T:Hca.Common.Resource.ResourceHelper"/>.
            </para>
            <para>
            A request for a resource must be confined to a given context (a named set of resources) and may be localized 
            per culture (if available). Additionally, any replaceable parameters in the string resource can be populated 
            along with the request.
            </para>
            <para>
            By default, if the request fails (the named resource is not found), the call will throw an exception. 
            This can be disabled, however, in which case the caller will receive <see langword="null"/> as a return value.
            </para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Resource.IResourceHelper.GetString(System.String,System.String,System.Object[])">
            <overloads>Retrieves a string resource.</overloads>
            <summary>Retrieves a string resource with no specified formatter.</summary>
            <param name="context">
            A <see cref="T:System.String"/> referencing a predefined resource context for the search. 
            If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.
            </param>
            <param name="name">
            A <see cref="T:System.String"/> containing the name of the string resource to retrieve. 
            If not found within the specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.
            </param>
            <param name="formatArgs">
            An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.
            </param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">
            Thrown if a best match is not possible.
            </exception>
        </member>
        <member name="M:Hca.Common.Resource.IResourceHelper.GetString(System.IFormatProvider,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters.</summary>
            <param name="formatProvider">
            An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information 
            for the <paramref name="formatArgs"/>.
            </param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve.</param>
            <param name="formatArgs">
            An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.
            </param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible.</exception>
        </member>
        <member name="M:Hca.Common.Resource.IResourceHelper.GetString(System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, optionally suppressing the exception if the resource is not found.</summary>
            <param name="exceptionIfMissing">
            A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if the resource cannot be found. 
            If <see langword="false"/>, <see langword="null"/> will be returned. If <see langword="true"/>, 
            a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, 
            or if the <paramref name="name"/> is not found in the context.
            </param>
            <param name="context">
            A <see cref="T:System.String"/> referencing a predefined resource context for the search. 
            If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.
            </param>
            <param name="name">
            A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the 
            specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.
            </param>
            <param name="formatArgs">
            An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.
            </param>
            <returns>
            The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if 
            a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">
            Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.
            </exception>
        </member>
        <member name="M:Hca.Common.Resource.IResourceHelper.GetString(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>
            Retrieves a string resource, using the specified formatter for replaceable parameters, localized for 
            the specified culture, and optionally suppressing the exception if the resource is not found.
            </summary>
            <param name="formatProvider">
            An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information for 
            the <paramref name="formatArgs"/>.
            </param>
            <param name="culture">
            <para>
            The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the 
            resource should be localized. Note that if the resource is not localized for this culture, the lookup 
            will fall back using the culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping 
            after looking in the neutral culture.
            </para>
            <para>
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained using 
            the caller's current culture settings.
            </para>
            </param>
            <param name="exceptionIfMissing">
            A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if the resource cannot be found. 
            If <see langword="false"/>, <see langword="null"/> will be returned. If <see langword="true"/>, 
            a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, or if 
            the <paramref name="name"/> is not found in the context.
            </param>
            <param name="context">
            A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, behavior will 
            depend on the value of the <paramref name="exceptionIfMissing"/> parameter.
            </param>
            <param name="name">
             <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found 
            within the specified context, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.
            </param>
            <param name="formatArgs">
            An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.
            </param>
            <returns>
            The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a best match 
            is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">
            Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.
            </exception>
        </member>
        <member name="F:Hca.Common.Resource.HcaResourceManager.staticSyncRoot">
            <summary>Used to synchronize instantiation of the singleton instance.</summary>
        </member>
        <member name="F:Hca.Common.Resource.HcaResourceManager.instance">
            <summary>Holds the singleton instance of this class.</summary>
        </member>
        <member name="F:Hca.Common.Resource.HcaResourceManager.innerHelper">
            <summary>Holds the <see cref="T:Hca.Common.Resource.ResourceHelper"/> that does the singleton instance's work.</summary>
        </member>
        <member name="F:Hca.Common.Resource.HcaResourceManager.innerHelperLock">
            <summary>Used to synchronize access with configuration of the instance.</summary>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.#ctor">
            <summary>Private constructor for singleton instantiation.</summary>		
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetConfiguredHelper">
            <summary>Retrieves the <see cref="T:Hca.Common.Resource.ResourceConfig"/>(s) from the configuration store.</summary>
            <returns>An array containing the <see cref="T:Hca.Common.Resource.ResourceConfig"/>(s) from the configuration store.</returns>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.ConfigFactoryInstanceReload(System.Object,System.EventArgs)">
            <summary>Handles <see cref="E:Hca.Common.Configuration.ConfigFactory.Refreshed"/>.</summary>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetString_Impl(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters, 
            localized for the specified culture, and optionally suppressing the exception if the resource is not found.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting 
            information for the <paramref name="formatArgs"/>.</param>
            <param name="culture">
            <para>The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the resource 
            should be localized. Note that if the resource is not localized for this culture, the lookup will fall back using 
            the culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping after looking in the neutral culture.</para>
            <para>If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained 
            using the caller's current culture settings.</para>
            </param>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's 
            behavior if the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. 
            If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, 
            or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. 
            If not found, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. 
            If not found within the specified context, behavior will depend on the value of 
            the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format 
            inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> 
            if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or 
            <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible 
            and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetString(System.String,System.String,System.Object[])">
            <overloads>Retrieves a string resource.</overloads>
            <summary>Retrieves a string resource with no specified formatter.</summary>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. 
            If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found 
            within the specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format 
            inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> 
            or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible.</exception>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetString(System.IFormatProvider,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting 
            information for the <paramref name="formatArgs"/>.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search.</param> 
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside 
            the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> 
            or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible.</exception>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetString(System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, optionally suppressing the exception if the resource is not found.</summary>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's 
            behavior if the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. 
            If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is 
            not found, or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. 
            If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. 
            If not found within the specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format 
            inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a 
            best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> 
            is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> 
            is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Resource.HcaResourceManager.GetString(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters, localized for the 
            specified culture, and optionally suppressing the exception if the resource is not found.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information 
            for the <paramref name="formatArgs"/>.</param>
            <param name="culture">
            <para>The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the resource should 
            be localized. Note that if the resource is not localized for this culture, the lookup will fall back using the 
            culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping after looking in the neutral culture.</para>
            <para>If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained using the 
            caller's current culture settings.</para>
            </param>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if 
            the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. 
            If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, 
            or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, 
            behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within 
            the specified context, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside 
            the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> 
            if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> 
            or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible 
            and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.</exception>
        </member>
        <member name="P:Hca.Common.Resource.HcaResourceManager.Instance">
            <summary>Gets the singleton instance of this class.</summary>
        </member>
        <member name="T:Hca.Common.Resource.MissingResourceException">
            <summary>The exception thrown by <see cref="T:Hca.Common.Resource.ResourceHelper"/> when the context name or resource name 
            passed to <see cref="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])"/> cannot be located and exception if missing is <see langword="true"/>.</summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.Resource.MissingResourceException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Resource.MissingResourceException"/>.</overloads>
            <summary>Default constructor.</summary>
            <remarks>Initializes <see cref="T:Hca.Common.Message"/> using default message. <see cref="P:System.Exception.InnerException"/> remains <see langword="null"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Resource.MissingResourceException.#ctor(System.String)">
            <summary>Overloaded constructor that specifies the exception message.</summary>		
            <remarks>Initializes <see cref="T:Hca.Common.Message"/> with <param name="message"/>. <see cref="P:System.Exception.InnerException"/> remains <see langword="null"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Resource.MissingResourceException.#ctor(System.String,System.Exception)">
            <summary>Overloaded constructor that specifies the exception message and exception that caused this exception.</summary>		
            <remarks>Initializes <see cref="T:Hca.Common.Message"/> with <param name="message"/> and <see cref="P:System.Exception.InnerException"/> with <param name="innerException"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Resource.MissingResourceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor. This is used when reconstituting a serialized object.
            </summary>
            <param name="info">the serialized object information</param>
            <param name="context">the context</param>
        </member>
        <member name="T:Hca.Common.Resource.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	Application code almost always needs string resources, for exception messages if not for 
            	the User Interface. A Resource Manager cleanly separates the executable code from the 
            	resources on which it depends. This separation clarifies design and development, eases 
            	maintenance, and enables enterprise-required features such as language and locale 
            	sensitivity.
            	<para/>		
            	This section describes the requirements that shaped the design and implementation of the 
            	<see cref="T:Hca.Common.Resource.ResourceMessage"/>, <see cref="T:Hca.Common.Resource.HcaResourceManager"/>, 
            	and <see cref="T:Hca.Common.Resource.ResourceHelper"/> in the <see cref="N:Hca.Common.Resource"/> namespace.
            
            	<h3 class="dtH3">References</h3>
            	The following works are referenced in this SDK:
            	<para/>
            	<i>Table 1: Referenced Works</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Label</th>
            				<th width="50%">Title</th>
            				<th width="30%">Reference</th>
            			</tr>
            			<tr>
            				<td>MsNetResource</td>
            				<td>.NET Framework Developer's Guide: Resources in Applications</td>
            				<td>
            					<see href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconCreatingUsingResources.asp"/>
            				</td>
            			</tr>
            			<tr>
            				<td>MsNetFormat</td>
            				<td>.NET Framework Developer's Guide: Formatting Types</td>
            				<td>
            					<see href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconformattingtypes.asp"/>
            				</td>
            			</tr>
            			<tr>
            				<td>ConfigUsage</td>
            				<td>Configuration SDK</td>
            				<td>HCA Dev Block Common - SDK</td>
            			</tr>
            			<tr>
            				<td>ExcFrmUsage</td>
            				<td>Exception Framework SDK</td>
            				<td>HCA Dev Block Common - SDK</td>
            			</tr>
            			<tr>
            				<td>MsNetPatterns</td>
            				<td>Enterprise Solution Patterns Using Microsoft .NET</td>
            				<td><see href="http://msdn.microsoft.com/practices/type/Patterns/Enterprise/default.asp"/></td>
            			</tr>
            			<tr>
            				<td>MsNetClasses</td>
            				<td>.NET Framework Class Library</td>
            				<td><see href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/cpref_start.asp"/></td>
            			</tr>
            		</table>
            	</div>
            
            	<h3 class="dtH3">Requirements</h3>
            	The classes in the <see cref="N:Hca.Common.Resource"/> namespace provide the basic resource management 
            	functionality (code/resource separation and language/locale customization) that .NET's 
            	<see cref="T:System.Resources.ResourceManager"/> or Java's <c>ResourceBundle</c> provides, with 
            	the following additional features:
            	<list type="bullet">
            		<item>
            			Declarative configuration and singleton (see [MsNetPatterns], chapter 5) instantiation. 
            			This puts resources at the developer's fingertips using a familiar XML schema.
            		</item>
            		<item>In-call formatting of replaceable parameters.</item>
            		<item>
            			Contextual grouping of resources – avoids name collisions in the singleton's 
            			(potentially very large) resource set.
            		</item>
            		<item>
            			Application-level override of libraries' resource configuration - allows declarative 
            			customization of any resources used by a referenced library.
            		</item>
            		<item>Multi-instance helper class – for special cases where the singleton isn't ideal.</item>
            	</list>
            
            	<h3 class="dtH3">Tenets</h3>
            	The following guidelines should be observed by developers using the <see cref="N:Hca.Common.Resource"/> 
            	classes:
            	<list type="bullet">
            		<item>
            			Any string that is intended for reading by a human at run-time is a good candidate 
            			resource.
            		</item>
            		<item>
            			Direct usage of a <see cref="T:Hca.Common.Resource.ResourceHelper"/> should be reserved 
            			only for special cases where using a <see cref="T:Hca.Common.Resource.ResourceMessage"/> 
            			(which inherently calls <see cref="T:Hca.Common.Resource.HcaResourceManager"/>) is clearly contra-indicated.
            		</item>
            		<item>
            			Use of classes within the <see cref="N:Hca.Common.Resource"/> framework are context sensitive.
            		</item>
            		<item>
            			Resources' string names should not be hard coded throughout the application. 
            			Use of <see cref="T:Hca.Common.Resource.ResourceMessage"/> classes alleviate this concern.
            			(See [ExcFrmUsage] for details.)
            		</item>
            		<item>
            			Document the names and uses of your embedded resources for easy override by 
            			consumers of your code. The recommended method is a well-commented extension of the 
            			<see cref="T:Hca.Common.Resource.ResourceMessage"/> class. For this reason, direct 
            			usage of the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> is often not needed.
            		</item>
            	</list>
            
            	<h2 class="dtH2">Design</h2>
            	The following class diagram illustrates the relationships between the classes in the 
            	Resource namespace.
            	<para/>
            	<img src="resource_class_diagram.gif"/>
            	<br/>
            	<i>Image 1: Resource Class Diagram</i>
            
            	<h3 class="dtH3">IResourceHelper</h3>
            	This interface defines common resource-retrieval semantics for the classes in the namespace.
            
            	<h3 class="dtH3">ResourceHelper</h3>
            	The <see cref="T:Hca.Common.Resource.ResourceHelper"/> is the primary implementation of 
            	<see cref="T:Hca.Common.Resource.IResourceHelper"/>. It is initialized using an array of 
            	<see cref="T:Hca.Common.Resource.ResourceConfig"/> objects and internally constructs a 
            	list of named contexts. Each context, in turn, has a list of resources associated with it.
            	<para/>
            	The <see cref="T:Hca.Common.Resource.ResourceHelper"/> handles localization automatically. It 
            	looks first for a resource localized for the specific culture requested. If this is not found, 
            	less specific cultures are successively searched (down to the default culture-neutral resource) 
            	until a match is found. (For details, see [MsNetResource].)
            	<para/>
            	The <see cref="T:Hca.Common.Resource.ResourceHelper"/> can also format replaceable parameters inline. 
            	This is enabled by the development platform. (For details, see [MsNetFormat].)
            	<para/>
            	When a <see cref="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])"/> call is received, 
            	the first resource in the specific context that matches the passed context name is returned. 
            	Thus, resource-name collision actually enables the override functionality in the requirements.
            
            	<h3 class="dtH3">HcaResourceManager</h3>
            	The <see cref="T:Hca.Common.Resource.HcaResourceManager"/> also implements 
            	<see cref="T:Hca.Common.Resource.IResourceHelper"/>. It wraps an inner 
            	<see cref="T:Hca.Common.Resource.ResourceHelper"/> in a singleton for consistent, convenient 
            	access and loads its own settings directly from the null configuration context in the 
            	configuration store. The singleton object is instantiated lazily.
            
            	<h3 class="dtH3">ResourceConfig</h3>
            	The idea of wrapping an entire resource context in a single configuration object was not 
            	used in order to keep the XML as straightforward as possible. However, the concept of a 
            	context is expressed as multiple <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfigs</see> 
            	with matching <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/> properties.
            	<hcaNote type="important">
            		The resource context of a given <see cref="T:Hca.Common.Resource.ResourceConfig"/> object 
            		(specified using the <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/> property 
            		on <see cref="T:Hca.Common.Resource.ResourceConfig"/>) should not be confused 
            		with config's context (specified using the context attribute on the config XML 
            		element). (See [ConfigUsage] for details on configuration contexts.)
            	</hcaNote>
            
            	<h3 class="dtH3">ResourceMessage</h3>
            	This class provide encapsulation of the context, arguments, and behavior around retrieving a message from a resource. 
            	<see cref="T:Hca.Common.Resource.ResourceMessage"/> uses <see cref="T:Hca.Common.Resource.HcaResourceManager"/> in 
            	its <see cref="M:Hca.Common.Resource.ResourceMessage.ToString"/> method for retrieving resources. 
            	Use of <see cref="T:Hca.Common.Resource.ResourceMessage"/> is recommended as opposed to direct usage of 
            	<see cref="T:Hca.Common.Resource.HcaResourceManager"/>.
            
            	<h2 class="dtH2">Usage</h2>
            	This section describes the configuration of <see cref="T:Hca.Common.Resource.ResourceHelper"/> and 
            	<see cref="T:Hca.Common.Resource.HcaResourceManager"/> for use with <see cref="T:Hca.Common.Resource.ResourceMessage"/>. 
            	It describes best practices for resource developers of applications consuming these components.
            
            	<h3 class="dtH3">Configuration</h3>
            	An array of <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects is used to initialize a 
            	<see cref="T:Hca.Common.Resource.ResourceHelper"/>. This array can be either programmatically 
            	constructed or declaratively defined using <see cref="N:Hca.Common"/>'s configuration functionality. (See 
            	the <see cref="N:Hca.Common.Configuration"/> section.) The <see cref="T:Hca.Common.Resource.HcaResourceManager"/> initializes 
            	its instance using declared configuration in the null configuration context. Declarative 
            	configuration will look something like the following:
            	<para/>
            	<hcaExample desc="Example 1: ResourceConfig">
            		<code>
            <![CDATA[<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            	<property name="ContextName" value="message"/>
            	<property name="AsmName" value="ResourceExample"/>
            	<property name="BaseName" value="messages"/>
            </config>
            <config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            	<property name="ContextName" value="exception"/>
            	<property name="AsmName" value="ResourceExample"/>
            	<property name="BaseName" value="exceptions"/>
            </config>
            <config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            	<property name="ContextName" value="exception"/>
            	<property name="AsmName" value="Hca_DevBlocks_Common, Version=1.3.0.0, Culture=neutral, PublicKeyToken=fd260fd4a2a56402"/>
            	<property name="BaseName" value="Hca.Common.BaseException.EmbedResource.commonexcmsg"/>
            </config>]]>
            		</code>
            	</hcaExample>
            	<para/>
            	All of the properties are required.
            	<list type="bullet">
            		<item>
            			<see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/> is the resource 
            			context (in the <see cref="T:Hca.Common.Resource.ResourceHelper"/>) 
            			in which to place the resources described by this <see cref="T:Hca.Common.Resource.ResourceConfig"/>. 
            			<see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfigs</see>, 
            			with matching <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName">ContextNames</see>, instruct the 
            			<see cref="T:Hca.Common.Resource.ResourceHelper"/> to group the resources together in one resource 
            			context. Overlapping resource names within a context are resolved on a first-in basis.
            		</item>
            		<item>
            			<see cref="P:Hca.Common.Resource.ResourceConfig.AsmName"/> is the assembly in which to 
            			search for <see cref="P:Hca.Common.Resource.ResourceConfig.BaseName"/>. The value 
            			given should be in the format required 
            			by <see cref="M:System.Reflection.Assembly.Load(System.String)">System.Reflection.Assembly.Load(string assemblyString)</see>. 
            			(See [MsNetClasses].) 
            			<hcaNote>
            				Strong assembly names must be specified for any resource that is embedded in an 
            				assembly that resides in the .NET Global Assembly Cache:
            				<c>ResourceExample, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)</c>
            			</hcaNote>
            		</item>
            		<item>
            			<see cref="P:Hca.Common.Resource.ResourceConfig.BaseName"/> is the name of the embedded .resources file to look for in the 
            			assembly specified by <see cref="P:Hca.Common.Resource.ResourceConfig.AsmName"/>. (See [MsNetResource].)
            		</item>
            	</list>
            	<para/>
            	In this example, the <c>ResourceExample</c> assembly (presumably the 
            	application's primary assembly) contains two .resources files: <i>messages.resources</i>, and 
            	<i>exceptions.resources</i>. The <c>Hca.DevBlocks.Common</c> assembly contains one .resources file: 
            	<i>Hca.Common.BaseException.EmbedResource.commonexcmsg</i> (<i>..resources</i>).
            	<para/>
            	Two contexts are created within the <see cref="T:Hca.Common.Resource.ResourceHelper"/> at run-time. 
            	The first, <c>message</c>, contains the resources from <i>messages.resources</i>. The second, 
            	<c>exception</c>, contains all the resources from <i>exceptions.resources</i> and all the resources 
            	from <i>Hca…resources</i>. If <i>messages.resources</i> contains a resource with the same name as a 
            	resource in <i>Hca….resources</i>, then the resource in <i>messages.resources</i> overrides the resource 
            	in <i>Com….resources</i>.
            
            	<h2 class="dtH2">Best Practices</h2>
            	General usage of these components is fairly forthright. A few guidelines should keep consumers' 
            	experience optimal.
            
            	<h3 class="dtH3">Any string that is intended for reading by a human at run-time is a good candidate resource</h3>
            	In other words, it should be used. Hard-coded strings make code brittle. For example:
            	<hcaExample desc="Example 2:">
            		<hcaExample desc="this, in MyClass.cs...">
            			<code>
            Console.WriteLine("The operation succeeded.");
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="...should become this...">
            			<code lang="c#" escaped="true">
            string resourceContext = "message";
            ...
            public static MyAppResourceMessage SuccessMessage()
            {
            	return new MyAppResourceMessage(resourceContext, "SuccessMessage");
            }
            ... 
            Console.WriteLine(MyAppResourceMessage.SuccessMessage());
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="...with this (in messages.txt)...">
            			<code>
            SuccessMsg=The operation succeeded.
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="...and probably this (in es/messages.txt)...">
            			<code>
            SuccessMsg=La operación tenida éxito.
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="...and perhaps this (in fr/messages.txt)...">
            			<code>
            SuccessMsg=L'opération a réussi.
            			</code>
            		</hcaExample>
            	</hcaExample>
            	<para/>
            	And if the verbiage ever needs to change from 'operation' to 'action', the code never needs 
            	to be touched. Note that users do not have to use name/value pair format .txt files. The .NET compiler will compile both .txt and xml .resx files into the correct .resources format.
            
            	<h3 class="dtH3">
            		Create a custom class that derives from <see cref="T:Hca.Common.Resource.ResourceMessage"/> for accessing resource messages
            	</h3>
            	It is the responsibility of the developer to implement access to resources for their application. 
            	Hard-coding resource name strings throughout code is error-prone and complicates 
            	maintenance, especially when a resource is referenced by code in multiple locations. We 
            	recommend that static methods for those names are defined in a resource message class 
            	named <c>&lt;app name&gt;ResourceMessage.cs</c> which derives from <see cref="T:Hca.Common.Resource.ResourceMessage"/>. 
            	This strongly types all references to the resource, enabling 
            	intellisense and eliminating the possibility of spelling mistakes. In the odd case when a resource gets 
            	renamed, changes to the code are minimized. For a practical example of this, 
            	see <see cref="T:Hca.Common.BaseException.ExceptionMessage">BaseException.ExceptionMessage</see> or the examples below. 
            	<see cref="T:Hca.Common.BaseException.ExceptionMessage"/> derives from <see cref="T:Hca.Common.Resource.ResourceMessage"/>, both 
            	of which use a <see cref="T:Hca.Common.Resource.HcaResourceManager"/> to obtain its resources when the 
            	<see cref="T:Hca.Common.Resource.ResourceMessage"/> is implicitly converted to a string.
            
            	<h3 class="dtH3">
            		Direct usage of a <see cref="T:Hca.Common.Resource.ResourceHelper"/> should be reserved only for special cases where 
            		using a <see cref="T:Hca.Common.Resource.ResourceMessage"/> is clearly contra-indicated
            	</h3>
            	<see cref="T:Hca.Common.Resource.ResourceMessage"/> is designed to handle the vast 
            	majority of consumers' resource-retrieval needs. It should be used for all but the most 
            	exceptional usage scenarios. However, some circumstances may require direct interaction 
            	with a <see cref="T:Hca.Common.Resource.ResourceHelper"/>. Such scenarios could include the 
            	following requirements:
            	<list type="bullet">
            		<item>
            			Imperative configuration: the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> used 
            			by <see cref="T:Hca.Common.Resource.ResourceMessage"/> loads its own configuration 
            			from the declarative configuration file; <see cref="T:Hca.Common.Resource.ResourceHelper"/> will 
            			take whatever configuration is passed to its constructor.
            		</item>
            		<item>
            			More direct control over the time at which resource assemblies are loaded. By 
            			default, the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> loads all 
            			declared resource assemblies together.
            		</item>
            	</list>
            
            	<h3 class="dtH3">
            		Resources must always be defined within a specific context
            	</h3>
            	In the vast majority of cases (especially when using the <see cref="T:Hca.Common.Resource.HcaResourceManager"/>), 
            	many contexts are defined and numerous library resources are present. Cross-context resource searches would take much more time 
            	and might yield unexpected results if context names overlap. For this 
            	reason <see cref="M:Hca.Common.Resource.HcaResourceManager.GetString(System.String,System.String,System.Object[])"/> requests are required to specify a <c>contextName</c>. 
            	<h3 class="dtH3">
            		Document the names and uses of your embedded resources for easy override by consumers 
            		of your code
            	</h3>
            	A key feature of the <see cref="T:Hca.Common.Resource.HcaResourceManager"/> is that the rules for 
            	priority used when there are resource-name collisions allow for powerful overriding customizations 
            	in an application for messages generated by referenced libraries. However, this only works if 
            	the resources used by the referenced libraries are clearly and thoroughly documented for 
            	the developers of the applications. Begin by listing the contexts and names by which a 
            	library's resources are organized. Then, for each resource, describe briefly when, where, 
            	and how that string appears in the application's output.
            
            	<h2 class="dtH2">Examples</h2>
            	The <c>MyClass.cs</c> code that follows consumes the resources defined in the following 
            	files:
            	<hcaExample desc="Example 3:">
            		<hcaExample desc="messages.txt">
            			<code>
            SuccessMessage=The operation succeeded. [{0}]
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="es/messages.txt">
            			<code>
            SuccessMessage=La operación tenida éxito. [{0}]
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="fr/messages.txt">
            			<code>
            SuccessMessage=L'opération a réussi. [{0}]
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="app.config">
            			<code>
            <![CDATA[<?xml version="1.0" encoding="UTF-8"?>
            <configuration>
            	<!-- ... -->
            	<cf:hcaConfigFactory xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            			xsi:schemaLocation="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd ConfigFactory.xsd"
            			xmlns:cf="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">
            		<config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            			<property name="ContextName" value="MyAppContext"/>
            			<property name="AsmName" value="ResourceExample"/>
            			<property name="BaseName" value="messages"/>
            		</config>
            	</cf:hcaConfigFactory>
            </configuration>]]>
            			</code>
            		</hcaExample>
            		<br/>
            		<hcaExample desc="MyClass.cs">
            			<code>
            using System;
            using System.Globalization;
            using System.Threading;
            using Hca.Common.Resource;
            		
            namespace ResourceExample
            {
            	class MyClass
            	{
            		[STAThread]
            		static void Main(string[] args)
            		{
            			try
            			{
            				CultureInfo[] cultures = new CultureInfo[] {
            						CultureInfo.CreateSpecificCulture("es"),
            						CultureInfo.CreateSpecificCulture("fr"),
            						CultureInfo.CreateSpecificCulture("en") };
            				Random randomGenerator = new Random();
            				int whichCulture = randomGenerator.Next(3);
            				Console.WriteLine(cultures[whichCulture].ToString());
            				Thread.CurrentThread.CurrentUICulture = cultures[whichCulture];
            				Thread.Sleep(1000);
            				Console.WriteLine(MyClassResourceMessage.SuccessMessage("1000"));
            			}
            			finally
            			{
            				Console.ReadLine();
            			}
            		}
            	}
            }
            			</code>
            		</hcaExample>
            		<para/>
            		<hcaExample desc="MyClassResourceMessage.cs">
            			<code><![CDATA[
            using System;
            using System.Globalization;
            using System.Threading;
            using Hca.Common.Resource;
            		
            namespace ResourceExample
            {
            	public sealed class MyAppResourceMessage : ResourceMessage
            	{
            		private static string resourceContext = "MyAppContext";
            		
            		/// <summary>
            		/// Create a resource message from the given a name and some replaceable arguments.
            		/// </summary>
            		/// <param name="name">The name used within the resource to retrieve.</param>
            		/// <param name="formatArgs">Arguments to be placed into the message in sequential order.</param>
            		public MyAppResourceMessage (string name, params object[] formatArgs) : base(resourceContext, name, formatArgs) { }
            		
            		/// <summary>
            		/// <para>Used when an operation completed successfully.</para>
            		/// <para><b>Message:</b> "The operation succeeded. [{0}]"</para>
            		/// </summary>
            		/// <param name="arg">Some description of the argument goes here.</param>
            		public static MyAppResourceMessage SuccessMessage(string arg)
            		{
            			return new MyAppResourceMessage(MethodBase.GetCurrentMethod().Name, arg);
            		}
            		
            	}
            }]]>
            			</code>
            		</hcaExample>
            	</hcaExample>
            	<para/>
            	In the above scenario, the first few lines in <c>Main()</c> choose a culture for the User 
            	Interface. Spanish ("es") and French ("fr") have special resources defined for them. 
            	English ("en"), on the other hand, does not, and uses the default resource that's compiled 
            	with the code (which in this case, happens to be English.)
            	<para/>
            	The placeholder in the resources string ("{0}") is populated with the first (and only) 
            	member of the array passed to <see cref="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])"/>. 
            	So the output of this program will resemble the following:
            	<br/>
            	<hcaExample desc="MyClass output">
            		<code escaped="true">
            <![CDATA[E:\[…]\ResourceExample\bin\Debug>resourceexample
            fr-FR
            2004-01-16 09:53:44,381 [2272] INFO  [HcaLogger] [] <> - Logger initialized.
            L'opration a russi. [1000]]]>
            		</code>
            	</hcaExample>
            	<para/>
            	The preferred of method of accessing resources is to use 
            	<see cref="M:System.Reflection.MethodBase.GetCurrentMethod">System.Reflection.MethodBase.GetCurrentMethod().Name</see> 
            	as opposed to hard coding the resource name in the <see cref="T:Hca.Common.Resource.ResourceMessage"/> constructor calls. 
            	If the situation arises where different key names need to be accessed by the same method
            	or different methods need to access the same resource, the string name may be substituted.
            	<hcaExample desc="Using the resource name as opposed to MethodBase.GetCurrentMethod().Name">
            	<code><![CDATA[
            		...
            		/// <summary>
            		/// <para>Used to indicate some message.</para>
            		/// <para><b>Message:</b> "This is a test message [{0}]."</para>
            		/// </summary>
            		/// <param name="itemName">The name of the item being tested.</param>
            		public static MyAppResourceMessage MyMessage(string itemName)
            		{
            			return new MyAppResourceMessage(MethodBase.GetCurrentMethod().Name, itemName);
            		}
            
            		/// <summary>
            		/// <para>Used to indicate some message.</para>
            		/// <para><b>Message:</b> "This is a test message [{0}]."</para>
            		/// </summary>
            		/// <param name="itemName">The name of the item being tested.</param>
            		public static MyAppResourceMessage MyOtherMessage(string itemName)
            		{
            			return new MyAppResourceMessage("MyMessage", itemName);
            		}
            		...]]>
            	</code>
            	</hcaExample>
            	<para/>
            	
            	<hcaNote>
            		Describing the .NET Framework's code and resource compilation mechanisms is beyond the 
            		scope of this SDK. However, in case the reader desires to execute this example code, 
            		note that the author compiled the above example by executing the following command lines 
            		from his <c>ResourceExample\bin\Debug</c> directory:
            	</hcaNote>
            	<para/>
            	<img src="resource_compilation.gif"/>
            	<br/>
            	<i>Figure 3:</i>
            </summary>
        </member>
        <member name="T:Hca.Common.Resource.ResourceConfig">
            <summary>Configuration class for initializing a <see cref="T:Hca.Common.Resource.ResourceHelper"/>.</summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            <para>
            One or more objects instantiated using this class may be used to initialize a <see cref="T:Hca.Common.Resource.ResourceHelper"/>. 
            The <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/> property determines the context name which must be specified in subsequent calls 
            to <see cref="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])"/> methods.
            </para>
            <para>
            When multiple resources share the same name and context specified in the call 
            to <see cref="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])"/> across <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfigs</see>, their list order in 
            configuration determines precedence. This enables the override capability of the <see cref="T:Hca.Common.Resource.ResourceHelper"/>.
            </para>
            <para>
            All strings are required, that is, <see langword="null"/> in <see cref="P:Hca.Common.Resource.ResourceConfig.ContextName"/>, <see cref="T:System.Reflection.AssemblyName"/>, 
            or <see cref="P:Hca.Common.Resource.ResourceConfig.BaseName"/> will cause <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/> to throw an exception. Duplicate entries are valid and 
            will be given the search priority of the first (highest priority) appearance. Checking for the existence of 
            the <see cref="T:System.Reflection.AssemblyName">AssemblyName's</see> (and <see cref="P:Hca.Common.Resource.ResourceConfig.BaseName">BaseName's</see> inside) is left for 
            the <see cref="T:Hca.Common.Resource.ResourceHelper"/> when it attempts to consume the <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfig's</see> information.
            </para>
            </remarks>
            <example>
            <para>
            The following example illustrates a sample configuration file describing two <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects in a shared context.
            <code><![CDATA[
            <?xml version="1.0" encoding="utf-8" ?> 
            <cf:hcaConfigFactory xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            	xsi:schemaLocation="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd ConfigFactory.xsd"
            	xmlns:cf="http://hcaschema.hca.corpad.net/Common/Configuration/2.0/ConfigFactory.xsd">
              <config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            	<property name="ContextName" value="test1" />
            	<property name="AssemblyName" value="TestResources" />
            	<property name="BaseName" value="test1" />
              </config>
              <config type="Hca.Common.Resource.ResourceConfig" readOnly="true">
            	<property name="ContextName" value="test1" />
            	<property name="AssemblyName" value="TestResources" />
            	<property name="BaseName" value="test2" />
              </config>
            </cf:hcaConfigFactory>]]>
            </code>
            </para>
            </example>
            <seealso cref="N:Hca.Common.Resource">Hca.Common.Resource Namespace</seealso>
        </member>
        <member name="F:Hca.Common.Resource.ResourceConfig.contextName">
            <summary>
            Holds the 'context' name used to access 
            this <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfig's</see> <see cref="T:System.Resources.ResourceManager"/> through 
            the <see cref="T:Hca.Common.Resource.ResourceHelper"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Resource.ResourceConfig.assemblyName">
            <summary>Holds the strong name of the primary assembly in which to search for the .resources file.</summary>
        </member>
        <member name="F:Hca.Common.Resource.ResourceConfig.baseName">
            <summary>Holds the base name of the .resources file to find in the assembly.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.#ctor">
            <overloads>Initializes a new instance of a resource config.</overloads>
            <summary>Default Constructor.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.#ctor(System.String,System.String,System.String)">
            <summary>Constructor that will initialize a resource config with the passed parameters.</summary>
            <param name="contextName">
            The 'context' name to be used to access 
            this <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfig's</see> <see cref="T:System.Resources.ResourceManager"/> through 
            the <see cref="T:Hca.Common.Resource.ResourceHelper"/>.
            </param>
            <param name="assemblyName">The strong name of the primary assembly in which to search for the .resources file.</param>
            <param name="baseName">The base name of the .resources file to find in the assembly.</param>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.GetHashCode">
            <summary>Gets a value-based hash code for this object.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.Equals(System.Object)">
            <summary>Performs a value comparison of two <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects.</summary>
            <param name="obj">The object with which to compare this one.</param>
            <returns><see langword="true"/> if the objects contain the same values; <see langword="false"/> if not.</returns>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.op_Equality(Hca.Common.Resource.ResourceConfig,Hca.Common.Resource.ResourceConfig)">
            <summary>Performs a value comparison of two <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects.</summary>
            <returns><see langword="true"/> if the operands contain the same values; <see langword="false"/> if not.</returns>
        </member>
        <member name="M:Hca.Common.Resource.ResourceConfig.op_Inequality(Hca.Common.Resource.ResourceConfig,Hca.Common.Resource.ResourceConfig)">
            <summary>Performs a value comparison of two <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects.</summary>
            <returns><see langword="false"/> if the operands contain the same values; <see langword="true"/> if not.</returns>
        </member>
        <member name="P:Hca.Common.Resource.ResourceConfig.ContextName">
            <summary>
            Required. Gets or sets the 'context' name to be used to access 
            this <see cref="T:Hca.Common.Resource.ResourceConfig">ResourceConfig's</see> <see cref="T:System.Resources.ResourceManager"/> 
            through the <see cref="T:Hca.Common.Resource.ResourceHelper"/>.
            </summary>
        </member>
        <member name="P:Hca.Common.Resource.ResourceConfig.AsmName">
            <summary>Required. Gets or sets the strong name of the primary assembly in which to search for the .resources file.</summary>
        </member>
        <member name="P:Hca.Common.Resource.ResourceConfig.BaseName">
            <summary>Required. Gets or sets the base name of the .resources file to find in the assembly.</summary>
        </member>
        <member name="T:Hca.Common.Resource.ResourceHelper">
            <summary>
            A class that wraps one or more .Net <see cref="T:System.Resources.ResourceManager"/>(s) with contextual grouping 
            and cascading aggregation functionality.
            </summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para>
            A .Net <see cref="T:System.Resources.ResourceManager"/> handles culture-sensitive access to a set of .resources files, either on the file 
            system, or compiled into a set of assemblies. The <see cref="T:Hca.Common.Resource.ResourceHelper"/> wraps this functionality with some 
            additional useful features...
            </para>
            <para>
            First, multiple <see cref="T:System.Resources.ResourceManager">ResourceManagers</see> may be searched in a single call, enabling better 
            organization of those files without complicating the code used to access them. There is a concept of priority 
            among the various <see cref="T:System.Resources.ResourceManager">ResourceManagers</see>, avoiding name collision and allowing 
            overridable resource population (e.g., local customization of a library's default message texts).
            </para>
            <para>
            Additionally, <see cref="T:System.Resources.ResourceManager">ResourceManagers</see> may be arbitrarily organized into named groups, 
            called contexts to enable searching within a designated subset. This allows inadvertant naming collisions to be 
            avoided as seperate subsystems search only the appropriate <see cref="T:System.Resources.ResourceManager">ResourceManagers</see> for 
            their own resources. Once again, priority among contexts allows for search across all contexts with defined handling 
            for name collisions.
            </para>
            <para>
            Last but not least, the replaceable parameter capabilities of the .Net <see cref="M:System.String.Format(System.String,System.Object)"/> method 
            have been wrapped in for easy access directly through the <see cref="T:Hca.Common.Resource.ResourceHelper"/>. See the .Net documentation 
            and the overloads of the GetString() methods that include the <c>formatArgs</c> and <see cref="T:System.IFormatProvider"/> parameters.
            </para>
            <para>
            Note that at present, some of the .Net <see cref="T:System.Resources.ResourceManager"/> functionality has not been included in 
            the <see cref="T:Hca.Common.Resource.ResourceHelper"/>. The <see cref="M:System.Resources.ResourceManager.GetObject(System.String)"/> methods are absent, 
            and the ability to use .resources files directly from the filesystem has not been provided.
            </para>
            </remarks>
            <example>
            <para>This first example illustrates basic retrieval of a resource string.
            <code>
            string test = HcaResourceManager.Instance.GetString("context1", "resource1", new object[] {});
            </code>
            </para>
            <para>This second example illustrates retrieval of the same resource string, specifying context, culture, 
            whether to throw an exception if the resource cannot be found, and formatted parameter replacement.
            <code>
            System.Globalization.NumberFormatInfo formatProvider =
            	 new System.Globalization.NumberFormatInfo();
            formatProvider.CurrencySymbol = "$";
            
            string test = HcaResourceManager.Instance.GetString(
            	formatProvider,
            	new System.Globalization.CultureInfo("en-US"),
            	false,
            	"context1",
            	"resource1",
            	new object[] { "foo", "bar", 678.9 } );
            </code>
            </para>
            <para>Assuming the <c>en-US</c> culture-specific string resource named <c>"resource1"</c> in the context 
            named <c>"context1"</c> is defined as <c>"First value: {0} / Second value: {1} / Third value: {2:C}"</c>, this 
            code will populate <c>test</c> with the following string:
            <code>
            First value: foo / Second value: bar / Third value: $678.90
            </code>
            </para>
            <para>
            For an example of instantiating a <see cref="T:Hca.Common.Resource.ResourceHelper"/>, please see 
            the <see cref="T:Hca.Common.Resource.ResourceConfig"/> class.
            </para>
            </example>
        </member>
        <member name="F:Hca.Common.Resource.ResourceHelper.DEFAULT_FOR_EXCEPTION_IF_MISSING">
            <summary>The field value behind the DefaultForExceptionIfMissing property.</summary>
        </member>
        <member name="F:Hca.Common.Resource.ResourceHelper.contextsInOrder">
            <summary>Holds this <see cref="T:Hca.Common.Resource.ResourceHelper"/>'s Context objects ordered by search priority.</summary>
        </member>
        <member name="F:Hca.Common.Resource.ResourceHelper.contextsByName">
            <summary>Holds this ResourceHelper's Context objects for access by name.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.#ctor(System.String)">
            <overloads>Initializes a working <see cref="T:Hca.Common.Resource.ResourceHelper"/>.</overloads>
            <summary>Initializes a working <see cref="T:Hca.Common.Resource.ResourceHelper"/> wrapping the context and resources described 
            by the <see cref="T:Hca.Common.Resource.ResourceConfig"/>s defined in a given configuration context. </summary>
            <param name="configContext">The <see cref="T:Hca.Common.Configuration.ConfigFactory"/> context from which to retrieve one or 
            more <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects.</param>
            <exception cref="T:System.Configuration.ConfigurationException">A member of <paramref name="configContext"/> failed to <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">An assembly could not be found.</exception>
            <exception cref="T:System.BadImageFormatException">An assembly file is not a valid assembly.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.#ctor(Hca.Common.Resource.ResourceConfig)">
            <summary>Initializes a working <see cref="T:Hca.Common.Resource.ResourceHelper"/> wrapping the context and resources described by the <paramref name="config"/> parameter. </summary>
            <param name="config">A <see cref="T:Hca.Common.Resource.ResourceConfig"/> object. See that class' documentation for details.</param>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if <paramref name="config"/> fails to <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">An assembly could not be found.</exception>
            <exception cref="T:System.BadImageFormatException">An assembly file is not a valid assembly.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.#ctor(Hca.Common.Resource.ResourceConfig[])">
            <summary>Initializes a working <see cref="T:Hca.Common.Resource.ResourceHelper"/> wrapping the contexts and resources described by the <paramref name="configs"/> parameter. </summary>
            <param name="configs">An array of <see cref="T:Hca.Common.Resource.ResourceConfig"/> objects. See that class' documentation for details.</param>
            <exception cref="T:System.Configuration.ConfigurationException">A member of <paramref name="configs"/> failed to <see cref="M:Hca.Common.Configuration.ConfigBase.Validate"/>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">An assembly could not be found.</exception>
            <exception cref="T:System.BadImageFormatException">An assembly file is not a valid assembly.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.GetString_Impl(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters, localized for the specified culture, and optionally suppressing the exception if the resource is not found.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information for the <paramref name="formatArgs"/>.</param>
            <param name="culture">
            <para>The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the resource should be localized. Note that if the resource is not localized for this culture, the lookup will fall back using the culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping after looking in the neutral culture.</para>
            <para>If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained using the caller's current culture settings.</para>
            </param>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the specified context, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.GetString(System.String,System.String,System.Object[])">
            <overloads>Retrieves a string resource.</overloads>
            <summary>Retrieves a string resource without specifying a formatter.</summary>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.GetString(System.IFormatProvider,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information for the <paramref name="formatArgs"/>.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.GetString(System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, optionally suppressing the exception if the resource is not found.</summary>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the specified context, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.GetString(System.IFormatProvider,System.Globalization.CultureInfo,System.Boolean,System.String,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters, localized for the specified culture, and optionally suppressing the exception if the resource is not found.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information for the <paramref name="formatArgs"/>.</param>
            <param name="culture">
            <para>The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the resource should be localized. Note that if the resource is not localized for this culture, the lookup will fall back using the culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping after looking in the neutral culture.</para>
            <para>If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained using the caller's current culture settings.</para>
            </param>
            <param name="exceptionIfMissing">A <see cref="T:System.Boolean"/> allowing the caller to control the method's behavior if the resource cannot be found. If <see langword="false"/>, <see langword="null"/> will be returned. If <see langword="true"/>, a <see cref="T:Hca.Common.Resource.MissingResourceException"/> will be thrown if the <paramref name="context"/> is not found, or if the <paramref name="name"/> is not found in the context.</param>
            <param name="context">A <see cref="T:System.String"/> referencing a predefined resource context for the search. If not found, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the specified context, behavior will depend on the value of the <paramref name="exceptionIfMissing"/> parameter.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="context"/> or <paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:Hca.Common.Resource.MissingResourceException">Thrown if a best match is not possible and <paramref name="exceptionIfMissing"/> is <see langword="true"/>.</exception>
        </member>
        <member name="P:Hca.Common.Resource.ResourceHelper.DefaultForExceptionIfMissing">
            <summary>The default value for the GetString() methods' exceptionIfMissing parameter. Enables consistent overloading.</summary>
        </member>
        <member name="T:Hca.Common.Resource.ResourceHelper.ResourceContext">
            <summary>A class that wraps one or more .Net <see cref="T:System.Resources.ResourceManager"/>(s) with cascading aggregation functionality.</summary>
            <remarks>
            <para>Only the GetString methods are guaranteed thread-safe.</para>
            </remarks>
        </member>
        <member name="F:Hca.Common.Resource.ResourceHelper.ResourceContext.resourceManagers">
            <summary>Holds this Context's <see cref="T:System.Resources.ResourceManager"/> objects ordered by search priority.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.ResourceContext.#ctor(System.Resources.ResourceManager[])">
            <summary>Initializes a new Context per the parameter.</summary>
        </member>
        <member name="M:Hca.Common.Resource.ResourceHelper.ResourceContext.GetString(System.IFormatProvider,System.Globalization.CultureInfo,System.String,System.Object[])">
            <summary>Retrieves a string resource, using the specified formatter for replaceable parameters, localized for the specified culture.</summary>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> that supplies culture-specific formatting information for the <paramref name="formatArgs"/>.</param>
            <param name="culture">
            <para>The <see cref="T:System.Globalization.CultureInfo"/> object that represents the culture for which the resource should be localized. Note that if the resource is not localized for this culture, the lookup will fall back using the culture's <see cref="P:System.Globalization.CultureInfo.Parent"/> property, stopping after looking in the neutral culture.</para>
            <para>If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> is obtained using the caller's current culture settings.</para>
            </param>
            <param name="name">A <see cref="T:System.String"/> containing the name of the string resource to retrieve. If not found within the specified context, behavior will depend on the value of the exceptionIfMissing parameter.</param>
            <param name="formatArgs">An <see cref="T:System.Object"/> array containing zero or more objects to format inside the returned string.</param>
            <returns>The value of the resource, localized for the caller's current culture settings, or <see langword="null"/> if a best match is not possible.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="name"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:Hca.Common.Service.AroundInterceptor">
            <summary>
            An <see langword="abstract"/> <see cref="T:Hca.Common.IInterceptor"/> that allows work to be performed before and after invocation.
            </summary>
            <remarks>
            This interceptor will call <see cref="M:Hca.Common.Service.AroundInterceptor.PreProceed(Hca.Common.IInvocation,System.Object[])"/> method, call <see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/>
            on the invocation, determine if the proceed failed, and then call
            <see cref="M:Hca.Common.Service.AroundInterceptor.PostProceed(Hca.Common.IInvocation,System.Boolean,System.Object@,System.Object[])"/> with failure notice. Implementors of this class
            just need to implement the abstract Pre- and Post- Proceed methods.
            <seealso cref="T:Hca.Common.Service.LoggingInterceptor"/>
            <seealso cref="T:Hca.Common.Service.ImpersonationInterceptor"/>
            </remarks>
            <threadsafety static="true" instance="true"/> 
        </member>
        <member name="T:Hca.Common.IInterceptor">
            <summary>
            Interface that defines the interceptor concept.
            A proxy will call back on this interceptor when it is
            invoked by a client.
            </summary>
            <remarks>
            <para>The interceptor receives the proxy invocation and has the opportunity
            to perform work if desired and then allow method invocation to proceed.
            Any work performed before or after method invocation is synchronous so
            if the interceptors are chained together the collective time might be unacceptable.
            If you need to perform a long running task, then you might want to
            consider performing the work asynchronously.</para>
            <para>Note that, to guarantee proper handling for multi-threaded services, 
            implementations of this interface must ensure thread safety.</para>
            </remarks>
            <threadsafety static="true" instance="true" /> 
        </member>
        <member name="M:Hca.Common.IInterceptor.Intercept(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Receives a proxy invocation and performs any desired work.
            </summary>
            <param name="invocation">The <see cref="T:Hca.Common.IInvocation"/> describing the call being intercepted.</param>
            <param name="args">The arguments on the invocation.</param>
            <returns>The result of invocation - usually (but not necessarily) obtained by calling <paramref name="invocation"/>.<see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/>.</returns>
        </member>
        <member name="M:Hca.Common.Service.AroundInterceptor.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.Service.AroundInterceptor.Intercept(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Call <see cref="M:Hca.Common.Service.AroundInterceptor.PreProceed(Hca.Common.IInvocation,System.Object[])"/> before proceeding and then <see cref="M:Hca.Common.Service.AroundInterceptor.PostProceed(Hca.Common.IInvocation,System.Boolean,System.Object@,System.Object[])"/>.
            </summary>
            <remarks>Note that the post proceed is guaranteed to be called
            even if the invocation proceed fails.
            </remarks>
            <param name="invocation">invocation</param>
            <param name="args">arguments for invocation</param>
            <returns>object create from invocation</returns>
        </member>
        <member name="M:Hca.Common.Service.AroundInterceptor.PreProceed(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Do some work before invocation proceeds.
            </summary>
            <param name="invocation">the invocation object</param>
            <param name="args">arguments passed to invocation proceed</param>
        </member>
        <member name="M:Hca.Common.Service.AroundInterceptor.PostProceed(Hca.Common.IInvocation,System.Boolean,System.Object@,System.Object[])">
            <summary>
            Do some work after invocation proceeded. This method is guaranteed to be called even
            if the proceed fails.
            </summary>
            <param name="invocation">the invocation object</param>
            <param name="invocationFailed"><see langword="true"/> if invocation proceed failed</param>
            <param name="returnValue">return value from invocation proceeding</param>
            <param name="args">arguments passed to invocation proceed</param>
        </member>
        <member name="T:Hca.Common.Service.ImpersonationInterceptor">
            <summary>
            Interceptor that provides impersonation around the invocation by
            entering a Windows 32 Identity Context, <see cref="M:Hca.Common.Utility.WindowsSecurity.EnterWin32IdentityContext(System.Security.Principal.WindowsIdentity)"/>, for the credential provided.
            This interceptor provides support for the Trusted Subsystem security model.
            </summary>
            <remarks>
            Usually application's security model is either impersonation/delegation or trusted subsystem.
            <list type="bullet">
            		<item>Impersonation/Delegation - The orginal caller's Windows identity is used to access a resource.</item>
            		<item>Trsuted Subsytem - The caller is authorized to perform an action and the action is performed with
            the identity of a trusted user which is typically a service account.</item>
            	</list>	
            If a credential is not provided no context is entered.
            <seealso cref="T:Hca.Common.Utility.WindowsSecurity"/>
            </remarks>
            <threadsafety static="true" instance="true"/> 
        </member>
        <member name="M:Hca.Common.Service.ImpersonationInterceptor.#ctor(System.Net.NetworkCredential)">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/>.</overloads>
            
            <summary>Initializes a new instance of <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/> using the specified <see cref="T:System.Net.NetworkCredential"/>.</summary>	
            <param name="credential">Credential to use to perform impersonation.</param>	
        </member>
        <member name="M:Hca.Common.Service.ImpersonationInterceptor.#ctor(System.Security.Principal.WindowsIdentity)">
            <summary>Initializes a new instance of <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/> using the specified <see cref="T:System.Security.Principal.WindowsIdentity"/>.</summary>	
            <param name="identity">Identity to use to perform impersonation.</param>	
        </member>
        <member name="M:Hca.Common.Service.ImpersonationInterceptor.Intercept(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Enters a Windows Identity Context
            </summary>
            <param name="invocation">proxy invocation</param>
            <param name="args">arguments of invocation</param>
            <returns>object create from invocation</returns>
        </member>
        <member name="T:Hca.Common.Service.InterceptorStack">
            <summary>
            Provides for stacking interceptors. The stack itself is an interceptor.
            This allows for interceptors to be nested.
            </summary>
            <remarks>
            When the stack is invoked by a proxy, the members 
            on the stack will be chained together and invoked. 
            The execution order is FIFO. 
            </remarks>
            <threadsafety static="true" instance="true" /> 
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Clear">
            <summary>
            <see cref="M:System.Collections.Stack.Clear"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Clone">
            <summary>
            <see cref="M:System.Collections.Stack.Clone"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Casts <paramref name="array"/> to <see cref="T:Hca.Common.IInterceptor"/> array and calls
            strongly-typed <see cref="M:Hca.Common.Service.InterceptorStack.CopyTo(Hca.Common.IInterceptor[],System.Int32)"/>.
            </summary>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown when <paramref name="array"/> is not an <see cref="T:Hca.Common.IInterceptor"/> array.</exception>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.CopyTo(Hca.Common.IInterceptor[],System.Int32)">
            <summary>
            Type-safe implementation of <see cref="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)"/>.
            </summary>
            <param name="array">The array to copy the items to.</param>
            <param name="index">The index to begin copying from.</param>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.Stack.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals(System.Object)"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.GetHashCode">
            <summary>
            <see cref="M:System.Object.GetHashCode"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Contains(Hca.Common.IInterceptor)">
            <summary>
            <see cref="M:System.Collections.Stack.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Peek">
            <summary>
            <see cref="M:System.Collections.Stack.Peek"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Pop">
            <summary>
            <see cref="M:System.Collections.Stack.Pop"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Push(Hca.Common.IInterceptor)">
            <summary>
            <see cref="M:System.Collections.Stack.Push(System.Object)"/>
            </summary>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.ToArray">
            <summary>
            <see cref="M:System.Collections.Stack.ToArray"/>
            </summary>
            <returns><see langword="array"/> of interceptors</returns>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStack.Intercept(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Propagates an invocation interception through the members of the stack, bottom-up (FIFO).
            </summary>
            <param name="invocation">Describes the <see cref="T:Hca.Common.IInvocation"/> being intercepted.</param>
            <param name="args">The invocation arugments.</param>
            <returns>The value returned by the first <see cref="T:Hca.Common.IInterceptor"/> to stop propagation, or the result of <paramref name="invocation"/>.<see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/>, if each interceptor calls back.</returns>
        </member>
        <member name="P:Hca.Common.Service.InterceptorStack.Count">
            <summary>
            <see cref="P:System.Collections.Stack.Count"/>
            </summary>
        </member>
        <member name="P:Hca.Common.Service.InterceptorStack.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.Stack.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:Hca.Common.Service.InterceptorStack.SyncRoot">
            <summary>
            <see cref="P:System.Collections.Stack.SyncRoot"/>
            </summary>
        </member>
        <member name="T:Hca.Common.IInvocation">
            <summary>Interface used in conjunction with <see cref="T:Hca.Common.IInterceptor"/> to 
            abstract a proxied call that is being intercepted.</summary>
            <remarks>The properties on this interface provide information about the object and 
            method being invoked, as well as the invoking proxy. The 
            <see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/> method calls back to the proxy to perform the actual 
            invocation. Note that an interceptor implementation may override the standard 
            invocation by simply returning without calling back.</remarks>
        </member>
        <member name="M:Hca.Common.IInvocation.Proceed(System.Object[])">
            <summary>Passes the invocation back to <see cref="P:Hca.Common.IInvocation.Proxy"/> for handoff to <see cref="P:Hca.Common.IInvocation.InvocationTarget"/>.</summary>
            <param name="args">The invocation arguments to pass to <see cref="P:Hca.Common.IInvocation.InvocationTarget"/>.</param>
            <returns>The result of the invocation.</returns>
        </member>
        <member name="P:Hca.Common.IInvocation.Proxy">
            <summary>Gets the dynamically-compiled object proxying the invocation.</summary>
        </member>
        <member name="P:Hca.Common.IInvocation.InvocationTarget">
            <summary>Gets the underlying object which will receive the invocation when <see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/> is called.</summary>
        </member>
        <member name="P:Hca.Common.IInvocation.Method">
            <summary>Describes the method being invoked.</summary>
        </member>
        <member name="T:Hca.Common.Service.InterceptorStackConfig">
            <summary>
            This configuration allows you to define reusable interceptor stacks for services.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            <p>Example configuration for a stack of interceptors</p>
            <code><![CDATA[
            <config type="Hca.Common.Service.InterceptorStackConfig" readOnly="true" context="testInterceptorStack">
            	<property name="Interceptors">
            		<object type="Hca.Common.Service.LoggingInterceptor"/>
            		<object type="Hca.Common.Service.TimingInterceptor"/>
            	</property>
            </config>
            ]]></code>
            <p>Your service config can now reference the interceptor stack as so -</p>
            <code><![CDATA[
            <config type="Hca.Common.Service.ServiceConfig" readOnly="true" context="realService">
            	<property name="InterceptorStackConfig" value="testInterceptorStack"/>
            </config>
            ]]></code>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStackConfig.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Service.InterceptorStackConfig"/>.</overloads>
            <summary>
            Default Constructor.
            </summary>		
        </member>
        <member name="M:Hca.Common.Service.InterceptorStackConfig.#ctor(Hca.Common.IInterceptor)">
            <summary>
            Constructor which takes an interceptor to add.
            </summary>
            <param name="interceptor">The interceptor to add.</param>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStackConfig.MakeInterceptorStack">
            <summary>
            Builds interceptor stack
            </summary>
            <returns>interceptor stack</returns>
        </member>
        <member name="M:Hca.Common.Service.InterceptorStackConfig.ValidateCustom">
            <summary>
            Determines if this configuration is valid.
            </summary>
        </member>
        <member name="P:Hca.Common.Service.InterceptorStackConfig.Interceptors">
            <summary>
            List of interceptors
            </summary>
            <remarks>
            <p>Note that the order of the interceptors in the array is the order they are
            placed on the stack; i.e., interceptor[0] will be pushed on the stack first.</p> 
            </remarks>
        </member>
        <member name="T:Hca.Common.Service.LoggingInterceptor">
            <summary>
            Logs DEBUG 'START' and 'FINISH' markers around the invocation chain including the passed in arguments.
            </summary>
            <remarks>
            This interceptor should normally be the first interceptor on the stack. An example output from this
            interceptor is the following:
            		<code>
            2006-02-07 08:42:19,856 [DEBUG] CORPPDCDT3837 (3104) LoggingInterceptor [(null)] - START: Service method [PaymentService] invocation with arguments []
            2006-02-07 08:42:19,856 [INFO] CORPPDCDT3837 (3104) ImpersonationInterceptor [(null)] - Impersonating service method call with credential [zzy1234@HCA]
            2006-02-07 08:42:19,950 [DEBUG] CORPPDCDT3837 (3104) WindowsSecurity [(null)] - Entering Win32 identity context: setting unmanaged thread identity to [HCA\zzy1234] from [HCA\cdt3837].
            2006-02-07 08:42:19,950 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - Constructed helper for object named [Win32IdentityContext: [HCA\zzy1234]].
            2006-02-07 08:42:19,965 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() requested on object named [Win32IdentityContext: [HCA\zzy1234]] by thread [3104].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - Thread [3104] has primary request to MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]]: marking helper disposed.
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]] blocking thread [3104] for holds ....
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]] returning on thread [3104].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) WindowsSecurity [(null)] - Exiting Win32 identity context: resetting unmanaged thread identity back to [HCA\cdt3837].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) LoggingInterceptor [(null)] - FINISHED: Service method [PaymentService] invocation				
            		</code>
            </remarks>
            <threadsafety static="true" instance="true" /> 
        </member>
        <member name="M:Hca.Common.Service.LoggingInterceptor.PreProceed(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Log debug start information
            </summary>
            <param name="invocation">proxy invocation</param>
            <param name="args">arguments of invocation</param>
        </member>
        <member name="M:Hca.Common.Service.LoggingInterceptor.PostProceed(Hca.Common.IInvocation,System.Boolean,System.Object@,System.Object[])">
            <summary>
            Log debug finished information
            </summary>
            <param name="invocation">proxy invocation</param>
            <param name="invocationFailed"><see langword="true"/> if invocation proceed failed</param>
            <param name="returnValue">the new value of return object if changed.</param>
            <param name="args">arguments of invocation</param>
        </member>
        <member name="T:Hca.Common.Service.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Overview</h2>
            	This section describes the requirements that shaped the design and implementation of the 
            	service namespace, <see cref="N:Hca.Common.Service"/>. 
            
            	<h3 class="dtH3">Service Layer Defined</h3>
            	A <i>Service Layer</i> defines an application's boundary and its set of available operations 
            	from the perspective of interfacing client layers. It encapsulates the application's 
            	business logic, controlling transactions and coordinating responses in the implementation 
            	of its operations. In addition, it "factors each kind of business logic (domain and application) 
            	into a separate	layer, yielding the usual benefits of layering and rendering the pure 
            	domain object classes more reusable from application to application." [ServiceLayer]
            
            	<h3 class="dtH3">How It Works</h3>
            	A <i>Service Layer</i> can be implemented in a couple of different ways, without violating 
            	the defining characteristics stated above. The differences appear in the allocation of 
            	responsibility behind the <i>Service Layer</i> interface.
            
            	<h4 class="dtH4">Implementation Variations</h4>
            	The two basic implementation variations are the <c>domain façade</c> approach and the 
            	<c>operation script</c> approach. In the <c>domain façade</c> approach, a <i>Service 
            	</i>Layer is implemented as a set of thin facades over a <i>Domain Model</i>. The classes 
            	implementing the facades don't implement any business logic. Rather, the <i>Domain Model</i> 
            	implements all of the business logic. The thin facades establish a boundary and set of 
            	operations through which client layers interact with the application, exhibiting the 
            	defining characteristics of Service Layer. In the operation script approach, a <i>Service 
            	Layer</i> is implemented as a set of thicker classes that directly implement application 
            	logic but delegate to encapsulated domain object classes for domain logic. The operations 
            	available to clients of a <i>Service Layer</i> are implemented as scripts, organized 
            	several to a class defining a subject area of related logic. Each such class forms an 
            	application <i>service</i> and it's common for service type names to end with <c>Service</c>.
            
            	<h4 class="dtH4">Identifying Services and Operations</h4>
            	Identifying the operations needed on a <i>Service Layer</i> boundary is pretty straightforward. 
            	They're determined by the needs of <i>Service Layer</i> clients, the most significant is 
            	usually a user interface. Since a user interface is designed to support the use cases that 
            	actors want to perform with an application, the starting point for identifying <i>Service 
            	Layer</i> operation is the use case model and the user interface design for the application. 
            	Many of the use cases in an enterprise application are typically <i>CRUD</i> (create, read, 
            	update, delete) use cases on domain objects, and in most cases there is a one-to-one 
            	correspondence between CRUD use cases and <i>Service Layer</i> operations.
            	<para/>
            	There are no hard-and-fast prescriptions to group related <i>Service Layer</i> operations. 
            	For a sufficiently small application, it may suffice to have but one abstraction, named 
            	after the application itself. Larger applications tend to be partitioned into several 
            	<i>subsystems</i>, each of which includes a complete vertical slice through the stack of 
            	architecture layers. In this case one abstraction per subsystem, named after the subsystem 
            	is preferred. Other possibilities include abstractions reflecting major partitions in a 
            	domain model, if these are different from the subsystem partitions (e.g. <c>ContractService</c>, 
            	<c>ProductService</c>), and abstractions named after thematic application behaviors (e.g., 
            	<c>RecognitionService</c>).
            	<para/>
            	The following provides an example of a service interface based on the operation script 
            	implementation.
            	<hcaExample desc="Example 1: Example Service Interface">
            		<code>
            public interface IAuthorizationProvider
            {
            	void Authorize(string operation);
            	void Authorize(string operation, string auditMessage);
            	void Authorize(WindowsIdentity identity, string operation, string auditMessage);
            	bool OperationAllowed(string operation);
            	bool OperationAllowed(WindowsIdentity identity, string operation);
            	bool OperationAllowed(string userName, string domain, string operation);
            	IPrincipal GetPrincipal(WindowsPrincipal principal);
            	string[] GetApplicationRoles();
            	string[] GetUserRoles();
            	string[] GetUserRoles(WindowsIdentity identity);
            	string[] GetUserRoles(string userName, string domain);
            }
            		</code>
            	</hcaExample>
            	<para/>
            	Service interfaces represent logical boundary points in a system such as between layers or 
            	tiers. They usually represent major controllers in any application design. These controllers 
            	or services are a place to control program flow, security, role impersonation, provide transactional boundaries, etc.
            
            	<h3 class="dtH3">References</h3>
            	The following works are referenced in this SDK:
            	<para/>
            	<i>Table 1: Referenced Works</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Label</th>
            				<th width="50%">Title</th>
            				<th width="30%">Reference</th>
            			</tr>
            			<tr>
            				<td>BusinessDelegate</td>
            				<td>Core J2EE Patterns – Business Delegate</td>
            				<td><see href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/BusinessDelegate.html"/></td>
            			</tr>
            			<tr>
            				<td>ServiceLayer</td>
            				<td>Patterns of Enterprise Application Architecture</td>
            				<td>Service Layer Pg. 133</td>
            			</tr>
            			<tr>
            				<td>DesignPatterns</td>
            				<td>Design Patterns</td>
            				<td>Design Patterns by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides; 1994</td>
            			</tr>
            			<tr>
            				<td>ExceptionUsage</td>
            				<td>Exception Usage</td>
            				<td>HCA DevBlock – Exception SDK</td>
            			</tr>
            			<tr>
            				<td>ConfigurationUsage</td>
            				<td>Configuration Usage</td>
            				<td>HCA DevBlock – Configuration SDK</td>
            			</tr>
            			<tr>
            				<td>AOP</td>
            				<td>Aspect Oriented Programming</td>
            				<td><see href="http://aosd.net/"/></td>
            			</tr>
            		</table>
            	</div>
            
            	<h3 class="dtH3">Requirements</h3>
            	The following requirements describe the constraints and functional needs placed on the Service 
            	namespace:
            	<list type="bullet">
            		<item>Allow common features such as impersonation, logging, and timing to be easily reused by services.</item>
            		<item>Allow service creation to be defined in a configuration class.</item>
            	</list>
            
            	<h2 class="dtH2">Design</h2>
            	<h3 class="dtH3">Service Helper</h3>
            	The <see cref="T:Hca.Common.Service.ServiceHelper"/> is a class with static methods that can proxy a service's implemented
            	interfaces or create the service and then proxy it. The creation of the service is defined in the <see cref="T:Hca.Common.Service.ServiceConfig"/>.
            	This class allows you to create reusable functionality through the use of the Proxy Pattern [DesignPattern]
            	that may be utilized non-invasively by your services. The Proxy Pattern is often used in the following
            	circumstances:
            	<list type="bullet">
            		<item>When you need a local representative for an object in a different address space.</item>
            		<item>When you want to minimize the creation of expensive operations to Just-In-Time.</item>
            		<item>When you want to control access to an object.</item>
            		<item>When you require additional work to be performed when an object is accessed.</item>
            	</list>
            
            	Through this pattern the helper class provides a proxy class that implements the service's <em>public</em>
            	interfaces that are <em>not</em> explicitly implemented. 
            	As the user interacts with a service interface, the proxy class calls its interceptors.
            	The proxy interceptors allow work to be performed before and/or after the actual service is invoked.
            	This allows common functionality like <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/>, 
            	<see cref="T:Hca.Common.Service.LoggingInterceptor"/>, <see cref="T:Hca.Common.Service.TimingInterceptor"/>, and others to be reused.
            	In addition, the class allows clients to pass in their own stack of interceptors if desired.			
            
            	<h2 class="dtH2">Usage</h2>
            	This section describes the configuration of Services and its typical helper usage. The service helper
            	will typically be used by applications in the following way.
            	<para/>
            	For web applications, the web tier should be considered as a throwaway user interface where the business logic
            	is behind service interfaces. The web tier does not concern itself with how the service is defined, created,
            	uses roles, etc. The business tier handles these complexities. The web tier is responsible for interpreting the
            	request, calling the appropriate service, and displaying the response. To support this scenario, it is recommended
            	that the business tier provide static getter methods that return the service's <see langword="Interface"/>. 
            	<hcaExample desc="Example 2: Example Web Tier Service Call">
            		<code>
            		IPaymentService paymentService = BusinessService.GetPaymentService();
            		</code>
            	</hcaExample>
            	<para/>
            	<hcaExample desc="Example 3: Example Business Tier Service Factory">
            		<code>
            		public class BusinessService {
            			private static IPaymentService paymentService;
            			private static object objectLock = new object();
            
            			static BusinessService()
            			{
            				ConfigFactory.Instance.Refreshed += new EventHandler(HandleConfigRefresh);
            			} 
            
            			public static IPaymentService GetPaymentService() {
            				if (null==paymentService) {
            					lock(objectLock) {
            						if (null==paymentService) {
            							BusinessServiceConfig config = (BusinessServiceConfig)ConfigFactory.Instance.GetConfig(typeof(BusinessServiceConfig));								
            							//proxy the interface and impersonate calls
            							paymentService = ServiceHelper.ProxyService(new PaymentService(), config.RoleCredential);
            						}
            					}
            				}					
            				return paymentService;
            			}
            			
            			public static IPaymentService GetPaymentService(string configContext) {
            				if (null==paymentService) {
            					lock(objectLock) {
            						if (null==paymentService) {
            							BusinessServiceConfig config = (BusinessServiceConfig)ConfigFactory.Instance.GetConfig(typeof(BusinessServiceConfig), configContext);								
            							//proxy the interface and impersonate calls
            							paymentService = ServiceHelper.ProxyService(new PaymentService(), config.RoleCredential);
            						}
            					}
            				}					
            				return paymentService;
            			}
            
            			private static void HandleConfigRefresh(object sender, EventArgs e) {
            				// Config was refreshed, so invalidate cached objects
            				paymentService = null;
            			} 				
            		}
            		</code>
            	</hcaExample>
            	<para/>
            	In the above example, the service implementation <c>PaymentService</c> is backed by a proxy that has
            	a default stack of interceptors associated with it. When the interface is invoked, the interceptors
            	will perform the following work:
            	<hcaExample desc="Default Interceptor Stack Output">
            		<code>
            2006-02-07 08:42:19,856 [DEBUG] CORPPDCDT3837 (3104) LoggingInterceptor [(null)] - START: Service method [PaymentService] invocation with arguments []
            2006-02-07 08:42:19,856 [INFO] CORPPDCDT3837 (3104) ImpersonationInterceptor [(null)] - Impersonating service method call with credential [zzy1234@HCA]
            2006-02-07 08:42:19,950 [DEBUG] CORPPDCDT3837 (3104) WindowsSecurity [(null)] - Entering Win32 identity context: setting unmanaged thread identity to [HCA\zzy1234] from [HCA\cdt3837].
            2006-02-07 08:42:19,950 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - Constructed helper for object named [Win32IdentityContext: [HCA\zzy1234]].
            2006-02-07 08:42:19,965 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() requested on object named [Win32IdentityContext: [HCA\zzy1234]] by thread [3104].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - Thread [3104] has primary request to MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]]: marking helper disposed.
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]] blocking thread [3104] for holds ....
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) DisposalHelper [(null)] - MarkDisposed() on object named [Win32IdentityContext: [HCA\zzy1234]] returning on thread [3104].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) WindowsSecurity [(null)] - Exiting Win32 identity context: resetting unmanaged thread identity back to [HCA\cdt3837].
            2006-02-07 08:42:19,981 [DEBUG] CORPPDCDT3837 (3104) LoggingInterceptor [(null)] - FINISHED: Service method [PaymentService] invocation				
            		</code>
            	</hcaExample>
            	<para/>
            	In the next example, a web service is proxied utlizing the default interceptor stack. This means that
            	impersonation will be performed before its methods are invoked.
            	<hcaExample desc="Example 3: Web Service Call">
            		<code>
            			WebServiceClass proxy = new WebServiceClass();
            			proxy.Credentials = System.Net.CredentialCache.DefaultCredentials;
            			//now proxy the service with the default interceptor stack
            			return ServiceHelper.ProxyService(proxy);				
            		</code>
            	</hcaExample>
            	
            	<para/>
            	Most of the value add from <see cref="T:Hca.Common.Service.ServiceHelper"/> is provided by the stack of interceptors. By default, the 
            	default interceptor stack (see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>) is used. Its implementation 
            	provides a <see cref="T:Hca.Common.Service.LoggingInterceptor"/>, a <see cref="T:Hca.Common.Service.TimingInterceptor"/>, and (optionally) an <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/>.				
            </summary>
        </member>
        <member name="T:Hca.Common.Service.ProxyServiceException">
            <summary>
            Thrown when there is a problem proxying a service.
            </summary>
            <seealso cref="T:Hca.Common.BaseException.HcaSystemException"/>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.Service.ProxyServiceException.#ctor">
            <overloads>Initializes a new instance of a <see cref="T:Hca.Common.Service.ProxyServiceException"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.Service.ProxyServiceException.#ctor(System.Exception)">
            <summary>
            Constructor that takes the cause of the exception
            </summary>
            <param name="cause">The reason for this exception</param>
        </member>
        <member name="M:Hca.Common.Service.ProxyServiceException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes the Message for the Exception
            </summary>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.Service.ProxyServiceException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Creates a new instance of the <see cref="T:Hca.Common.Service.ProxyServiceException"/> class
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The reason for this exception</param>
        </member>
        <member name="M:Hca.Common.Service.ProxyServiceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used for deserialization of the exception <see cref="T:Hca.Common.Service.ProxyServiceException"/> class.
            </summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="T:Hca.Common.Service.ServiceConfig">
            <summary>Defines the instantiation mechanisim and proxy interceptors for a named service object.</summary>
            <remarks>
            <para>
            Instance of this class are used by <see cref="T:Hca.Common.Service.ServiceHelper"/>. <see cref="M:Hca.Common.Service.ServiceHelper.CreateServiceAndProxy(Hca.Common.Service.ServiceConfig)"/> creates a service object by 
            invoking the factory method or constructor described by a <see cref="T:Hca.Common.Service.ServiceConfig"/> object and passing the defined parameters. This 
            allows client code to be compiled without any hard-coded knowledge of how 
            service implementations will be instantiated.
            </para>
            <para>
            Users can also specify interceptors to be attached to the proxy object. By 
            default, the interceptors returned by <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Net.NetworkCredential)"/> will be attached. 
            (Specify the impersonation account using <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.) This default stack may be 
            extended by specifying <see cref="T:Hca.Common.Service.InterceptorStackConfig"/>, and/or 
            overridden by setting <see cref="P:Hca.Common.Service.ServiceConfig.UseDefaultInterceptorStack"/> to <see langword="false"/>.
            </para>
            <para>
            Note that nothing in the configuration indicates what interfaces will be 
            implemented by the service object. It is the responsibility of the caller to 
            ensure that the call to <see cref="M:Hca.Common.Service.ServiceHelper.CreateServiceAndProxy(Hca.Common.Service.ServiceConfig)"/> 
            specifies the configuration context of the intended <see cref="T:Hca.Common.Service.ServiceConfig"/>.
            </para>
            <h4 class="dtH4">Instantiation Styles</h4>
            <para>
            <see cref="T:Hca.Common.Service.ServiceHelper"/> supports two styles of service instantiation: (1) invocation of an object constructor, or (2) invocation of a static factory method. The following tables describe how to use the <see cref="T:Hca.Common.Service.ServiceConfig"/> properties for each of these approaches.
            </para>
            <para><strong>Specifying Constructor Invocation</strong></para>
            <list type="table">
            <listheader>
            	<term>Property Name</term>
            	<description>Value</description>
            </listheader>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/></term>
            	<description>The type whose constructor will be invoked. If multiple overloads exist, <see cref="T:Hca.Common.Service.ServiceHelper"/> will select one using <see cref="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs"/>.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs"/></term>
            	<description>The arguments (if any) to pass to the constructor.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/></term>
            	<description>Must be <see langword="null"/>.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/></term>
            	<description>Must be <see langword="null"/>.</description>
            </item>
            </list>
            <para><strong>Specifying Factory Method Invocation</strong></para>
            <list type="table">
            <listheader>
            	<term>Property Name</term>
            	<description>Value</description>
            </listheader>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/></term>
            	<description>The type containing the static factory method that will be invoked.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs"/></term>
            	<description>Must be <see langword="null"/>.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/></term>
            	<description>The name of the static factory method. If multiple overloads exist, <see cref="T:Hca.Common.Service.ServiceHelper"/> will select one using <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/>.</description>
            </item>
            <item>
            	<term><see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/></term>
            	<description>The arguments (if any) to pass to the static factory method.</description>
            </item>
            </list>
            <seealso cref="T:System.Net.NetworkCredential"/> 
            <seealso cref="T:Hca.Common.Service.ServiceHelper"/> 
            <seealso cref="T:Hca.Common.Service.InterceptorStack"/> 
            <seealso cref="T:Hca.Common.IInterceptor"/> 
            <seealso cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Net.NetworkCredential)"/> 
            <seealso cref="T:Hca.Common.Service.InterceptorStackConfig"/>
            </remarks>
            <example>
            Following is sample <see cref="T:Hca.Common.Configuration.ConfigFactory"/> XML defining two instances of <see cref="T:Hca.Common.Service.ServiceConfig"/>.
            <code>
            <![CDATA[<config type="Hca.Common.Service.ServiceConfig" context="Hca.Product.Service.IType:Real">
            	<property name="ServiceType" value="Hca.Product.Service.Type"/>
            	<property name="ServiceCreationMethod" value="FactoryMethod"/>
            	<property name="ServiceCreationMethodArgs">
            		<object type="ArgType">argValue</object>
            	</property>
            	<property name="InterceptorStackContext" value="myStack"/>
            	<property name="NetworkCredential">
            		<property name="Domain" value="HCA" />
            		<property name="UserName" value="Account" />
            		<property name="Password" value="*****" />
            	</property>
            </config>
            <config type="Hca.Common.Service.ServiceConfig" context="Hca.Product.Service.IType:Stub">
            	<property name="ServiceType" value="Hca.Product.Service.Stub"/>
            	<property name="ServiceTypeArgs">
            		<object type="ArgType">argValue</object>
            	</property>
            	<property name="UseDefaultInterceptorStack" value="false"/>
            </config>]]>
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.#ctor">
            <overloads>Initializes an instance.</overloads>
            
            <summary>Initializes an instance with nothing specified.</summary>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.#ctor(System.Type)">
            <summary>Initializes an instance with the specified construction type.</summary>
            <param name="serviceType">The type exposing the constructor to be used for instantiation of the service.</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.#ctor(System.Type,System.Object[])">
            <summary>Initializes an instance with the specified construction type and arguments.</summary>
            <param name="serviceType">The type exposing the constructor to be used for instantiation of the service.</param>
            <param name="serviceTypeArgs">The arguments (if any) to pass to the service constructor.</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.#ctor(System.Type,System.String)">
            <summary>Initializes an instance with the specified factory type and method.</summary>
            <param name="serviceType">The type exposing the static factory method to be used for instantiation of the service.</param>
            <param name="serviceCreationMethod">The name of the static factory method to be used for instantiation of the service.</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.#ctor(System.Type,System.String,System.Object[])">
            <summary>Initializes an instance with the specified factory type, method, and arguments.</summary>
            <param name="serviceType">The type exposing the static factory method to be used for instantiation of the service.</param>
            <param name="serviceCreationMethod">The name of the static factory method to be used for instantiation of the service.</param>
            <param name="serviceCreationMethodArgs">The arguments (if any) to pass to the factory method.</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceConfig.ValidateCustom">
            <summary>Ensures that this configuration is valid.</summary>
            <exception cref="T:Hca.Common.BaseException.HcaConfigurationException">
            <para>Thrown if <see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/> is <see langword="null"/>;</para>
            <para>-- OR --</para>
            <para>if <see cref="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs"/> is specified along with <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> and/or <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/>;</para>
            <para>-- OR --</para>
            <para>if <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/> is specified while <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> is <see langword="null"/>;</para>
            <para>-- OR --</para>
            <para>if <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> contains an invalid character, or if <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.<see cref="P:System.Net.NetworkCredential.Domain"/> or <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/> while the other (or <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/>.<see cref="P:System.Net.NetworkCredential.Password"/>) is not;</para>
            <para>-- OR --</para>
            <para>if <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/> is specified while <see cref="P:Hca.Common.Service.ServiceConfig.UseDefaultInterceptorStack"/> is <see langword="false"/>.</para>
            </exception>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.ServiceType">
            <summary>Gets or sets the type exposing the constructor or static factory method to be used for instantiation of the service.</summary>
            <remarks>This property may not be <see langword="null"/>. The constructor overload to be invoked will be determined by this name and the arguments (if any) specified by <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/>.</remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs">
            <summary>Gets or sets the arguments (if any) to pass to the service constructor.</summary>
            <remarks>
            <para>Unless <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> is specified, the members of this array (or lack thereof) must correspond in number, type, and ordering to a constructor exposed by the type specified in <see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/>.</para>
            <para>If <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> is specified, this property must be <see langword="null"/>.</para>
            </remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod">
            <summary>Gets or sets the name of the static factory method to be used for instantiation of the service.</summary>
            <remarks>
            <para>If this is not <see langword="null"/>, then it must correspond to the name of a static method exposed by the type specified in <see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/>. The method to be invoked will be determined by this name and the arguments (if any) specified by <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/>.</para>
            <para>If this property is specified, this <see cref="P:Hca.Common.Service.ServiceConfig.ServiceTypeArgs"/> must be <see langword="null"/>.</para>
            </remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs">
            <summary>Gets or sets the arguments (if any) to pass to the factory method.</summary>
            <remarks>
            <para>If <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> is specified, the members of this array (or lack thereof) must correspond in number, type, and ordering to a static method with the name specified by <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> exposed by the type specified in <see cref="P:Hca.Common.Service.ServiceConfig.ServiceType"/>.</para>
            <para>It is an error to specify <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethodArgs"/> if <see cref="P:Hca.Common.Service.ServiceConfig.ServiceCreationMethod"/> is <see langword="null"/>.</para>
            </remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.InterceptorStackContext">
            <summary>Gets or sets the configuration context of an <see cref="T:Hca.Common.Service.InterceptorStackConfig"/> defining the interceptor stack to use for this service.</summary>
            <remarks>If <see cref="P:Hca.Common.Service.ServiceConfig.UseDefaultInterceptorStack"/> is <see langword="true"/>, then this stack will be appended to the default stack. Otherwise, this stack is used alone.</remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.UseDefaultInterceptorStack">
            <summary>Gets or sets whether to use the default interceptor stack. The default is <see langword="true"/>.</summary>
            <remarks>See <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Net.NetworkCredential)"/> for details on the default interceptor stack.</remarks>
        </member>
        <member name="P:Hca.Common.Service.ServiceConfig.NetworkCredential">
            <summary>Gets or sets the credentials to use for impersonation when invoking methods on this service.</summary>
            <remarks>
            <para>Returns <see langword="null"/> if all properties are <see langword="null"/> or <see cref="F:System.String.Empty"/>.</para>
            <para>This property is passed to <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Net.NetworkCredential)"/>; therefore, it is an error to specify <see cref="P:Hca.Common.Service.ServiceConfig.NetworkCredential"/> if <see cref="P:Hca.Common.Service.ServiceConfig.UseDefaultInterceptorStack"/> is <see langword="false"/>.</para>
            </remarks>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown by getter if any property is not <see langword="null"/>, but <see cref="P:System.Net.NetworkCredential.Domain"/> or <see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:Hca.Common.Service.ServiceCreationException">
            <summary>
            Thrown when there is a problem creating a service.
            </summary>
            <seealso cref="T:Hca.Common.BaseException.HcaSystemException"/>
            <threadsafety static="true" instance="false"/> 
        </member>
        <member name="M:Hca.Common.Service.ServiceCreationException.#ctor">
            <overloads>Initializes a new instance of <see cref="T:Hca.Common.Service.ServiceCreationException"/>.</overloads>
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Hca.Common.Service.ServiceCreationException.#ctor(System.Exception)">
            <summary>
            Constructor that takes the cause of the exception
            </summary>
            <param name="cause">The reason for this exception</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceCreationException.#ctor(Hca.Common.Resource.ResourceMessage)">
            <summary>
            Constructor that takes the message for the Exception
            </summary>
            <param name="msg">The message to display</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceCreationException.#ctor(Hca.Common.Resource.ResourceMessage,System.Exception)">
            <summary>
            Creates a new instance of the <see cref="T:Hca.Common.Service.ServiceCreationException"/> class
            </summary>
            <param name="msg">The message to display</param>
            <param name="cause">The reason for this exception</param>
        </member>
        <member name="M:Hca.Common.Service.ServiceCreationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used for deserialization of the exception <see cref="T:Hca.Common.Service.ServiceCreationException"/> class.
            </summary>
            <param name="info">Represents the SerializationInfo of the exception.</param>
            <param name="context">Represents the context information of the exception.</param>
        </member>
        <member name="T:Hca.Common.Service.ServiceHelper">
            <summary>
            Helper class for services.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            <p> A service is an interface that defines specific behavior that may be used 
            by other parts of the system or systems. It layers the system making it more
            manageable.</p>
            
            <p>The service helper provides support for creating and proxying services.
            A proxy is a class that is emitted to support the service's interfaces. 
            This emitted class is returned to the user to interact with. Upon method invocation
            of this class the passed in interceptor will be called.</p>
             
            <p>When a consumer invokes the interface-backed proxy, the proxy will call a 
            chained list of interceptors defined in the <see cref="T:Hca.Common.Service.InterceptorStack"/>. 
            Each <see cref="T:Hca.Common.IInterceptor"/> will have an opportunity to perform some work and
            then choose to proceed or not to proceed. If the interceptor proceeds 
            then the next interceptor has an opportunity to perform some work.
            This continues until an interceptor has chosen to stop the invocation call
            or the last interceptor is reached. The last interceptor
            proceed call will invoke the appropriate service method.</p>
            
            <p>Interceptors allow behavior to be aspected to services in a clean manner
            without adding code to the actual service implementation. 
            By default, <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/> is used which provides
            impersonation, timing, and logging behaviors. You can provide your own
            interceptor stack if the default does not meet your need.</p>
            
            <p>
            The helper is designed to provide a service proxy that allows common
            functionality to be reused across services. Typical usage for most applications
            is instantiate your service class and pass it to the <see cref="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object)"/> method.
            Component writers that want proxy services for their components may use this helper
            as well. They would provide a component factory class which would in turn 
            use this helper class.
            </p>
            
            <p>
            Note that all the interfaces the service class implements will be proxied.
            Therefore, it is best practice that the service class only implement
            service interfaces.
            </p>
            
            <seealso cref="T:Hca.Common.IInterceptor"/>
            <seealso cref="T:Hca.Common.Service.InterceptorStack"/>
            <seealso cref="T:Hca.Common.Utility.ProxyGenerator"/>
            </remarks>	
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.#ctor">
            <summary>
            Private constructor for static class
            </summary>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.CreateServiceAndProxy(Hca.Common.Service.ServiceConfig)">
            <overloads>Creates a proxied service object ready to be cast to any implemented interface.</overloads>
            
            <summary>Creates a proxied service object based on the provided <see cref="T:Hca.Common.Service.ServiceConfig"/>.</summary>
            <param name="serviceConfig">Defines the instantiation mechanism and proxy interceptors for the service object.</param>
            <exception cref="T:Hca.Common.Service.ServiceCreationException">Thrown if there is a problem creating the service object.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <returns>The requested service object proxy, or <see langword="null"/> if <paramref name="serviceConfig"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.CreateServiceAndProxy(System.String)">
            <summary>Creates a proxied service object based on the <see cref="T:Hca.Common.Service.ServiceConfig"/> in the specified context, throwing an exception if the configuration cannot be found.</summary>
            <param name="serviceConfigContext">The configuration context from which to retrieve a <see cref="T:Hca.Common.Service.ServiceConfig"/> defining the instantiation mechanism and proxy interceptors for the service object.</param>
            <exception cref="T:Hca.Common.Service.ServiceCreationException">Thrown if there is a problem creating the service object.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if there is a problem with the configuration.</exception>
            <returns>The requested service object proxy.</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.CreateServiceAndProxy(System.String,System.Boolean)">
            <summary>Creates a proxied service object based on the <see cref="T:Hca.Common.Service.ServiceConfig"/> in the specified context, optionally throwing an exception if the configuration cannot be found.</summary>
            <param name="serviceConfigContext">The configuration context from which to retrieve a <see cref="T:Hca.Common.Service.ServiceConfig"/> defining the instantiation mechanism and proxy interceptors for the service object.</param>
            <param name="isOptional">Whether to return <see langword="null"/> if there is no <see cref="T:Hca.Common.Service.ServiceConfig"/> in the specified context.</param>
            <exception cref="T:Hca.Common.Service.ServiceCreationException">Thrown if there is a problem creating the service object.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <exception cref="T:System.Configuration.ConfigurationException">Thrown if there is a problem with the configuration.</exception>
            <returns>The requested service object proxy, or <see langword="null"/> if <paramref name="isOptional"/> is <see langword="true"/> and no <see cref="T:Hca.Common.Service.ServiceConfig"/> is found in the context specified by <paramref name="serviceConfigContext"/>.</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object)">
            <overloads>Creates a proxy for the specified service object ready to be cast to any implemented interface.</overloads>
            
            <summary>Creates a proxy for the specified service object, attaching the default interceptor stack.</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,Hca.Common.IInterceptor)">
            <summary>Creates a proxy for the specified service object, attaching the specified interceptor and the default interceptor stack.</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="interceptor">The interceptor to push onto the default stack.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Net.NetworkCredential)">
            <summary>Creates a proxy for the specified service object, attaching the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Net.NetworkCredential"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.)</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Net.NetworkCredential,System.String)">
            <summary>Creates a proxy for the specified service object, attaching the specified configured interceptor stack and the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Net.NetworkCredential"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptorStackConfigContext">The configuration context of an <see cref="T:Hca.Common.Service.InterceptorStackConfig"/> defining an interceptor stack to push onto the default stack.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Net.NetworkCredential,System.String,System.Boolean)">
            <summary>Creates a proxy for the specified service object, attaching the specified configured interceptor stack and (optionally) the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Net.NetworkCredential"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptorStackConfigContext">The configuration context of an <see cref="T:Hca.Common.Service.InterceptorStackConfig"/> defining an interceptor stack to push onto the default stack.</param>
            <param name="useDefaultInterceptorStack">Whether to use the default interceptor stack underneath the stack specified by <paramref name="interceptorStackConfigContext"/>.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.
            If <paramref name="useDefaultInterceptorStack"/> is <see langword="false"/> and <paramref name="interceptorStackConfigContext"/> is <see langword="null"/>
            and <paramref name="serviceImplementation"/> is not <see langword="null"/> then the <paramref name="serviceImplementation"/>
            will be returned and not an object proxy.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if <paramref name="credential"/> is specified while <paramref name="useDefaultInterceptorStack"/> is <see langword="false"/>.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Net.NetworkCredential,Hca.Common.IInterceptor)">
            <summary>Creates a proxy for the specified service object, attaching the specified interceptor and the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Net.NetworkCredential"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptor">The interceptor to push onto the default stack.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Net.NetworkCredential,Hca.Common.IInterceptor,System.Boolean)">
            <summary>Creates a proxy for the specified service object, attaching the specified interceptor and (optionally) the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Net.NetworkCredential"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptor">The interceptor to push onto the default stack.</param>
            <param name="useDefaultInterceptorStack">Whether to use the default interceptor stack underneath <paramref name="interceptor"/>.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.
            If <paramref name="useDefaultInterceptorStack"/> is <see langword="false"/> and <paramref name="interceptor"/> is <see langword="null"/>
            and <paramref name="serviceImplementation"/> is not <see langword="null"/> then the <paramref name="serviceImplementation"/>
            will be returned and not an object proxy.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if <paramref name="credential"/> is specified while <paramref name="useDefaultInterceptorStack"/> is <see langword="false"/>.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Security.Principal.WindowsIdentity)">
            <summary>Creates a proxy for the specified service object, attaching the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Security.Principal.WindowsIdentity"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="identity">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.)</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Security.Principal.WindowsIdentity,Hca.Common.IInterceptor)">
            <summary>Creates a proxy for the specified service object, attaching the specified interceptor and the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Security.Principal.WindowsIdentity"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="identity">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptor">The interceptor to push onto the default stack.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.</returns>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.ProxyService(System.Object,System.Security.Principal.WindowsIdentity,Hca.Common.IInterceptor,System.Boolean)">
            <summary>Creates a proxy for the specified service object, attaching the specified interceptor and (optionally) the default interceptor stack with impersonation of the specified account (using a <see cref="T:System.Security.Principal.WindowsIdentity"/>).</summary>
            <param name="serviceImplementation">The service object to proxy.</param>
            <param name="identity">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.</param>		
            <param name="interceptor">The interceptor to push onto the default stack.</param>
            <param name="useDefaultInterceptorStack">Whether to use the default interceptor stack underneath <paramref name="interceptor"/>.</param>
            <returns>The service object proxy, or <see langword="null"/> if <paramref name="serviceImplementation"/> is <see langword="null"/>.
            If the <paramref name="serviceImplementation"/> is not <see langword="null"/> but the <paramref name="interceptor"/> is null
            then the <paramref name="serviceImplementation"/> will be returned instead of the object proxy.</returns>
            <exception cref="T:Hca.Common.BaseException.HcaArgumentException">Thrown if <paramref name="identity"/> is specified while <paramref name="useDefaultInterceptorStack"/> is <see langword="false"/>.</exception>
            <exception cref="T:Hca.Common.Service.ProxyServiceException">Thrown if there is a problem proxying the service object.</exception>
            <remarks>
            <para>For details on the default interceptor stack, see <see cref="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack"/>.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack">
            <overloads>Builds an interceptor stack that performs logging, timing, and (optionally) impersonation.</overloads>
            
            <summary>Builds an interceptor stack that performs logging and timing.</summary>
            <returns>An instance of <see cref="T:Hca.Common.Service.InterceptorStack"/> containing a <see cref="T:Hca.Common.Service.LoggingInterceptor"/> and a <see cref="T:Hca.Common.Service.TimingInterceptor"/>.</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Net.NetworkCredential)">
            <summary>Builds an interceptor stack that performs logging, timing, and impersonation (using a <see cref="T:System.Net.NetworkCredential"/>.</summary>
            <param name="credential">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.)</param>		
            <returns>An instance of <see cref="T:Hca.Common.Service.InterceptorStack"/> containing a <see cref="T:Hca.Common.Service.LoggingInterceptor"/>, a <see cref="T:Hca.Common.Service.TimingInterceptor"/>, and (if <paramref name="credential"/> is not <see langword="null"/>) an <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/>..</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.MakeDefaultInterceptorStack(System.Security.Principal.WindowsIdentity)">
            <summary>Builds an interceptor stack that performs logging, timing, and impersonation (using a <see cref="T:System.Security.Principal.WindowsIdentity"/>.</summary>
            <param name="identity">The account to impersonate. (If this is <see langword="null"/>, no impersonation interceptor is pushed.)</param>		
            <returns>An instance of <see cref="T:Hca.Common.Service.InterceptorStack"/> containing a <see cref="T:Hca.Common.Service.LoggingInterceptor"/>, a <see cref="T:Hca.Common.Service.TimingInterceptor"/>, and (if <paramref name="identity"/> is not <see langword="null"/>) an <see cref="T:Hca.Common.Service.ImpersonationInterceptor"/>..</returns>
        </member>
        <member name="M:Hca.Common.Service.ServiceHelper.CreateServiceImpl(Hca.Common.Service.ServiceConfig)">
            <summary>
            Create service by first checking to see if a static factory method was defined. If one wasn't defined,
            then check for a declared type and instantiate it. Otherwise return null.
            </summary>
            <exception cref="T:Hca.Common.Service.ServiceCreationException">Thrown if there is a problem creating the service.</exception>
        </member>
        <member name="T:Hca.Common.Service.TimingInterceptor">
            <summary>
            Interceptor that clocks the time of an invocation to INFO.
            </summary>
            <remarks>This interceptor should normally be placed on the stack
            after <see cref="T:Hca.Common.Service.LoggingInterceptor"/>. This allows elapsed time to
            be recorded for all interceptors and method invocation.</remarks>
            <threadsafety static="true" instance="true"/> 
        </member>
        <member name="M:Hca.Common.Service.TimingInterceptor.Intercept(Hca.Common.IInvocation,System.Object[])">
            <summary>
            Logs to info the time it takes for a service call to return in seconds.
            </summary>
            <param name="invocation">invocation</param>
            <param name="args">arguments for invocation</param>
            <returns>object create from invocation</returns>
        </member>
        <member name="T:Hca.Common.Utility.AssemblyLoadMonitor">
            <summary>Ensures that loading of HCA assemblies is reported correctly by .Net's <see cref="M:System.AppDomain.GetAssemblies"/> and <see cref="E:System.AppDomain.AssemblyLoad"/>.</summary>
            <remarks>
            <p>There is a bug in .Net 1.1 where an assembly from the GAC may not ever be reported as loaded in a given application domain if another application domain in the same process has already loaded it. This appears to be a side-effect of .Net's <see cref="F:System.LoaderOptimization.MultiDomainHost"/> assembly loading optimization which loads the JIT-compiled code of shared assemblies into a process-wide "shared domain".</p>
            <p>This class enables a work-around by tracing the static (i.e., compile-time) references of the assemblies that are reported loaded. Unfortunately, this does involve a performance hit as assemblies that may not yet (or ever) be dynamically referenced will be loaded simply by virtue of a static reference.</p>
            <p>To minimize this performance hit, this class's dependency loading has been limited to assemblies whose name begins with "HCA". This is sufficient to solve the HCA-typical problem occasioned by this bug - failure of <see cref="T:Hca.Common.Configuration.ConfigFactory"/> to load configuration files specified by <see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute"/>.</p>
            <note>If a referenced assembly cannot be loaded, the exception will be logged processing will continue.</note>
            </remarks>
            <example><code><![CDATA[
            ]]></code></example>\
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="M:Hca.Common.Utility.AssemblyLoadMonitor.WatchCurrentDomain">
            <summary>Starts monitoring the current application domain.</summary>
        </member>
        <member name="M:Hca.Common.Utility.AssemblyLoadMonitor.Watch(System.AppDomain)">
            <summary>Starts monitoring the specified application domain.</summary>
        </member>
        <member name="T:Hca.Common.Utility.ChainingComparer">
            <summary>Implements <see cref="T:System.Collections.IComparer"/> around one or more other implementations.</summary>
            <remarks>
            <para>Multiple inner comparers can be used to order values that would be considered equivalent to a single comparer. A typical exampled is sorting a grid, where rows that have equal values in the first column should be ordered by the values in the second column, and so forth.</para>
            <example>Please see <see cref="T:Hca.Common.Utility.PropertyComparer"/> for an example of using <see cref="T:Hca.Common.Utility.ChainingComparer"/>.</example>
            <seealso cref="T:System.Collections.IComparer"/>
            <seealso cref="T:System.Collections.Comparer"/>
            <seealso cref="T:System.Collections.CaseInsensitiveComparer"/>
            <seealso cref="T:Hca.Common.Utility.PropertyComparer"/>
            <seealso cref="T:Hca.Common.Utility.ReversibleComparer"/>
            <seealso cref="T:Hca.Common.Utility.ValueComparator"/>
            </remarks>
        </member>
        <member name="F:Hca.Common.Utility.ChainingComparer.innerComparers">
            <summary>Holds the other <see cref="T:System.Collections.IComparer"/> implementations that this instance will call.</summary>
        </member>
        <member name="M:Hca.Common.Utility.ChainingComparer.#ctor(System.Collections.IComparer[])">
            <summary>Initializes an instance.</summary>
            <param name="innerComparers">The other <see cref="T:System.Collections.IComparer"/> implementations that this instance will call.</param>
        </member>
        <member name="M:Hca.Common.Utility.ChainingComparer.Compare(System.Object,System.Object)">
            <summary>Compares two objects and returns a value indicating whether one is less than, equal to or greater than the other.</summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns><list type="table">
            <para>Less than zero if <paramref name="x"/> is less than <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Zero if <paramref name="x"/> equals <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Greater than zero if <paramref name="x"/> is greater than <paramref name="y"/>.</para>
            </list></returns>
            <remarks>This method works by calling through to the inner comparers passed to the <see cref="T:Hca.Common.Utility.ChainingComparer"/> constructor. They are invoked one at a time, in order, until a non-zero value is returned or all the comparers are exhausted.</remarks>
        </member>
        <member name="T:Hca.Common.Utility.DisposalHelper">
             <summary>A helper class for implementing <see cref="T:System.IDisposable"/> over multi-threaded classes.</summary>
             <threadsafety static="true" instance="true"/>
            	<remarks>
            	<para><b>Functional Requirements</b></para>
             <see cref="T:Hca.Common.Utility.DisposalHelper"/> abstracts the intricacies of 
             coordinating disposal of multi-threaded <see cref="T:System.IDisposable"/> implementations. 
             (See <see href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeserializationserializationinfoclasstopic.asp">MsNetIDisp</see>.)
            	
             <para><b>Tenets</b></para>
             <list type="bullet">
            		<item>
            		Classes that allocate unmanaged resources must implement 
            		<see cref="T:System.IDisposable"/>.
            		</item>
            		<item>
            		Classes that wrap usage of other <see cref="T:System.IDisposable"/> objects 
            		should implement <see cref="T:System.IDisposable"/>.
            		</item>
            		<item>
            		Classes that implement <see cref="T:System.IDisposable"/> should ensure instance 
            		thread-safety to guarantee the integrity of their resource allocations.
            		</item>
            		<item>
            		Multi-threaded <see cref="T:System.IDisposable"/> classes should use 
            		<see cref="T:Hca.Common.Utility.DisposalHelper"/>.
            		</item>
             </list>
             
             <para><b>Design</b></para>
             .NET defines the <see cref="T:System.IDisposable"/> interface for classes that must interact 
             with unmanaged resources. (See MsNetIDisp.) In brief, the interface specifies that the client 
             of a disposable object should call <see cref="M:System.IDisposable.Dispose"/> as soon as the object is no long needed. This signals 
             the object to release its resources. Consistent with this, the interface additionally 
             stipulates that once <see cref="M:System.IDisposable.Dispose"/> has been called, all methods (other than <see cref="M:System.IDisposable.Dispose"/>) 
             must throw <see cref="T:System.ObjectDisposedException"/>.
             <para/>
             Complexities arise when the implementing class must ensure safety in multi-threading scenarios. 
             Two new considerations immediately come into play:
             <list type="bullet">
             <item>
             	<see cref="M:System.IDisposable.Dispose"/> must block while any already-executing methods finish executing.
             </item>
             <item>
             	Once <see cref="M:System.IDisposable.Dispose"/> starts blocking, new calls to other methods should throw 
             	<see cref="T:System.ObjectDisposedException"/>.
             </item>
             </list>
             <para/>
             This class is designed to assist developers who are facing these issues. It allows a client 
             to acquire and release individual 'holds' (similar to a <c>Monitor</c> lock) for operations 
             that must complete before <see cref="M:System.IDisposable.Dispose"/> returns. It abstracts setting the 'disposed' flag 
             with a method (<see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>) that 
             immediately sets an internal flag, and then blocks for any holds. It also provides properties 
             for testing for existing holds, and for testing the disposed state.
             <para/>
             Microsoft's .NET documentation illustrates a baseline implementation of <see cref="T:System.IDisposable"/>. 
             (See <see href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeserializationserializationinfoclasstopic.asp">MsNetIDisp</see>.) 
             Their example is a single class which wraps both managed and unmanaged 
             scarce resources and implements <see cref="T:System.IDisposable"/> to handle release of those resources. 
             However, it does not address actual usage of those resources nor does it attempt to ensure 
             thread safety. Microsoft's example is reproduced below (sans comments).
             
             <para><b>Usage</b></para>
             Multi-threaded class that implements <see cref="T:System.IDisposable"/> (see MsNetIDisp) should 
             have a private field of type <see cref="T:Hca.Common.Utility.DisposalHelper"/>. When the containing 
             class is constructed, the helper must be instantiated with a string that will describe the object 
             if the helper must throw an <see cref="T:System.ObjectDisposedException"/>.
             <para/>
             Then, each code block (method or segment thereof) that could conflict with resource disposal 
             must be wrapped in a disposal hold. The hold is obtained through a call to the helper's 
             <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/> method, 
             and released by a call to <see cref="M:Hca.Common.Utility.DisposalHelper.ReleaseHold"/>. When the object's 
             <see cref="M:System.IDisposable.Dispose"/> method is called, it must in turn call the 
             helper's <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>. From then on, 
             subsequent calls to <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/> throw the appropriate 
             <see cref="T:System.ObjectDisposedException"/>. However, all existing hold blocks (and any additional 
             hold requests nested in those blocks) will be allowed to execute, and 
             <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/> is not returned until all holds have been released. 
             As a convenience, <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/> also 
             returns an indicator of whether it actually changed state or had been called previously. 
             In the latter case, cleanup has been handled elsewhere and should not be executed by the 
             calling thread.)
             <para/>
             This is a fairly simple usage pattern that is illustrated in the Examples section.
             
             <!-- 
             <para><b>Best Practices</b></para>
             
            	<para/><para/>
            	-->
             </remarks>
             <example>
             <hcaExample desc="Microsoft's IDisposable Example">
             <code>
             public class BaseResource: IDisposable
             {
             	private IntPtr handle;
             	private Component component;
             	private bool disposed = false;
             
             	public BaseResource()
             	{
             	}
             
             	public void Dispose()
             	{
             		Dispose(true);
             		GC.SuppressFinalize(this);
             	}
             
             	protected virtual void Dispose(bool disposing)
             	{
             		if(!this.disposed)
             		{
             			if(disposing)
             			{
             				component.Dispose();
             			}
             			CloseHandle(handle);
             			handle = IntPtr.Zero;
             		}
             		disposed = true;
             	}
             
             	~BaseResource()
             	{
             		Dispose(false);
             	}
             
             	public void DoSomething()
             	{
             		if(this.disposed)
             		{
             			throw new ObjectDisposedException();
             		}
             	}
             	//	...
             }
             	</code>
             </hcaExample>
             <para/>
             The following three examples illustrate three variations on Microsoft's example that begin 
             to ensure thread-safe disposal.
             <para/>
             <hcaExample desc="Implementing IDisposable to Release Managed (IDisposable) Members">
             	<code>
             public class BaseResource: IDisposable
             {
             	private Component component;
             	private DisposalHelper disposalHelper;
             
             	public BaseResource()
             	{
             		this.disposalHelper = new DisposalHelper("BaseResource");
             	}
             
             	public void Dispose()
             	{
             		Dispose(true);
             		GC.SuppressFinalize(this);
             	}
             
             	protected virtual void Dispose(bool disposing)
             	{
             		if (this.disposalHelper.MarkDisposed(Timeout.Infinite))
             		{
             			if(disposing)
             			{
             				component.Dispose();
             			}
             		}
             	}
             
             	public void DoSomething()
             	{
             		this.disposalHelper.AcquireHold();
             		try
             		{
             			//	...
             		}
             		finally
             		{
             			this.disposalHelper.ReleaseHold();
             		}
             	}
             	//	...
             }
            		</code>
             </hcaExample>
             <para/>
             <hcaExample desc="Implementing IDisposable to Release Unmanaged Members">
             	<code>
             public class BaseResource: IDisposable
             {
             	private IntPtr handle;
             	private DisposalHelper disposalHelper;
             
             	public BaseResource()
             	{
             		this.disposalHelper = new DisposalHelper("BaseResource");
             	}
             
             	public void Dispose()
             	{
             		Dispose(true);
             		GC.SuppressFinalize(this);
             	}
             
             	protected virtual void Dispose(bool disposing)
             	{
             		if (this.disposalHelper.MarkDisposed(Timeout.Infinite))
             		{
             			CloseHandle(handle);
             			handle = IntPtr.Zero;
             		}
             	}
             
             	~BaseResource()		
             	{
             		Dispose(false);
             	}
             
             	public void DoSomething()
             	{
             		this.disposalHelper.AcquireHold();
             		try
             		{
             			//	...
             		}
             		finally
             		{
             			this.disposalHelper.ReleaseHold();
             		}
             	}
             	//	...
             }
             	</code>
             </hcaExample>
             <para/>
             <hcaExample desc="Implementing IDisposable to Release Both Manage and Unmanaged Members">
             	<code>
             public class BaseResource: IDisposable
             {
             	private IntPtr handle;
             	private Component component;
             	private DisposalHelper disposalHelper;
             
             	public BaseResource()
             	{
             		this.disposalHelper = new DisposalHelper("BaseResource");
             	}
             
             	public void Dispose()
             	{
             		Dispose(true);
             		GC.SuppressFinalize(this);
             	}
             
             	protected virtual void Dispose(bool disposing)
             	{
             		if (this.disposalHelper.MarkDisposed(Timeout.Infinite))
             		{
             			if(disposing)
             			{
             				component.Dispose();
             			}
             			CloseHandle(handle);
             			handle = IntPtr.Zero;
             		}
             	}
             
             	~BaseResource()		
             	{
             		Dispose(false);
             	}
             
             	public void DoSomething()
             	{
             		this.disposalHelper.AcquireHold();
             		try
             		{
             			//	...
             		}
             		finally
             		{
             			this.disposalHelper.ReleaseHold();
             		}
             	}
             	//	...
             }
             		</code>
             </hcaExample> 
             <para/>
             <hcaExample desc="The following code illustrates a basic usage.">
             <code>
            using Hca.Common.Util;
            
            class Class1 : IDisposable
            {
            	private DisposalHelper disposalHelper;
            
            	public Class1 ()
            	{
            		this.disposalHelper = new DisposalHelper("aClass1");
            
            		//	Initialize access to resources ...
            	}
            
            	protected DisposalHelper DisposalHelper
            	{
            		get { return this.disposalHelper; }
            	}
            
            	public void DoWork ()
            	{
            		using (this.DisposalHelper.AcquireHoldHandle())
            		{
            			//	Do work with resources ...
            		}
            	}
            
            	public void Dispose ()
            	{
            		if (this.DisposalHelper.MarkDisposed(Timeout.Infinite))
            		{
            			this.Dispose(true);
            			GC.SuppressFinalize(this);
            		}
            	}
            
            	protected virtual void Dispose (bool disposing)
            	{
            		if (disposing)
            		{
            			//	Release managed resources ...
            		}
            
            		//	Release unmanaged resources ...
            	}
            
            	~Class1()      
            	{
            		this.Dispose(false);
            	}
            }
            
            class Class2 : Class1  // Inherits both IDisposable and DisposalHelper from Class1.
            {
            	public void DoOtherWork ()
            	{
            		using (this.DisposalHelper.AcquireHoldHandle())
            		{
            			//	Do work with resources ...
            		}
            	}
            
            	protected override void Dispose (bool disposing)
            	{
            		if (disposing)
            		{
            			//	Release managed resources ...
            		}
            
            		//	Release unmanaged resources ...
            		
            		base.Dispose(disposing);
            	}
            }
             </code>
             </hcaExample>
             <para/>
             <hcaExample desc="The following code exercises behavior.">
             <code>
            using System.Globalization;
            using System.Reflection;
            using System.Threading;
            using Hca.Common.Logger;
            using Hca.Common.Utility;
            
            class UnmanagedResourceAccessor : IDisposable
            {
            	private static readonly HcaLogger log = HcaLogger.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);
            
            	private DisposalHelper disposalHelper;
            
            	public UnmanagedResourceAccessor (string resourceName)
            	{
            		this.disposalHelper = new DisposalHelper(string.Format("UnmanagedResourceAccessor[{0}]", resourceName));
            
            		log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Initializing access to unmanaged resource.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            	}
            
            	public void AccessUnmanagedResource ()
            	{
            		log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Attempting access to unmanaged resource.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            
            		using (this.disposalHelper.AcquireHoldHandle())
            		{
            			log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Start accessing unmanaged resource.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            
            			Thread.Sleep(5000);  // Simulate five seconds of work.
            
            			log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Done accessing unmanaged resource.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            		}
            	}
            
            	public void Dispose ()
            	{
            		log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Dispose: Waiting for access to complete.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            
            		if (this.disposalHelper.MarkDisposed(Timeout.Infinite))
            		{
            			this.Dispose(true);
            			GC.SuppressFinalize(this);
            		}
            		else
            		{
            			log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Dispose: Unmanaged resource is already released.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            		}
            	}
            
            	protected virtual void Dispose (bool disposing)
            	{
            		log.Debug(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - Dispose: Releasing unmanaged resource.", DateTime.Now, AppDomain.GetCurrentThreadId()));
            
            		Thread.Sleep(2000);  // Simulate two seconds of cleanup.
            	}
            
            	~UnmanagedResourceAccessor ()
            	{
            		this.Dispose(false);
            	}
            }
            
            class Exercise
            {
            	private static readonly HcaLogger log = HcaLogger.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);
            
            	private static UnmanagedResourceAccessor subject;
            
            	public static void Main()
            	{
            		//	Initialize subject.
            		subject = new UnmanagedResourceAccessor("Main Exercise");
            
            		//	Simulate multi-threaded resource access.
            		for (int i = 0; i &lt; 5; i++)
            		{
            			new Thread(new ThreadStart(subject.AccessUnmanagedResource)).Start();
            			Thread.Sleep(1000);
            		}
            
            		//	Ask to dispose before access completes.
            		new Thread(new ThreadStart(subject.Dispose)).Start();
            		Thread.Sleep(1000);
            
            		//	Prove the object is marked marked disposed before dispose actually completes.
            		try
            		{
            			subject.AccessUnmanagedResource();
            			throw new ApplicationException("We should never get here.");
            		}
            		catch (ObjectDisposedException exc)
            		{
            			log.Error(String.Format(CultureInfo.InvariantCulture, "[{0} / x{1:X}] - {2}", DateTime.Now, AppDomain.GetCurrentThreadId(), exc.Message));
            		}
            
            		//	Throw in an extra call to dispose.
            		subject.Dispose();
            
            		//	Let the user read the output.
            		Console.WriteLine();
            		Console.WriteLine("Exercise complete. Press &lt;Enter&gt; to exit.");
            		Console.ReadLine();
            	}
            }
             </code>
             </hcaExample>
             <para>Executing this example produces the following output (with different times):</para>
             <code>
            2005-02-03 17:38:04,988 [4212] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:04 / x1074] - Initializing access to unmanaged resource.
            2005-02-03 17:38:05,003 [4304] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:05 / x10D0] - Attempting access to unmanaged resource.
            2005-02-03 17:38:05,066 [4304] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:05 / x10D0] - Start accessing unmanaged resource.
            2005-02-03 17:38:05,988 [4032] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:05 / xFC0] - Attempting access to unmanaged resource.
            2005-02-03 17:38:05,988 [4032] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:05 / xFC0] - Start accessing unmanaged resource.
            2005-02-03 17:38:06,988 [2440] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:06 / x988] - Attempting access to unmanaged resource.
            2005-02-03 17:38:06,988 [2440] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:06 / x988] - Start accessing unmanaged resource.
            2005-02-03 17:38:07,988 [2052] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:07 / x804] - Attempting access to unmanaged resource.
            2005-02-03 17:38:07,988 [2052] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:07 / x804] - Start accessing unmanaged resource.
            2005-02-03 17:38:08,988 [984] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:08 / x3D8] - Attempting access to unmanaged resource.
            2005-02-03 17:38:08,988 [984] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:08 / x3D8] - Start accessing unmanaged resource.
            2005-02-03 17:38:09,988 [2100] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:09 / x834] - Dispose: Waiting for access to complete.
            2005-02-03 17:38:10,066 [4304] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:10 / x10D0] - Done accessing unmanaged resource.
            2005-02-03 17:38:10,988 [4032] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:10 / xFC0] - Done accessing unmanaged resource.
            2005-02-03 17:38:10,988 [4212] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:10 / x1074] - Attempting access to unmanaged resource.
            2005-02-03 17:38:13,550 [2440] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x988] - Done accessing unmanaged resource.
            2005-02-03 17:38:13,550 [2052] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x804] - Done accessing unmanaged resource.
            2005-02-03 17:38:13,550 [4212] ERROR [Exercise] [] &lt;&gt; - [02/03/2005 17:38:13 / x1074] - Cannot access a disposed object named "UnmanagedResourceAccessor[Main Exercise]".
            Object name: "UnmanagedResourceAccessor[Main Exercise]".
            2005-02-03 17:38:13,550 [4212] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x1074] - Dispose: Waiting for access to complete.
            2005-02-03 17:38:13,988 [984] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x3D8] - Done accessing unmanaged resource.
            2005-02-03 17:38:13,988 [2100] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x834] - Dispose: Releasing unmanaged resource.
            2005-02-03 17:38:13,988 [4212] DEBUG [UnmanagedResourceAccessor] [] &lt;&gt; - [02/03/2005 17:38:13 / x1074] - Dispose: Unmanaged resource is already released.
            
            Exercise complete. Press &lt;Enter&gt; to exit.
             </code>
             <para>Note that the last few lines may appear out of order. This does not indicate failure in blocking, because the messages themselves are not synchronized.</para>
             </example>
             <seealso cref="T:System.IDisposable">IDisposable Interface</seealso>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.log">
            <summary>Logger for this class.</summary>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.clientName">
            <summary>Contains the name of the disposed object displayed if <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/> throws an <see cref="T:System.ObjectDisposedException"/>.</summary>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.clientIsDisposed">
            <summary>Indicates whether the client has called <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>.</summary>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.clientIsDisposedLock">
            <summary>Used to synchronize access to <see cref="F:Hca.Common.Utility.DisposalHelper.clientIsDisposed"/>.</summary>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.holdEnforcementLock">
            <summary>Used to block returns from <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/> while waiting for existing holds to be released.</summary>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.#ctor(System.String)">
            <summary>Constructs an instance of <see cref="T:Hca.Common.Utility.DisposalHelper"/>.</summary>
            <param name="clientName">The name of the client object. Used if <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/> throws an <see cref="T:System.ObjectDisposedException"/>.</param>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.AcquireHold">
            <summary>Acquires a hold on returns from <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>.</summary>
            <remarks>The acquired hold must be released by a corresponding call to <see cref="M:Hca.Common.Utility.DisposalHelper.ReleaseHold"/>.</remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if a call has already been made to <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/> (but only if this thread doesn't already have a hold).</exception>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.AcquireHoldHandle">
            <summary>Acquires a hold on returns from <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>.</summary>
            <returns>An <see cref="T:System.IDisposable"/> object whose <see cref="M:System.IDisposable.Dispose"/> method will release the acquired hold.</returns>
            <remarks>
            <para>The acquired hold must be released in of two ways:
            <list type="">
            <li>by a corresponding call to this <see cref="T:Hca.Common.Utility.DisposalHelper"/>'s <see cref="M:Hca.Common.Utility.DisposalHelper.ReleaseHold"/>, or</li>
            <li>by a call to the returned <see cref="T:System.IDisposable"/>'s <see cref="M:System.IDisposable.Dispose"/>.</li>
            </list></para>
            <para>Since disposal holds are thread-specific, <see cref="M:System.IDisposable.Dispose"/> will fail with an <see cref="T:System.InvalidOperationException"/> if it does not come from the same thread that called this method.</para>
            <para>Note that the returned object does not fully comply with the <see cref="T:System.IDisposable"/> contract. More than one call to <see cref="M:System.IDisposable.Dispose"/> will result in an <see cref="T:System.ObjectDisposedException"/>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if a call has already been made to <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/> (but only if this thread doesn't already have a hold).</exception>
            <example>
            The following example demonstrates the intended usage of this method:
            <code>
            public void DoSomething ()
            {
            	using (this.disposalHelper.AcquireHoldHandle())
            	{
            		//	Do something ...
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.ReleaseHold">
            <summary>Releases a hold acquired by a previous call to <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/>.</summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread does not have a hold.  </exception>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)">
            <summary>Moves the <see cref="T:Hca.Common.Utility.DisposalHelper"/> into the disposed state.</summary>
            <param name="millisecondsTimeout">How long (in milliseconds) to wait for existing holds to be released.</param>
            <returns>A boolean indicating whether this is the first call to <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>.</returns>
            <remarks>A call to this method first causes any successive calls to <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/> to throw an <see cref="T:System.ObjectDisposedException"/>. It then waits to return until all acquired holds (see <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/>) have been released (see <see cref="M:Hca.Common.Utility.DisposalHelper.ReleaseHold"/>).</remarks>
            <exception cref="T:System.ApplicationException">Thrown if <paramref name="millisecondsTimeout"/> expires before all holds are released.</exception>
        </member>
        <member name="P:Hca.Common.Utility.DisposalHelper.IsHeldByAnyThread">
            <summary>Gets a boolean indicating whether any thread has a hold.</summary>
        </member>
        <member name="P:Hca.Common.Utility.DisposalHelper.IsHeldByCurrentThread">
            <summary>Gets a boolean indicating whether the current thread has a hold.</summary>
        </member>
        <member name="P:Hca.Common.Utility.DisposalHelper.IsMarkedDisposed">
            <summary>Gets a boolean indicating whether the client has called <see cref="M:Hca.Common.Utility.DisposalHelper.MarkDisposed(System.Int32)"/>.</summary>
            <remarks>Unlike <see cref="M:Hca.Common.Utility.DisposalHelper.AcquireHold"/>, this property does not consider whether the calling thread still has a hold.</remarks>
        </member>
        <member name="T:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock">
            <summary>Defines a lock that enforces either shared or exclusive access.</summary>
            <remarks>This is like a <see cref="T:System.Threading.ReaderWriterLock"/> with more generic naming. It adds one new property (<see cref="P:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.IsSharedLockHeldByAnyThread"/>).</remarks>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.innerLock">
            <summary>Implements the hard part of this class' logic.</summary>
        </member>
        <member name="F:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.anyThreadSyncRoot">
            <summary>Used by <see cref="M:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.AcquireExclusiveLock(System.Int32)"/> to avoid interference from <see cref="P:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.IsSharedLockHeldByAnyThread"/>.</summary>
            <remarks>I'm using a <see cref="T:System.Threading.ReaderWriterLock"/> as a logical <see cref="T:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock"/> because I'm in <see cref="T:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.AcquireExclusiveLock(System.Int32)">
            <summary>Increments this thread's exclusive lock count, using an <see cref="T:System.Int32"/> value for the time-out.</summary>
            <param name="millisecondsTimeout">The time-out in milliseconds</param>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.ReleaseExclusiveLock">
            <summary>Decrements this thread's exclusive lock count.</summary>
            <exception cref="T:System.ApplicationException">The thread does not have the exclusive lock.</exception>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.AcquireSharedLock(System.Int32)">
            <summary>Increments this thread's shared lock count, using an <see cref="T:System.Int32"/> value for the time-out.</summary>
            <param name="millisecondsTimeout">The time-out in milliseconds</param>
        </member>
        <member name="M:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.ReleaseSharedLock">
            <summary>Decrements this thread's shared lock count.</summary>
            <exception cref="T:System.ApplicationException">The thread does not have a shared lock.</exception>
        </member>
        <member name="P:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.IsSharedLockHeldByCurrentThread">
            <summary>Gets a value indicating whether the current thread holds a shared lock.</summary>
        </member>
        <member name="P:Hca.Common.Utility.DisposalHelper.SharedExclusiveLock.IsSharedLockHeldByAnyThread">
            <summary>Gets a value indicating whether any thread holds a shared lock.</summary>
            <remarks>This method is potentially slow, since catching an exception is the only way to detect locks held by other threads.</remarks>
        </member>
        <member name="T:Hca.Common.Utility.ElapseTime">
            <summary>
            Used to mark one to many response times. The times are given in milliseconds.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            <para><b>Functional Requirements</b></para>
            <list type="bullet">
            	<item>Provide consistent, convenient method for measuring elapsed time.</item>
            	<item>Support single measurements as well as multiple measurements.</item>
            	<item>Report total elapsed time, current elapsed time, and average elapsed time.</item>
            	<item>Track time for a single machine.</item>
            </list>
            
            <para><b>Tenets</b></para>
            <see cref="T:Hca.Common.Utility.ElapseTime"/> should not use to track time across 
            multiple machines.
            
            <para><b>Design</b></para>
            This class provides a convenient method for time measurement. There are many uses for this 
            class. Some obvious examples are code profiling, instrumentation for runtime performance, 
            and time measurement in general for time sensitive operations. 
            <para/>
            In addition to providing a single time measurement, <see cref="T:Hca.Common.Utility.ElapseTime"/> 
            can provide the total elapsed time and the average elapsed time over a series of samples. In 
            addition, you can get the series of data points used to determine elapsed time.
            
            <para><b>Usage</b></para>
            This class is used to mark one to many response times. This class can also be used to mark just a begin/end time or used to mark 
            a begin and a moving end times. A key is used to distinguish between other entries.
            
            <!--
            <para><b>Best Practices</b></para>
            
            <para/><para/>
            -->
            
            </remarks>
            <example>
            <hcaExample desc="ElapseTime example">
            <code>
            ElapseTime.MarkTime("test", true);
            System.Threading.Thread.Sleep(500);
            ElapseTime.MarkTime("test");
            System.Threading.Thread.Sleep(500);
            ElapseTime.MarkTime("test");
            System.Threading.Thread.Sleep(500);
            ElapseTime.MarkTime("test");
            ElapseTime.GetResponseTime("test").TotalElapsedTime
            </code>
            </hcaExample>
            <para/>
            <hcaExample desc="Another ElapseTime example">
            <code>
            ElapseTime.MarkTime(key, true); //ensures a new response time
            ...some work
            ElapseTime.MarkTime(key); //increment response time
            ...more work
            ElapseTime.MarkTime(key); //increment response time
            
            log.Info(ElapseTime.GetResponseTime(key).TotalElapseTime);
            </code>
            </hcaExample>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.#ctor">
            <summary>
            Private constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.MarkTime(System.Object)">
            <overloads>Begins or ends a time measurement.</overloads>
            <summary>
            Begins or ends a time measurement with no explicit option to start the measurement.
            </summary>
            <remarks>
            If the response time has already been started, then a new data point will
            be created.
            </remarks>
            <param name="key">the key of the time measurement</param>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.MarkTime(System.Object,System.Boolean)">
            <summary>
            Begins or ends a time measurement with option to explicitly indicate starting the measurement.
            </summary>
            <remarks>
            A value of true will start a new response time.
            </remarks>
            <param name="key">the key of the time measurement</param>
            <param name="start">boolean value indicating whether to start the measurement</param>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.ClearAllTimes">
            <summary>
            Clears all times
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.ClearTime(System.Object)">
            <summary>
            Clears a specific time
            </summary>
            <param name="key">The key of the time to clear</param>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.RemoveTime(System.Object)">
            <summary>
            Returns the elapsed time and removes the time from the cache
            </summary>
            <param name="key">The key of the time to remove</param>
            <returns>The time measurement for the given key or -1 if the key is not found</returns>
        </member>
        <member name="M:Hca.Common.Utility.ElapseTime.GetResponseTime(System.Object)">
            <summary>
            Returns a clone of the elapsed time of the current measurement
            </summary>
            <param name="key">The key of the measurement to return</param>
            <returns>The response time object.</returns>
        </member>
        <member name="T:Hca.Common.Utility.HashCodeGenerator">
             <summary>
             This class provides a means to generate a hashcode for an object that is based on all fields of a class. 
             This is useful if the client of this class overrides <see cref="M:System.Object.Equals(System.Object)"/> to provide value semantics 
             equality and hence needs to provide the hashcode implementation that considers this. 
            	</summary>
            	<remarks>
            	<para><b>Functional Requirements</b></para>
             <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> class must derive a value-based hash code 
             from any given object.
            	
             <para><b>Tenets</b></para>
             This class must support <see cref="M:System.Object.GetHashCode"/> implementations that conform to 
             three of the four rules laid out by .NET:
             <list type="number">
             <item>
             	If two objects are equal (i.e., their <see cref="M:System.Object.Equals(System.Object)"/> methods 
             	return <see langword="true"/> when the other object is passed in as a parameter), 
             	they must have the same hash code.
             </item>
             <item>
             	The value returned by <see cref="M:System.Object.GetHashCode"/> cannot change, even if member 
             	variables change their value. This rule is only applicable for 
             	immutable value types. <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> does 
             	not support this rule.
             </item>
             <item>
             	The function must not have circular references or throw exceptions. 
             	<see cref="T:Hca.Common.Utility.HashCodeGenerator"/> does throw one exception. See 
             	the Design section below for details.
             </item>
             <item>
             	Objects that override <see cref="M:System.Object.Equals(System.Object)"/> must override <see cref="M:System.Object.GetHashCode"/>.
             </item>
             </list>
            	Of these rules, two is problematic and in fact all <see cref="T:System.ValueType">ValueTypes</see> within the .NET framework break. The 
            	problem is that for rule two to be enforced, the class must either be immutable or the hashcode must be based on 
            	a constant value that is unique for an instance (i.e. like the heap address of the object). Unfortunately, this is 
            	not very useful in many cases and more importantly breaks rule one if equals is defined in terms of value based 
            	comparison. The real reason for rule two was to deal with collections that used the hashcode of a value as its 
            	key into the collection. However, it is possible to deal with this situation by designing wrappers to the object 
            	to store such that the immutable nature can be maintained by the wrapper or using an immutable key to the object
            	value instead of the hashcode of the object. This puts additional burden in using hash based collections but this 
            	is better than the alternative of always returning a new type when an object has a mutable operation performed. 
            	Therefore, clients of this class should consider the usage of this class for generation of hashcodes and handle 
            	the resultant consequences.
              
             <para><b>Design</b></para>
             This class has a method, <see cref="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)"/>, which derives a value-based hash 
             code from any given object. It iterates through parent and child objects including arrays 
             and collections. In general, every value in the object will be factored into the returned 
             hash code.  However, there are two exceptions to this rule:
             <list type="bullet">
             	<item>
             		If an object in the graph has the <see cref="T:Hca.Common.AlwaysEquivalentAttribute"/> 
             		applied, then the object will be ignored for hash code purposes.
             	</item>
             	<item>
             		<see cref="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)"/> may call <see cref="M:Hca.Common.Utility.HashCodeGenerator.GetHashCode(System.Object)"/> 
             		on any object in the graph that does not implement <see cref="T:Hca.Common.IIdentifiable"/>. If an object implements 
             		<see cref="M:Hca.Common.Utility.HashCodeGenerator.GetHashCode(System.Object)"/> in terms of <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> without implementing 
             		<see cref="T:Hca.Common.IIdentifiable"/>, an infinite loop can result. 
             		<see cref="T:Hca.Common.Utility.HashCodeGenerator"/> detects this loop and throws a 
             		<see cref="T:System.ArgumentException"/>.
             	</item>
             </list>
            	<p>
            	This class uses the FNV1a algorithm for computing hash values. You can find more details on the algorithm at 
            	<see href="http://www.isthe.com/chongo/tech/comp/fnv/"/>.</p>
            	<p>
            	This class does handle aggregates (arrays and collection) and hence if you have an object that has object references 
            	or sequences, it will recurse into those objects and get the hashcode of their elements until only leaf 
            	nodes are reached.</p>
            	<p>
            	Cycles are detected in self referencing or cyclical relationships (such as common with bi-directional reln) and 
            	are not recursed (i.e, we satisfy rule three above).</p>
            	<p>
            	Parent classes are navigated until either at the top base class or a class is reached that is in the excluded 
            	packages list. If <see langword="null"/> is passed for the exclude list, this class automatically adds the <see cref="N:System"/> and 
            	<see cref="N:Microsoft"/> namespace since it is not typical that equality should be based on field values in a .NET base 
            	class. However, this is not to say that if the start class is a <see cref="N:System"/> type that its values would not be 
            	evaluated, only that its parents type would not be navigated.</p>
            	<p>
            	Since this class uses reflection, if byte code security is placed on a class and this class can't gain access 
            	to a member, that member is ignored (i.e., no exceptions are thrown to once again satisfy rule 3). 
            	Hence care should be taken when using this class in these cases especially if secured members are necessary 
            	to calculate a hashcode.</p>
             
             <para><b>Usage</b></para>
             This can be used to derive a value-base hash code from an object. <i>Value-based</i> means 
             that each member in the object's graph is taken into account in deriving the hash code. This class also has a method
             that will calculate a hash code using FNV1-a given a binary data array. <see cref="T:Hca.Common.Utility.HashCodeGenerator"/>
             also has a method <see cref="M:Hca.Common.Utility.HashCodeGenerator.GetHashCodeProvider"/> that can also be used in methods 
             that need a <see cref="T:System.Collections.IHashCodeProvider"/> instance.
             
             <h5>Configuration</h5>
             <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> class should have one or more limiting namespaces 
             specified, which indicate the top most parent class(es) to compare for an object. If no 
             limiting namespace is specified then <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> class compares 
             the object's parent, then the parent's parent, etc. By default, the <see cref="N:System"/> namespace 
             is excluded form traversal.
             <para/>
             This limiting namespace should be as specific as is needed to ensure a correct comparison. 
             A higher-level namespace will encompass all of its child namespaces as well. Any collection 
             of namespaces to exclude is in addition to the default <see cref="N:System"/> namespace.
             
             <para><b>Best Practices</b></para>
             Use the <see cref="M:Hca.Common.BaseType.ObjectBase.GetHashCode">ObjectBase.GetHashCode</see> method instead 
             of the <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> class when implementing classes that inherit 
             from <see cref="T:Hca.Common.BaseType.ObjectBase"/>. <see cref="T:Hca.Common.Utility.HashCodeGenerator"/>  
             can be used outside of <see cref="T:Hca.Common.BaseType.ObjectBase"/> where needed.
             </remarks>
             <example>
             <hcaExample desc="HashCodeGenerator">
             <code>
             class Foo : IIdentifiable 
             {
             	public override int GetHashCode () 
             	{
             		return HashCodeGenerator.CalculateHashCode(this); 
             	}
             }
             </code>
             </hcaExample>
             <para/>
            	To invoke the utility excluding the default <see cref="N:System"/> and <see cref="N:Microsoft"/> namespaces:
            	<code>
            int hash = HashCodeGenerator.CalculateHashcode(obj1);
            	</code>
            	To invoke the utility including all namespaces:
            	<code>
            int hash = HashCodeGenerator.CalculateHashcode(obj1, new string[0]);
            	</code>
            	To invoke the utility excluding the listed namespaces:
            	<code>
            int hash = HashCodeGenerator.CalculateHashcode(obj1, new string[]{"System","Microsoft","NHibernate"});
            	</code>
             </example>
             <threadsafety static="true" instance="true"/>
        </member>
        <member name="F:Hca.Common.Utility.HashCodeGenerator.FNV1_32_OFFSET">
            <summary>
            The offset value for 32 bit hashing. This would need to change if hashcode ever moves to 64 bits.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.HashCodeGenerator.log">
            <summary>
            Logger for this class
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.HashCodeGenerator.depth">
            <summary>
            This field provides the depth of recursion into determining
            the hashcode of an object.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.HashCodeGenerator.visited">
            <summary>
            This field provides the list of objects visited on the recursion of
            hashcode. It is used to break cycles that may exist in the 
            hashcode chain.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.HashCodeGenerator.instance">
            <summary>
            The single instance to return for the <see cref="M:Hca.Common.Utility.HashCodeGenerator.GetHashCodeProvider"/> method.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.GetHashCodeProvider">
            <summary>
            <p>
            Get the single <see cref="T:System.Collections.IHashCodeProvider"/> that is usable for passing into other methods where
            a <see cref="T:System.Collections.IHashCodeProvider"/> is needed.</p>
            </summary>
            <remarks>For example, the <see cref="T:System.Collections.Hashtable"/> class can be constructed with a <see cref="T:System.Collections.IHashCodeProvider"/>
            that defines how items added are hashed into the collection. This provider can be used when the 
            values need to be value based instead of reference based.</remarks>
            <returns><see cref="T:System.Collections.IHashCodeProvider"/></returns>
            <example>
            The Following example shows typical usage:
            <code>
            public class MyClass
            {
            	private Hashtable table;
            	
            	public MyClass()
            	{
            		// Use a value based provider in this hashtable instead of the <see cref="M:System.Object.GetHashCode"/>
            		// method.
            		table = new Hashtable(HashCodeGenerator.GetHashCodeProvider(), null);
            	}
            	...
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.GetHashCode(System.Object)">
            <summary>
            <see cref="M:System.Collections.IHashCodeProvider.GetHashCode(System.Object)"/>
            </summary>
            <param name="obj">The object for which to generate a hash code</param>
            <returns>The <see cref="T:System.Int32"/> hash value.</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.#ctor">
            <summary>
            Hide constructor so class is not instantiated.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)">
            <overloads>
            <summary>
            This method provides calculation of a hashcode by using all fields and properties of the passed class.
            </summary>
            <remarks>
            <p>
            Any member which is not accessible is not considered into the comparison. <see langword="Static"/> members are also not included 
            since their values would always be the same for all instances of a class and hence including them adds 
            unnecessary processing.</p>
            <p>
            This hash function does not ensure unique values but attempts to provide reasonable distribution of the 
            hash values. If <see langword="null"/> does not contribute to the hash value since its value is the same and hence the current
            hash at the point of evaluation is returned when <see langword="null"/> is encountered. If an exception occurs a hashcode of zero 
            is returned.</p>
            </remarks>
            </overloads>
            <summary>
            <p>
            This overload will exclude navigation into any Parent type that is within the <see cref="N:System"/> and <see cref="N:Microsoft"/>
            namespace. If you need to navigate into a parent of type <see cref="N:System"/>, use the <see langword="static"/> method that takes an explicit
            namespace list and provide an empty array and (NOT <see langword="null"/>).</p>
            </summary>
            <param name="obj">The object to compute a hashcode on</param>
            <returns>int, hashcode value or zero if <see langword="null"/> input or exception</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object,System.String[])">
            <summary>
            This overload will only navigate into parent types that are not within the excluded namespace list.
            </summary>
            <remarks>
            If <see langword="null"/> is passed for the <paramref name="namespaceExcludes"/> argument, <see cref="N:System"/> is included by default. If an empty array
            is passed, all namespaces are <em>included</em>. Otherwise, the namespaces listed are excluded as specified.
            </remarks>
            <param name="obj">The object to compute a hashcode on</param>
            <param name="namespaceExcludes">A string array of namespaces that should be excluded for evaluation.</param>
            <returns>int, hashcode value or zero if <see langword="null"/> input or exception</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.UInt32,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            This method is the actual impl for calculating the hash
            </summary>
            <param name="hash">The current hash value to this point</param>
            <param name="obj">The object to include next into the hash</param>
            <param name="namespaceExcludes">A string array of namespaces that should be excluded for evaluation.</param>
            <returns>a <see cref="T:System.UInt32"/> that has the hash value.</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashClass(System.UInt32,System.Type,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            This class breaks a class up into its parts and calculates a hash based on those parts.
            </summary>
            <param name="hash">The current hash value to this point</param>
            <param name="type">The <see cref="T:System.Type"/> of the object.</param>
            <param name="obj1">The object to hash.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="T:System.UInt32"/>, hashcode calculated</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.Fnv1aHashFunction(System.UInt32,System.Byte[])">
            <summary>
            Generalized implementation of the FNV1a Hash Algorithm as defined by Landon Curt Null 
            <see href="http://www.isthe.com/chongo/tech/comp/fnv/"/>.
            </summary>
            <remarks><p>When using this function, pass zero when you hash the first value. This will seed the has with a
            suitable prime to help ensure good random distribution. When hashing objects or structs, you must break
            down every item to a primitive type so that it can be converted to a representative byte array.</p>
            <p>The unsigned int that is returned should be cast to an int in the final return for use with hashing that
            requires an int.</p></remarks>
            <param name="hash">Zero, for first data value, else current hash.</param>
            <param name="data">The data to hash.</param>
            <returns>A reasonably random hash value of the given data.</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashParent(System.UInt32,System.Type,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            Calculates hashvalue up the Parent (inherited / base) class chain. If the namespace of the parent class is 
            listed in the excluded namespace list then the parent class is skipped.
            </summary>
            <param name="hash">The current hash value as calculated to this point</param>
            <param name="type">The <see cref="T:System.Type"/> of the object.</param>
            <param name="obj1">The object to calculate hash for.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="T:System.UInt32"/>, hashcode for this part</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashArray(System.UInt32@,System.Type,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            If type is an array, calculate the hashcode for that array.
            </summary>
            <param name="hashCode">The hashcode value to this point in the calculation.</param>
            <param name="type">The <see cref="T:System.Type"/> of the object.</param>
            <param name="obj1">The object to hash.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see langword="true"/> if this type was an array</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.CompareAlwaysTruePresent(System.Reflection.FieldInfo)">
            <summary>
            Checks an object to see if the <see cref="T:Hca.Common.AlwaysEquivalentAttribute"/> Attribute is present. If so
            it is not considered in hash since it was not considered in equality.
            </summary>
            <param name="fieldInfo">Field to check</param>
            <returns><see langword="true"/> if the attribute is present</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashIEnumerable(System.UInt32@,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            If a collection, calculate the hashcode of that collection.
            </summary>
            <param name="hashCode">The hash value to this point in the calculation</param>
            <param name="obj1">The object to hash.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see langword="true"/> if an <see cref="T:System.Collections.IEnumerable"/>.</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashBaseSystemType(System.UInt32@,System.Type,System.Object)">
            <summary>
            If a primitive, or a string, calculate hash code using hash function.  
            </summary>
            <param name="hashCode">The hash if a base system type, else zero</param>
            <param name="type">The <see cref="T:System.Type"/> of the object.</param>
            <param name="obj1">The object to hash.</param>
            <returns><see langword="true"/> if a base system type</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.HashFields(System.UInt32,System.Type,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            This method will process the fields of an instance of a class that is determined to be a composite type which
            does not fall into one of the special cases.
            </summary>
            <remarks>
            The hash value needs to be based off the state of the object and hence only fields need to be included since
            Properties are really only accessors or mutators and as such are based off the fields.
            </remarks>
            <param name="hashCode">the hash value to this point of calculation</param>
            <param name="type">The <see cref="T:System.Type"/> of the object.</param>
            <param name="obj1">The object to hash.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns>hashcode considering all fields</returns>
        </member>
        <member name="M:Hca.Common.Utility.HashCodeGenerator.NavigateParent(System.String,System.Collections.Specialized.StringCollection)">
            <summary>
            Helper method to determine whether to navigate to a parent package
            </summary>
            <param name="classNamespace">The namespace to lookup.</param>
            <param name="namespaceExcludeList">list of namespaces to exclude</param>
            <returns><see langword="true"/> is the namespace should be tested, <see langword="false"/> if not.</returns>
        </member>
        <member name="T:Hca.Common.Utility.InstanceIdentityGenerator">
            <summary>Generates a unique identity string for a given object.</summary>
        </member>
        <member name="F:Hca.Common.Utility.InstanceIdentityGenerator.inGetHashCode">
            <summary>Used to detect infinite loop entry if subject's <see cref="M:System.Object.GetHashCode"/> calls back to <see cref="M:Hca.Common.Utility.InstanceIdentityGenerator.GenerateInstanceIdentityString(System.Object,System.Type)"/>.</summary>
        </member>
        <member name="M:Hca.Common.Utility.InstanceIdentityGenerator.#ctor">
            <summary>Private constructor prevents instantiation.</summary>
        </member>
        <member name="M:Hca.Common.Utility.InstanceIdentityGenerator.GenerateInstanceIdentityString(System.Object,System.Type)">
            <summary>Generates a unique identity string for a given object and type.</summary>
            <remarks>
            If <see langword="null"/> is passed for the object instance, a constant value is returned (hash of empty string).
            If <see langword="null"/> is passed for <paramref name="instanceType"/>, the type of the instance is used.
            </remarks>
            <param name="instance">The object for which to generate an identity string.</param>
            <param name="instanceType">Allows callers to pass in the type, avoiding the (admittedly slight) hit of <see cref="M:System.Object.GetType"/>.</param>
            <returns>The behavior of this method depends on whether <paramref name="instance"/> implements <see cref="T:Hca.Common.IIdentifiable"/>. If it does, it returns a string combining <paramref name="instance"/>'s <see cref="P:System.Type.FullName">Type.FullName</see> with its <see cref="P:Hca.Common.IIdentifiable.InstanceIdentity"/>. If not, it returns a string combining <paramref name="instance"/>'s <see cref="P:System.Type.FullName">Type.FullName</see> with its <see cref="M:System.Object.GetHashCode"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s <see cref="M:System.Object.GetHashCode"/> recursively calls back into this method.</exception>
        </member>
        <member name="T:Hca.Common.Utility.NamespaceDoc">
            <summary>
            <h2 class="dtH2">Overview</h2>
            These classes implement methods that don't belong to any other framework category. 
            For further information, see each utility's class documentation.
            </summary>
        </member>
        <member name="T:Hca.Common.Utility.ObjectRegistry">
            <summary>
            Implements hash table of object references used to determine if we find a cycle while recursively 
            iterate through an object graph.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ObjectRegistry.Add(System.Object)">
            <summary>
            Adds an object to the list.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="value"/> is <see langword="null"/>.</exception>
            <param name="value">Target Object</param>
            <remarks>If <paramref name="value"/> is already in the registry, this method does nothing.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.ObjectRegistry.Remove(System.Object)">
            <summary>
            Removes an object from the list.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="value"/> is <see langword="null"/>.</exception>
            <param name="value">Target Object</param>
            <remarks>If <paramref name="value"/> is not in the registry, this method does nothing.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.ObjectRegistry.Contains(System.Object)">
            <summary>
            Determines if an object has been registered
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="value"/> is <see langword="null"/>.</exception>
            <param name="value">Target Object</param>
            <returns>bool</returns>
        </member>
        <member name="T:Hca.Common.Utility.PropertyComparer">
             <summary>Uses <see cref="T:Hca.Common.Utility.PropertyUtility"/> to implement <see cref="T:System.Collections.IComparer"/> over the value of a specified property on each object compared.</summary>
             <remarks>
            	<seealso cref="T:System.Collections.IComparer"/>
            	<seealso cref="T:System.Collections.Comparer"/>
            	<seealso cref="T:System.Collections.CaseInsensitiveComparer"/>
            	<seealso cref="T:Hca.Common.Utility.ChainingComparer"/>
            	<seealso cref="T:Hca.Common.Utility.ReversibleComparer"/>
            	<seealso cref="T:Hca.Common.Utility.ValueComparator"/>
             </remarks>
             <example>Following is an example using <see cref="T:Hca.Common.Utility.PropertyComparer"/> in conjunction with <see cref="T:Hca.Common.Utility.ChainingComparer"/> to sort an array of <see cref="T:Hca.Common.DataType.PersonName"/> by ascending last name then descending first name, ignoring letter case:<code><![CDATA[
            PersonName[] names = new PersonName[] {
            		new PersonName("James", null, "Monroe"),
            		new PersonName("Woodrow", null, "Wilson"),
            		new PersonName("James", null, "Madison") };
            IComparer nameComparer = new ChainingComparer(
            		new PropertyComparer(new CaseInsensitiveComparer(), "FirstName"),
            		new PropertyComparer(new CaseInsensitiveComparer(), true, "LastName") );
            Array.Sort(names, nameComparer);
             ]]></code></example>
        </member>
        <member name="T:Hca.Common.Utility.ReversibleComparer">
            <summary>Implements <see cref="T:System.Collections.IComparer"/> around another implementation, optionally reversing its ordering.</summary>
            <remarks>
            <seealso cref="T:System.Collections.IComparer"/>
            <seealso cref="T:System.Collections.Comparer"/>
            <seealso cref="T:System.Collections.CaseInsensitiveComparer"/>
            <seealso cref="T:Hca.Common.Utility.ChainingComparer"/>
            <seealso cref="T:Hca.Common.Utility.PropertyComparer"/>
            <seealso cref="T:Hca.Common.Utility.ValueComparator"/>
            </remarks>
        </member>
        <member name="F:Hca.Common.Utility.ReversibleComparer.reverse">
            <summary>Whether to reverse the ordering from the inner comparer.</summary>
        </member>
        <member name="M:Hca.Common.Utility.ReversibleComparer.#ctor(System.Collections.IComparer)">
            <overloads>Initializes an instance.</overloads>
            
            <summary>Initializes a reversing instance.</summary>
            <param name="innerComparer">The other <see cref="T:System.Collections.IComparer"/> implementation that this instance will call.</param>
        </member>
        <member name="M:Hca.Common.Utility.ReversibleComparer.#ctor(System.Collections.IComparer,System.Boolean)">
            <summary>Initializes an instance, optionally reversing.</summary>
            <param name="innerComparer">The other <see cref="T:System.Collections.IComparer"/> implementation that this instance will call.</param>
            <param name="reverse">Whether to reverse the ordering from <paramref name="innerComparer"/>.</param>
        </member>
        <member name="M:Hca.Common.Utility.ReversibleComparer.Compare(System.Object,System.Object)">
            <summary>Compares two objects and returns a value indicating whether one is less than, equal to or greater than the other.</summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns><list type="table">
            <para>Less than zero if <paramref name="x"/> is less than <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Zero if <paramref name="x"/> equals <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Greater than zero if <paramref name="x"/> is greater than <paramref name="y"/>.</para>
            </list></returns>
            <remarks>This method works by calling through to the inner comparer passed to the <see cref="T:Hca.Common.Utility.ReversibleComparer"/> constructor. The result is then multiplied by -1 if the constructor's reverse parameter was <b>true</b>.</remarks>
        </member>
        <member name="F:Hca.Common.Utility.PropertyComparer.DEFAULT_BINDING">
            <summary>The default value for <see cref="F:Hca.Common.Utility.PropertyComparer.bindingFlags"/>.</summary>
        </member>
        <member name="F:Hca.Common.Utility.PropertyComparer.propertyName">
            <summary>Holds the name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</summary>
        </member>
        <member name="F:Hca.Common.Utility.PropertyComparer.bindingFlags">
            <summary>Holds the flags to use to bind to the property.</summary>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.String)">
            <overloads>Initializes an instance.</overloads>
            
            <summary>Initializes an instance with the specified property name, <see cref="F:System.Reflection.BindingFlags.Public"/> and <see cref="F:System.Reflection.BindingFlags.Instance"/> binding flags, and a case-sensitive property <see cref="T:System.Collections.Comparer"/> using the thread's current culture.</summary>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.String,System.Reflection.BindingFlags)">
            <summary>Initializes an instance with the specified property name and binding flags, and a case-sensitive property <see cref="T:System.Collections.Comparer"/> using the thread's current culture.</summary>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
            <param name="bindingFlags">The flags to use to bind to the property.</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.Collections.IComparer,System.String)">
            <summary>Initializes an instance with the specified property name, <see cref="F:System.Reflection.BindingFlags.Public"/> and <see cref="F:System.Reflection.BindingFlags.Instance"/> binding flags, and a given property comparer.</summary>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
            <param name="valueComparer">The <see cref="T:System.Collections.IComparer"/> implementation to use for comparing property values.</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.Collections.IComparer,System.String,System.Reflection.BindingFlags)">
            <summary>Initializes an instance with the specified property name and binding flags, and a given property comparer.</summary>
            <param name="valueComparer">The <see cref="T:System.Collections.IComparer"/> implementation to use for comparing property values.</param>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
            <param name="bindingFlags">The flags to use to bind to the property.</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.Collections.IComparer,System.Boolean,System.String)">
            <summary>Initializes an instance with the specified property name, <see cref="F:System.Reflection.BindingFlags.Public"/> and <see cref="F:System.Reflection.BindingFlags.Instance"/> binding flags, and a given property comparer (optionally reversing its ordering).</summary>
            <param name="valueComparer">The <see cref="T:System.Collections.IComparer"/> implementation to use for comparing property values.</param>
            <param name="reverse">Whether to reverse the ordering from <paramref name="valueComparer"/>.</param>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.#ctor(System.Collections.IComparer,System.Boolean,System.String,System.Reflection.BindingFlags)">
            <summary>Initializes an instance with the specified property name and binding flags, and a given property comparer (optionally reversing its ordering).</summary>
            <param name="valueComparer">The <see cref="T:System.Collections.IComparer"/> implementation to use for comparing property values.</param>
            <param name="reverse">Whether to reverse the ordering from <paramref name="valueComparer"/>.</param>
            <param name="propertyName">The name of the property to compare - this may be simple to a complex name. (See <see cref="T:Hca.Common.Utility.PropertyUtility"/>.)</param>
            <param name="bindingFlags">The flags to use to bind to the property.</param>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.Compare(System.Object,System.Object)">
            <summary>Compares two objects and returns a value indicating whether one is less than, equal to or greater than the other.</summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns><list type="table">
            <para>Less than zero if <paramref name="x"/> is less than <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Zero if <paramref name="x"/> equals <paramref name="y"/>.</para>
            <para>-- OR --</para>
            <para>Greater than zero if <paramref name="x"/> is greater than <paramref name="y"/>.</para>
            </list></returns>
            <remarks>This method works by first calling <see cref="M:Hca.Common.Utility.PropertyUtility.GetProperty(System.Object,System.String)"/> on <paramref name="x"/> and <paramref name="y"/> (with the property name and binding flags specified when this instance was constructed), and then passing the results to the inner comparer. The result is then multiplied by -1 if the constructor's reverse parameter was <b>true</b>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.PropertyComparer.GetPropertyValue(System.Object)">
            <summary>Gets from a given object the value of the property specified when this instance was constructed.</summary>
            <param name="source">The object form which to get the property value.</param>
        </member>
        <member name="T:Hca.Common.Utility.PropertyUtility">
            <summary>
            Utility class for using reflection to facilitate generic property operations on objects.
            </summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para><b>Functional Requirements</b></para>
            <see cref="T:Hca.Common.Utility.PropertyUtility"/> provides convenient methods for 
            developers to work with object properties. It provides the ability to get, set, 
            and determine a property's read and write capabilities. It allows a set of 
            properties to be copied from a source object to a target object. For the getter 
            and setter methods, the property names may be specified in a nested dot notation 
            format that includes index properties. The setter method also provides 
            coercion capabilities.
            
            <para><b>Tenets</b></para>
            <see cref="T:Hca.Common.Utility.PropertyUtility"/> uses reflection to manipulate the 
            properties. It is important to take into account its performance impact if used 
            in time sensitive tasks.
            
            <para><b>Design</b></para>
            This is a powerful utility allowing the user to easily manipulate properties on an object 
            as well as copy properties between objects. The utility uses reflection to discover an 
            object's properties and traverse the property name. Coercion is handled by type converters 
            registered to types. This class allows exceptions to bubble up through its public methods without using the exception
            handler to properly log and wrap exceptions. This is because the <see cref="N:Hca.Common.Utility"/> namespace is further up
            the namespace hierarchy than <see cref="N:Hca.Common.BaseException"/> and thus cannot use it.
            
            <para><b>Usage</b></para>
            This utility is used to get or set a property, copy properties from one object to another, 
            and check a property to see if you can read or write to it. For the getter and setter methods, 
            you can pass in a property name that indicates a chain of properties where the last property 
            is the one you want to get or set. Within this chain you can also name index properties.
            <hcaNote>
            	When declaring an indexed property in getting or setting a property, <c>Item</c> should be 
            	used to indicate the indexed property on the object.
            </hcaNote>
            All property names provided to set or get properties may be in the form of simple or complex
            property name. Simple property names are just one property. Complex property names may indicate a list of properties
            that need to be traversed. For instance, the <c>propertyName</c> can be a in a 
            dot notation where each token maps to a property. This allows you to 
            specify nested properties. This is useful when you want to set or get a property without
            having to call multiple getters. The tokens can be expressed in the following format:
            <list type="bullet">
            	<item>simple - name</item>
            	<item>complex - name.name.name</item>
            	<item>indexed - name[index]</item>
            	<item>indexed - name[index, index]</item>
            	<item>combined - name.name[index].name</item>
            </list>
            By default, the binding flags used to determine the set of properties for an object are 
            based on its instance, public, and declared properties in the passed object. For all methods, you can pass in 
            your own set of binding flags to override the default.  The main purpose is to copy properties at the top level 
            not performing some deep copy or clone. See  <see cref="M:Hca.Common.Utility.SystemUtility.DeepCopy(System.Object)"/> for performing a deep clone.
            There is an overloaded property that allows the bindings to be explicitly declared. This means
            you can control how properties are discovered for manipulation. See <see cref="T:System.Reflection.BindingFlags"/>. 
            <para/>
            <para/>
            For the setter and copy methods, you can define how the methods should handle nulls. For 
            instance, should nulls from a source object property be copied to the target? Or, should 
            only null properties on the target be valued? In addition, for setter properties you can 
            indicate if you want coercion to take place. This is used when the property value passed 
            in is a string and you want it to be coerced to the appropriate type for the target property.
            <!--
            <para><b>Best Practices</b></para>
            
            <para/><para/>
            -->
            </remarks>
            <example>
            <hcaExample>
            <code>
            // readable/writable
            PropertyUtility.IsReadable(testClass, "ReadOnlyProperty");
            PropertyUtility.IsWritable(testClass, "ReadOnlyProperty");
            
            // property set
            PropertyUtility.SetProperty(testClass, "StringProperty", "This is a string 2.", PropertyUtility.NullHandling.ValueOnlyTargetNulls);
            PropertyUtility.SetProperty(testClass, "StringProperty", value, PropertyUtility.NullHandling.ExcludeSourceNulls);
            PropertyUtility.SetProperty(testClass, "TestClassProperty.FloatProperty", 125.0f);
            
            // coerce property set
            PropertyUtility.SetProperty(testClass, "TestClassProperty.FloatProperty", “125.0”, true);
            
            // index property get
            PropertyUtility.GetProperty(indexTestClass, "Item[1]"));
            PropertyUtility.GetProperty(testClass, "TestClassProperty.Artists.Item[1]");
            PropertyUtility.GetProperty(multiIndexTestClass, "Item[1, 1]");
            
            // index property set
            PropertyUtility.SetProperty(indexTestClass, "Item[1]", "fred");
            PropertyUtility.SetProperty(testClass, "TestClassProperty.Artists.Item[1]", "fred");
            
            // copy properties
            PropertyUtility.CopyProperties(testCopy2Class, testCopyClass);
            </code>
            </hcaExample>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.GetProperty(System.Object,System.String)">
            <overloads>Return the value for the property considering our support for dot notation formats.</overloads>
            <summary>
            Return the value for the specified property using the default binding flags.
            </summary>
            <param name="source">object to return property value</param>
            <param name="propertyName">property name - this may be simple to a complex name</param>
            <returns>the property's value</returns>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not readable</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.GetProperty(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>
            Return the value for the specified property using the specified binding flags.
            </summary>
            <param name="source">object to return property value</param>
            <param name="propertyName">property name - this may be simple to a complex name</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <returns>the property's value</returns>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not readable</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object)">
            <overloads>
            Set a named property on an object with a value. The method
            does not perform any data conversion except for what is allowed
            by the types.
            </overloads>
            <summary>
            Sets a specified property on an object to the specified value.
            </summary>
            <remarks>
            Normal <see langword="null"/> handling will be used.
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Sets a specified property on an object to the specified value while allowing the value to be coerced into the target property's type.
            </summary>
            <remarks>
            Normal <see langword="null"/> handling will be used.
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="coerce">Should the passed in value be coerced to the target property type?
            If <see langword="true"/>, then a type converter will be retrieved if defined and used to convert the value
            from string to appropriate type. If the value is not a string or type converter is not
            defined the setting will fail.</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            Sets a specified property on an object to the specified value using the passed <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/>.
            </summary>
            <remarks>
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Boolean)">
            <summary>
            Sets a specified property on an object to the specified value while allowing the passed value to be coerced into the 
            target property's type and using the passed <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/>.
            </summary>
            <remarks>
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param> 
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="coerce">Should the passed in value be coerced to the target property type?
            If <see langword="true"/>, then a type converter will be retrieved if defined and used to convert the value
            from string to appropriate type. If the value is not a string or type converter is not
            defined the setting will fail.</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags)">
            <summary>
            Set a specified property to the specified value using the passed <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and <see cref="T:System.Reflection.BindingFlags"/>.
            </summary>
            <remarks>
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetProperty(System.Object,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags,System.Boolean)">
            <summary>
            Set a specified property to the specified value using the passed <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and <see cref="T:System.Reflection.BindingFlags"/> 
            while allowing the passed value to be coerced into the target property's type.
            </summary>
            <remarks>
            </remarks>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <param name="coerce">Should the passed in value be coerced to the target property type?
            If <see langword="true"/>, then a type converter will be retrieved if defined and used to convert the value
            from string to appropriate type. If the value is not a string or type converter is not
            defined the setting will fail.</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object)">
            <overloads>
            <summary>
            Copy all properties from one object to another. The properties are not cloned but just referenced assigned.
            </summary>
            <remarks><para>The property names are considered simple only. Indexed properties are not copied. Only properties 
            with a getter to read and setter to write are copied.</para><para>Overloads that define formal parameters of 
            target type and source type allow a caller to specify the base type to use when searching for properties. 
            If <see langword="null"/>, the passed object's type is used. Otherwise the passed type is used to get properties. The <see cref="T:System.Type"/> is 
            needed when a class has a chain of one or more concrete parent classes and a virtual method uses this method 
            to copy properties at the current classes level and calls its parent to do the same. In this case if the target 
            and source types are used, the parents call will use that type instead of its type which means that the parent 
            properties will not be copied, only the most derived class' properties.</para></remarks>
            </overloads>
            <summary>
            This overload uses the target and source types and default <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and <see cref="T:System.Reflection.BindingFlags"/>.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type)">
            <summary>
            This overload uses default <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and <see cref="T:System.Reflection.BindingFlags"/>.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object,System.Reflection.BindingFlags)">
            <summary>
            This overload allows the binding flags to be specified while using the target and source types for
            copying properties.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <param name="propertyBinding">The flags to use to bind to the property for both target and source.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type,System.Reflection.BindingFlags)">
            <summary>
            This overload allows the binding flags to be specified.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="propertyBinding">The flags to use to bind to the property for both target and source.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows the <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> policy to be specified while using the target and source types
            for copying properties.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type,Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows the <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> policy to be specified.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags)">
            <summary>
            This overload allows both <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and Bindings to be specified while using the target and source types
            for copying properties.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property for both target and source.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags)">
            <summary>
            This overload allows both <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> and Bindings to be specified.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property for both target and source.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object,System.String[],System.String[])">
            <summary>
            This overload allows a list of include and exclude properties to be specified from the target object while using
            the target and source types for copying properties.
            </summary>
            <remarks>Properties from the target object (the one being copied to) will not include the update of any
            excluded properties and will only include those listed in the include list. If the exclude list is <see langword="null"/>, no
            properties are excluded. If the include list is <see langword="null"/>, all properties are included. If the include list is <see langword="null"/>
            and the exclude list has values, all properties are include except those in the exclude list.</remarks>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type,System.String[],System.String[])">
            <summary>
            This overload allows a list of include and exclude properties to be specified from the target object.
            </summary>
            <remarks>Properties from the target object (the one being copied to) will not include the update of any
            excluded properties and will only include those listed in the include list. If the exclude list is <see langword="null"/>, no
            properties are excluded. If the include list is <see langword="null"/>, all properties are included. If the include list is <see langword="null"/>
            and the exclude list has values, all properties are include except those in the exclude list.</remarks>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Object,System.String[],System.String[],Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows the <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> policy to be specified and the include, exclude properties from the
            target object while using the target and source types for copying properties.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="source">object to copy properties from</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Object,System.Type,System.String[],System.String[],Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows the <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/> policy to be specified and the include, exclude properties from the
            target object.
            </summary>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Reflection.BindingFlags,System.Object,System.Reflection.BindingFlags,System.String[],System.String[],Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows both target and source bindings to be specified, <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/>, and which properties to 
            include or exclude from the target object while using the target and source types to copy properties.
            </summary>
            <remarks>The property names are considered simple only.
            Indexed properties are not copied.
            Only properties with a getter to read and setter to write
            are copied.</remarks>
            <param name="target">object to copy properties to</param>
            <param name="targetPropertyBinding">The flags to use to bind to the property.</param>
            <param name="source">object to copy properties from</param>
            <param name="sourcePropertyBinding">The flags to use to bind to the property.</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.CopyProperties(System.Object,System.Type,System.Reflection.BindingFlags,System.Object,System.Type,System.Reflection.BindingFlags,System.String[],System.String[],Hca.Common.Utility.PropertyUtility.NullHandling)">
            <summary>
            This overload allows both target and source bindings to be specified, <see cref="T:Hca.Common.Utility.PropertyUtility.NullHandling"/>, and which properties to 
            include or exclude from the target object.
            </summary>
            <remarks>The property names are considered simple only.
            Indexed properties are not copied.
            Only properties with a getter to read and setter to write
            are copied.</remarks>
            <param name="target">object to copy properties to</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="targetPropertyBinding">The flags to use to bind to the property.</param>
            <param name="source">object to copy properties from</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to search for properties</param>
            <param name="sourcePropertyBinding">The flags to use to bind to the property.</param>
            <param name="includeProperties">A list of properties to include. If <see langword="null"/>, then
            it is assumed that all properties are included.</param>
            <param name="excludeProperties">A list of properties to exclude. If <see langword="null"/>, then
            it is assumed that no properties are excluded.</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or source are <see langword="null"/></exception>
            <returns>the number of properties copied</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsReadable(System.Object,System.String)">
            <overloads>
            Does the named property have a getter?
            </overloads>
            <summary>
            This overload uses the source object's type and default bindings to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="propertyName">simple or complex property name to check for readability</param>
            <returns><see langword="true"/> if the property is readable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsReadable(System.Object,System.Type,System.String)">
            <summary>
            This overload uses the passed <paramref name="sourceType"/> and default bindings to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to get the property..</param>
            <param name="propertyName">simple or complex property name to check for readability</param>
            <returns><see langword="true"/> if the property is readable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsReadable(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>
            This overload uses the source object's type and passed bindings to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="propertyName">simple or complex property name to check for readability</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <returns><see langword="true"/> if the property is readable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsReadable(System.Object,System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            This overload uses the passed <paramref name="sourceType"/> and bindings to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to get the property..</param>
            <param name="propertyName">simple or complex property name to check for readability</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <returns><see langword="true"/> if the property is readable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsWritable(System.Object,System.String,System.Reflection.BindingFlags)">
            <overloads>
            Does the named property have a setter?
            </overloads>
            <summary>
            This overload uses the source object's type to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="propertyName">simple or complex property name to check for writability</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <returns><see langword="true"/> if the property is writable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsWritable(System.Object,System.String)">
            <summary>
            This overload uses the source object's type and default bindings.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="propertyName">simple or complex property name to check for writability</param>
            <returns><see langword="true"/> if the property is writable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsWritable(System.Object,System.Type,System.String)">
            <summary>
            This overload uses the source object's type and passed bindings.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to get the property.</param>
            <param name="propertyName">simple or complex property name to check for writability</param>
            <returns><see langword="true"/> if the property is writable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.IsWritable(System.Object,System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            This overload uses the passed <paramref name="sourceType"/> to get the property.
            </summary>
            <param name="source">The object to inspect its property.</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use to get the property.</param>
            <param name="propertyName">simple or complex property name to check for writability</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <returns><see langword="true"/> if the property is writable</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.GetPropertyImpl(System.Object,System.Type,System.String,System.Reflection.BindingFlags,System.Reflection.PropertyInfo@,System.Object[]@)">
            <overloads>
            Returns the property object given a complex property name. If
            the name is only a simple string, then the returning object
            is the source.
            </overloads>
            <summary>
            This overload includes the <paramref name="sourceType"/>.
            </summary>
            <param name="source">source object to reflect on</param>
            <param name="sourceType">The <see cref="T:System.Type"/> to use for getting the property</param>
            <param name="propertyName">simple or complex name</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <param name="propertyInfo">property info</param> 
            <param name="propertyIndexes">property indexes if it is an indexed property</param>
            <returns>property object</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.GetPropertyImpl(System.Object,System.String,System.Reflection.BindingFlags,System.Reflection.PropertyInfo@,System.Object[]@)">
            <summary>
            This overload uses the sources type as the type to get the property from.
            </summary>
            <param name="source">source object to reflect on</param>
            <param name="propertyName">simple or complex name</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <param name="propertyInfo">property info</param> 
            <param name="propertyIndexes">property indexes if it is an indexed property</param>
            <returns>property object</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SplitToken(System.String,System.String@)">
            <summary>
            Split token into the property and its indexes.
            </summary>
            <param name="rawToken">raw token</param>
            <param name="indexToken">the indexes. <see langword="null"/> if none found.</param>
            <returns>Actual property</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.BuildIndexes(System.Reflection.PropertyInfo,System.String)">
            <summary>
            Build a set of indexes based on property info and an index string.
            The string needs to be in the form of string, string.
            </summary>
            <param name="propertyInfo">Property meta to build indexes from</param>
            <param name="indexStr">index string that might contain 1 to many indexes</param>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <returns>array of indexes</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetPropertyImpl(System.Object,System.Type,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags,System.Boolean,System.Boolean)">
            <overloads>
            Set a named property on an object with a value.
            </overloads>
            <summary>
            This overload uses the passed target type to get the property
            </summary>
            <param name="target">object with the property to set</param>
            <param name="targetType">The <see cref="T:System.Type"/> to use when getting or setting a property.</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <param name="coerce">Should the passed in value be coerced to the target property type?
            If <see langword="true"/>, then a type converter will be retrieved if defined and used to convert the value
            from string to appropriate type. If the value is not a string or type converter is not
            defined the setting will fail.</param>
            <param name="errorOnNotWritable">Should we throw an exception if property is not writable?</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="M:Hca.Common.Utility.PropertyUtility.SetPropertyImpl(System.Object,System.String,System.Object,Hca.Common.Utility.PropertyUtility.NullHandling,System.Reflection.BindingFlags,System.Boolean,System.Boolean)">
            <summary>
            This overload uses the target object's type for getting the property.
            </summary>
            <param name="target">object with the property to set</param>
            <param name="propertyName">simple or complex property name to set</param>
            <param name="value">value to set on property</param>
            <param name="nullDirective">How should we handle <see langword="null"/> on setting target. 
            The valid values are <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal"/> and <see cref="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls"/>.</param>
            <param name="propertyBinding">The flags to use to bind to the property.</param>
            <param name="coerce">Should the passed in value be coerced to the target property type?
            If <see langword="true"/>, then a type converter will be retrieved if defined and used to convert the value
            from string to appropriate type. If the value is not a string or type converter is not
            defined the setting will fail.</param>
            <param name="errorOnNotWritable">Should we throw an exception if property is not writable?</param>
            <exception cref="T:System.MissingMemberException">Thrown if <paramref name="propertyName"/> does not map to an actual property.</exception>
            <exception cref="T:System.MemberAccessException">Thrown if <paramref name="propertyName"/> is not writable</exception>
            <exception cref="T:System.NotSupportedException">thrown if there is not type converter for index parameter</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> or <paramref name="propertyName"/> are <see langword="null"/></exception>
            <returns><see langword="true"/> if value was set.</returns>
        </member>
        <member name="P:Hca.Common.Utility.PropertyUtility.DefaultBinding">
            <summary>
            Get the Default binding value which includes all public, instance, and declared members of a class.
            Hence inherited, private, and static members are not included.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.PropertyUtility.AllMemberBinding">
            <summary>
            Get the All Member binding value which includes all public and nonpublic, <see langword="static"/> and instance members inclusive 
            of inherited members.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.PropertyUtility.AllInstanceMemberBinding">
            <summary>
            Get the All Instance Member binding value which includes all public and nonpublic, instance members inclusive 
            of inherited members.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.PropertyUtility.CurrentClassAllMemberBinding">
            <summary>
            Get the Current Class All Member binding value which includes all public and nonpublic static and instance 
            members for the current class exclusive of inherited members.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.PropertyUtility.CurrentClassAllInstanceMemberBinding">
            <summary>
            Get the Current Class All Instance Member binding value which includes all public and nonpublic instance 
            members for the current class exclusive of inherited members.
            </summary>
        </member>
        <member name="T:Hca.Common.Utility.PropertyUtility.NullHandling">
            <summary>
            Enumeration for handling <see langword="null"/>
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.PropertyUtility.NullHandling.Normal">
            <summary>
            All of the source object's properties that intersect with the target will be copied.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.PropertyUtility.NullHandling.ExcludeSourceNulls">
            <summary>
            The source object should not copy over target properties if the source property value is <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.PropertyUtility.NullHandling.ValueOnlyTargetNulls">
            <summary>
            The target object should only have its properties that are <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Hca.Common.Utility.ProxyGenerator">
            <summary>Proxies calls to an object through an <see cref="T:Hca.Common.IInterceptor"/>.</summary>
            <remarks>The <see cref="N:Hca.Common.Service"/> namespace provides several classes expanding on proxy functionality.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.ProxyGenerator.#ctor">
            <summary>Private constructor prevents instantiation of static-only class.</summary>		
        </member>
        <member name="M:Hca.Common.Utility.ProxyGenerator.GenerateProxy(System.Object,Hca.Common.IInterceptor)">
            <summary>Generates a proxy for the supplied object. The interceptor, if provided, will be called when any interface is invoked.</summary>
            <param name="implementation">The object to proxy. Must implement one or more interfaces.</param>
            <param name="interceptor">Will be called for each method invoked on the proxy.</param>
            <returns>An object implementing the same interfaces exposed by <paramref name="implementation"/>.</returns>
            <remakrs>The interceptor's <see cref="M:Hca.Common.IInterceptor.Intercept(Hca.Common.IInvocation,System.Object[])"/> implementation will handle every method <see cref="T:Hca.Common.IInvocation"/> on the returned proxy object. It can call the intercepted invocation's <see cref="M:Hca.Common.IInvocation.Proceed(System.Object[])"/> to invoke the <paramref name="implementation"/> object as normal; alternatively, it can perform work itself and return, or it can throw an exception.</remakrs>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="implementation"/> or <paramref name="interceptor"/> is <see langword="null"/>, or if <paramref name="implementation"/> doesn't expose any interfaces.</exception>
        </member>
        <member name="T:Hca.Common.Utility.ResponseTime">
            <summary>
            Serializable class to wrap a response time.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.#ctor">
            <overloads>Create a new instance of <see cref="T:Hca.Common.Utility.ResponseTime"/>.</overloads>
            <summary>
            Create a new instance of <see cref="T:Hca.Common.Utility.ResponseTime"/> with UTC NOW time in milliseconds.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.#ctor(System.Int64)">
            <summary>
            Creates a new instance of response time with the specified begin value
            </summary>
            <param name="begin">Start time in milliseconds</param>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.MarkEnd(System.Int64)">
            <summary>
            Create a data point.
            </summary>
            <remarks>
            All new data points are considered end points.
            </remarks>
            <param name="end">End time in milliseconds</param>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.GetMarks">
            <summary>
            Returns the marks 
            </summary>
            <returns>array of times in milliseconds</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.ComputeAverageTime">
            <summary>
            Computes and returns the average time for the given key
            </summary>
            <returns>The average time in milliseconds of the specified key measurements.
            If there is only one data point, then a <see cref="T:System.InvalidOperationException"/> 
            will be thrown.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown when there are not enough data points
            to determine the average time.</exception>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.Clone">
            <summary>
            At this level just return the value created by object's <see cref="M:System.Object.MemberwiseClone"/> (shallow copy
            semantics). Note that the owner object is not cloned since it could lead
            to recursion looping. This is ok in the case where the clone is used as a 
            snapshot of the existing object for printing or viewing. However, if this 
            operation is being used to create a new instance, the owner should be reset 
            with the new parent created outside this operation so the correct 
            reference is valued.
            </summary>
            <remarks>
            If a shallow copy isn't appropriate for an object, then this method can be 
            overridden using the <see cref="T:System.ICloneable"/> interface.
            </remarks>
            <returns>The cloned object</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.Equals(System.Object)">
            <summary>
            Method to test equality of one object to another.  Equality
            tests should include all attributes that contribute to what 
            distinguishes one instance of an object to another. 
            </summary>
            <remarks>
            This method uses a compare utility that checks all fields for equality including
            fields in any parent class as long as that parent class is a user
            defined class and not a .Net Framework class (value semantics equality). 
            Further, any composite types are drilled into and checked for equality. 
            Derived classes SHOULD NOT override this method unless they have special 
            value semantics that a straight comparison would not handle. 
            <param name="value">The object to compare against</param>
            </remarks>
            <returns><see langword="true"/> if this object and the passed object have the same value</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.op_Equality(Hca.Common.Utility.ResponseTime,Hca.Common.Utility.ResponseTime)">
            <summary>Overrides the == operator</summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects have the same value.</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.op_Inequality(Hca.Common.Utility.ResponseTime,Hca.Common.Utility.ResponseTime)">
            <summary>Overrides the != operator</summary>
            <param name="value1">The first object to compare.</param>
            <param name="value2">The second object to compare.</param>
            <returns><see langword="true"/> if the two objects do not have the same value.</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.GetHashCode">
            <summary>
            Returns a HashCode that is derived from a recursive listing of all
            of this object's values.
            </summary>
            <remarks>
            This HashCode will be the same for any two objects that have exactly
            the same values.
            </remarks>
            <returns>The HashCode of the object's concatenated values.</returns>
        </member>
        <member name="M:Hca.Common.Utility.ResponseTime.ToString">
            <summary>
            This method provides a string view of all public properties.
            </summary>
            <remarks>
            This is convenient for debugging.
            </remarks>
            <returns>A string that is a fully recursive dump of the object's values.</returns>
        </member>
        <member name="P:Hca.Common.Utility.ResponseTime.MarkCount">
            <summary>
            Number of time data points
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.ResponseTime.Begin">
            <summary>
            Begin time. It is always the first point.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.ResponseTime.End">
            <summary>
            End time. It is always the last point.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.ResponseTime.TotalElapsedTime">
            <summary>
            The total elapse time for the last data point and the first.
            </summary>
        </member>
        <member name="P:Hca.Common.Utility.ResponseTime.ElapsedTime">
            <summary>
            The elapse time of the last two data points.
            </summary>
        </member>
        <member name="T:Hca.Common.Utility.SerializationUtility">
            <summary>Provides static methods for common serialization and deserialization tasks.</summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            <para><b>Functional Requirements</b></para>
            Provides convenient methods for developers to implement compatible changes 
            to pre-existing serializable classes. The <see cref="T:Hca.Common.Utility.SerializationUtility"/> class is intended to 
            provide <see langword="static"/> methods for tasks that recur commonly in serialization and deserialization scenarios.
            
            <para><b>Tenets</b></para>
            Provides convenient methods for developers who must implement compatible 
            changes to pre-existing serializable classes.
            
            <para><b>Design</b></para>
            <i>Compatible</i> changes to a class often include the addition of methods or fields. This 
            is considered compatible because pre-existing client code can ignore the new members as long 
            as the existing members and their semantics have not changed. This backward compatibility 
            becomes less simple, however, in the context of a serializable class that must reconstruct 
            serialized instances of older versions of the class. .NET's deserialization operations 
            (<see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)"/>, etc.) [MsNetSerialize] 
            assume that the lack of a requested member is an error state, and throw an exception. However, 
            if the member has been added to class since the object was serialized, the member's absence 
            from the serialized instance is not an error. Therefore, the exception must be caught and the 
            member assigned a default or placeholder value. <see cref="T:Hca.Common.Utility.SerializationUtility"/> 
            provides shortcuts for the developer who is implementing this workaround.
            <para/>
            At present, the missing-value-aware wrappers for <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)">SerializationInfo.GetValue</see> 
            and its variants are the only methods provided.
            
            <para><b>Usage</b></para>
            This utility adds a new serializable member to a class, to handle the case where the 
            revised class must deserialize an older instance in which the new member did not exist. 
            When the new member is requested from the old serialized instance, 
            <see cref="T:Hca.Common.Utility.SerializationUtility"/> can catch the exception thrown by 
            <see cref="T:System.Runtime.Serialization.SerializationInfo"/> [MsNetSerialize] and provide an 
            appropriate value for the missing member.
            <para/>
            For each of <see cref="T:System.Runtime.Serialization.SerializationInfo">SerializationInfo's</see> retrieval methods 
            (<c>GetValue</c> and its type-sensitive variants), <see cref="T:Hca.Common.Utility.SerializationUtility"/> 
            provides a set of overloaded wrapper methods. Three styles of overload are provided. 
            One simply passes the call directly to the SerializationInfo. 
            The other two overloads also pass the call through to <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, 
            but they can suppress the <i>member not found</i> exception – one by returning the type's 
            default value, and the other by returning a value supplied by the caller.
            
            <para><b>Best Practices</b></para>
            It is suggested that all deserialization operations use the <see cref="T:Hca.Common.Utility.SerializationUtility"/>, rather 
            than directly calling the <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)"/> methods. 
            Although this measure may be technically unnecessary in the initial incarnation of a 
            class' serialization implementation (most likely using the wrapper methods' first overload), 
            it is recommended for two reasons:
            <list type="bullet">
            	<item>
            		The reference to <see cref="T:Hca.Common.Utility.SerializationUtility"/> should remind future 
            		developers to handle new serialized members intelligently.
            	</item>
            	<item>It provides stylistic consistency across code areas.</item>
            </list>
            </remarks>
            <example>
            <hcaExample>
            <code>
            // MyClass – Original Release:
            public class MyClass : ObjectBase, ISerializable
            {
            	string field1; 
            	...
            	void ISerializable.GetObjectData( SerializationInfo info, StreamingContext context )
            	{
            		info.AddValue( "One", this.field1 );
            	}
            	...
            	protected MyClass( SerializationInfo info, StreamingContext context )
            	{
            		this.field1 = SerializationUtility.GetString( info, "One" );
            	}
            }
            
            // MyClass – Later Release:
            public class MyClass : ObjectBase, ISerializable
            {
            	string field1; 
            	string field2;
            	...
            	void ISerializable.GetObjectData( SerializationInfo info, StreamingContext context )
            	{
            		info.AddValue( "One", this.field1 );
            		info.AddValue( "Two", this.field2 );
            	}
            	...
            	protected MyClass( SerializationInfo info, StreamingContext context )
            	{
            		this.field1 = SerializationUtility.GetString( info, "One" );
            		this.field2 = SerializationUtility.GetString( info, "Two", "N/A" );
            	}
            }
            </code>
            </hcaExample>
            </example>	
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.#ctor">
            <summary>Private constructor prevents instantiation.</summary>		
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetBoolean(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Boolean"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Boolean"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no work around for the 
            not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Boolean"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Boolean"/> value with the supplied <paramref name="name"/> is not found</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetBoolean(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Boolean"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Boolean"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Boolean"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetByte(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Byte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Byte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options 
            for the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Byte"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Throw if a <see cref="T:System.Byte"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetByte(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Byte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Byte"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Byte"/> value with the supplied <paramref name="name"/> is not found and  <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Byte"/> value with the supplied 
            <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetByte(System.Runtime.Serialization.SerializationInfo,System.String,System.Byte)">
            <summary>Retrieves a <see cref="T:System.Byte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Byte"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Byte"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetChar(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Char"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Char"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for handling the 
            not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Char"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Char"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetChar(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Char"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Char"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Char"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns '\x0000'
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Char"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetChar(System.Runtime.Serialization.SerializationInfo,System.String,System.Char)">
            <summary>Retrieves a <see cref="T:System.Char"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Char"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Char"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDateTime(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.DateTime"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.DateTime"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options
            for handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.DateTime"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.DateTime"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDateTime(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.DateTime"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.DateTime"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.DateTime"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns <see cref="F:System.DateTime.MinValue">DateTime.MinValue</see>.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.DateTime"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDateTime(System.Runtime.Serialization.SerializationInfo,System.String,System.DateTime)">
            <summary>Retrieves a <see cref="T:System.DateTime"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.DateTime"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.DateTime"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDecimal(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Decimal"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Decimal"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Decimal"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Decimal"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDecimal(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Decimal"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Decimal"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Decimal"/> value with the supplied <paramref name="name"/> is not found and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Decimal"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDecimal(System.Runtime.Serialization.SerializationInfo,System.String,System.Decimal)">
            <summary>Retrieves a <see cref="T:System.Decimal"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Decimal"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Decimal"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDouble(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Double"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Double"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Double"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Double"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDouble(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Double"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Double"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Double"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Double"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetDouble(System.Runtime.Serialization.SerializationInfo,System.String,System.Double)">
            <summary>Retrieves a <see cref="T:System.Double"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Double"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Double"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt16(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Int16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Int16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Int16"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int16"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt16(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Int16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int16"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Int16"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int16"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt16(System.Runtime.Serialization.SerializationInfo,System.String,System.Int16)">
            <summary>Retrieves a <see cref="T:System.Int16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int16"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Int16"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt32(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Int32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Int32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Int32"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int32"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt32(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Int32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int32"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Int32"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int32"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt32(System.Runtime.Serialization.SerializationInfo,System.String,System.Int32)">
            <summary>Retrieves a <see cref="T:System.Int32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int32"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Int32"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt64(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Int64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Int64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Int64"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int64"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt64(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Int64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int64"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Int64"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Int64"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetInt64(System.Runtime.Serialization.SerializationInfo,System.String,System.Int64)">
            <summary>Retrieves a <see cref="T:System.Int64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Int64"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Int64"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSByte(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.SByte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.SByte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.SByte"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">If a <see cref="T:System.SByte"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSByte(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.SByte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.SByte"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.SByte"/> value with the supplied <paramref name="name"/> is not found and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">If a <see cref="T:System.SByte"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSByte(System.Runtime.Serialization.SerializationInfo,System.String,System.SByte)">
            <summary>Retrieves a <see cref="T:System.SByte"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.SByte"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.SByte"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSingle(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.Single"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.Single"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.Single"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Single"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSingle(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.Single"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Single"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.Single"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.Single"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetSingle(System.Runtime.Serialization.SerializationInfo,System.String,System.Single)">
            <summary>Retrieves a <see cref="T:System.Single"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.Single"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.Single"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetString(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.String"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.String"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.String"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.String"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetString(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.String"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.String"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.String"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns <see cref="F:System.String.Empty">String.Empty</see>.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.String"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetString(System.Runtime.Serialization.SerializationInfo,System.String,System.String)">
            <summary>Retrieves a <see cref="T:System.String"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.String"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.String"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt16(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.UInt16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.UInt16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.UInt16"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt16"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt16(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.UInt16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt16"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.UInt16"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt16"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt16(System.Runtime.Serialization.SerializationInfo,System.String,System.UInt16)">
            <summary>Retrieves a <see cref="T:System.UInt16"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt16"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.UInt16"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt32(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.UInt32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.UInt32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.UInt32"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt32"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt32(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.UInt32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt32"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.UInt32"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt32"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt32(System.Runtime.Serialization.SerializationInfo,System.String,System.UInt32)">
            <summary>Retrieves a <see cref="T:System.UInt32"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt32"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.UInt32"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt64(System.Runtime.Serialization.SerializationInfo,System.String)">
            <overloads>Retrieves a <see cref="T:System.UInt64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a <see cref="T:System.UInt64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <returns>The <see cref="T:System.UInt64"/> value associated with <paramref name="name"/>.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt64"/> value with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt64(System.Runtime.Serialization.SerializationInfo,System.String,System.Boolean)">
            <summary>Retrieves a <see cref="T:System.UInt64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, optionally working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="isOptional">Controls behavior if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt64"/> value associated with <paramref name="name"/>.</returns>
            <remarks>
            If a <see cref="T:System.UInt64"/> value with the supplied <paramref name="name"/> is not found, and the value of <paramref name="isOptional"/> is <see langword="true"/>, this method returns 0.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if a <see cref="T:System.UInt64"/> value with the supplied <paramref name="name"/> is not found and <paramref name="isOptional"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetUInt64(System.Runtime.Serialization.SerializationInfo,System.String,System.UInt64)">
            <summary>Retrieves a <see cref="T:System.UInt64"/> value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found.</param>
            <returns>The <see cref="T:System.UInt64"/> value associated with <paramref name="name"/>.</returns>
            <remarks>If a <see cref="T:System.UInt64"/> value with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Type)">
            <overloads>Retrieves a value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</overloads>
            <summary>Retrieves a value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with no options for 
            handling the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="type">The <see cref="T:System.Type"/> of the value to retrieve. If the stored value cannot be converted to this type, the system will throw an <see cref="T:System.InvalidCastException"/>.</param>
            <returns>The object of the specified type associated with <paramref name="name"/>.</returns>
            <remarks>
            If the data stored in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> is of the type requested (or one of its derived classes), that value is returned directly. Otherwise, <see cref="M:System.Runtime.Serialization.IFormatterConverter.Convert(System.Object,System.Type)">IFormatterConverter.Convert</see> is called to convert it to the appropriate type. Note: The value returned by the <see cref="M:Hca.Common.Utility.SerializationUtility.GetValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Type)"/> method can always be safely cast to the type specified in the type parameter.
            </remarks>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Thrown if an object of the specified type with the supplied <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SerializationUtility.GetValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Type,System.Object)">
            <summary>Retrieves a value from the supplied <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, working around the not found condition.</summary>
            <param name="info">The object from which to retrieve the value.</param>
            <param name="name">The name of the value to retrieve.</param>
            <param name="type">The <see cref="T:System.Type"/> of the value to retrieve. If the stored value cannot be converted to this type, the system will throw an <see cref="T:System.InvalidCastException"/>.</param>
            <param name="defaultValue">The value to return if <paramref name="name"/> is not found. If the supplied value's type is not assignable to <paramref name="type"/>, this method will throw an <see cref="T:System.InvalidCastException"/>.</param>
            <returns>The object of the specified type associated with <paramref name="name"/>.</returns>
            <remarks>
            <para>If an object of the specified type with the supplied <paramref name="name"/> is not found, this method returns <paramref name="defaultValue"/>.</para>
            <para>If the data stored in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> is of the type requested (or one of its derived classes), that value is returned directly. Otherwise, <see cref="M:System.Runtime.Serialization.IFormatterConverter.Convert(System.Object,System.Type)">IFormatterConverter.Convert</see> is called to convert it to the appropriate type. Note: The value returned by the <see cref="M:Hca.Common.Utility.SerializationUtility.GetValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Type)"/> method can always be safely cast to the type specified in the type parameter.</para>
            </remarks>
            <exception cref="T:System.InvalidCastException">The supplied <paramref name="defaultValue"/>'s type is not assignable to the supplied <paramref name="type"/>.</exception>
        </member>
        <member name="T:Hca.Common.Utility.StandardRegularExpression">
            <summary>
            An essentially <see langword="static"/> class that provides regular expressions
            for general use.
            </summary>
            <remarks>
            Unless otherwise specified, <see langword="null"/> will always return <see langword="false"/> for
            a valid check. Also note that no modification of the string is
            made before the check. Hence, if you have leading or trailing
            whitespace, it will fail the expression if whitespace is not
            allowed as valid characters.
            </remarks>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.#ctor">
            <summary>
            Hide Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidThreeFourId(System.String)">
            <summary>
            Returns <see langword="true"/> if the 3-4 is in a valid format
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            A 3-4 id is made of three letters followed by
            4 digits where the last 4 digits can't be all
            zeros and the first three letters don't include
            offensive words.
            </remarks>
            <param name="checkUid">The UID to check</param>
            <returns><see langword="true"/> if valid</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetThreePartOfId(System.String)">
            <summary>
            Returns the three part of the 34 id if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="threeFourId">A 34 id</param>
            <returns>the three part of the id or empty</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetFourPartOfId(System.String)">
            <summary>
            Returns the four part of the 34 id if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="threeFourId">A 34 id</param>
            <returns>the four part of the id or empty</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsFakeSsn(System.String)">
            <summary>
            Return <see langword="true"/> if the string passed in is a fake ssn.
            </summary>
            <remarks>
            A fake ssn is one that starts with three leading zeros.
            If <see langword="null"/> is passed, this will always return <see langword="false"/>.
            </remarks>
            <param name="checkSsn">the ssn to check</param>
            <returns><see langword="true"/> if fake</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidSsn(System.String)">
            <summary>
            Return <see langword="true"/> if the string is a valid ssn.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            Per Gov spec:
            http://www.socialsecurity.gov/employer/ssnweb.htm
            The following rule are used to determine an invalid ssn.
            <list type="bullet">
            	<item>
            		<description>Starts with an eight</description>
            	</item>
            	<item>
            		<description>Starts with a nine</description>
            	</item>
            	<item>
            		<description>Starts with three zeros</description>
            	</item>
            	<item>
            		<description>Starts with three sixes</description>
            	</item>
            	<item>
            		<description>All ones</description>
            	</item>
            	<item>
            		<description>All threes</description>
            	</item>
            	<item>
            		<description>Is a sequential number</description>
            	</item>
            	<item>
            		<description>Not all digits</description>
            	</item>
            </list>
            Each grouping may have zero or more space, tab or
            dash characters between them and still match. For example:
            <c>
            124 67 7890
            124-67-7890
            124    67    7890
            </c>
            would all match.
            </remarks>
            <param name="checkSsn">The ssn to check</param>
            <returns><see langword="true"/> if valid format ssn</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetAreaPartOfSsn(System.String)">
            <summary>
            Returns the Area part (first three numbers)of a ssn if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="ssn">An ssn</param>
            <returns>The Area part of the ssn or empty</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetGroupPartOfSsn(System.String)">
            <summary>
            Returns the group part (middle two numbers) if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="ssn">An ssn</param>
            <returns>The group part of ssn</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetSequencePartOfSsn(System.String)">
            <summary>
            Returns the sequence part (last four numbers) of an SSN if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="ssn">An ssn</param>
            <returns>The sequence part of ssn</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetSequencePartOfFakeSsn(System.String)">
            <summary>
            Returns the sequence part (last four numbers) of a Fake SSN.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="ssn">An ssn</param>
            <returns>The sequence part of ssn</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidUserLogin(System.String)">
            <summary>
            Returns <see langword="true"/> if passed a valid windows login.
            </summary>
            <remarks>
            Valid logins for windows can take the form
            <c>
            Domain\UserName
            Domain/UserName
            UserName@Domain
            Domain can include subdomain parts such as domain.sub.sub.
            </c>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            </remarks>
            <param name="login">The login string</param>
            <returns><see langword="true"/> if valid</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetDomainPartOfLogin(System.String)">
            <summary>
            Returns the domain part if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            This method handles both forms of specifying the domain
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidUserLogin(System.String)"/> for details.
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="login">A login</param>
            <returns>The domain part of the login</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetUserNamePartOfLogin(System.String)">
            <summary>
            Returns the user name part if valid.
            Otherwise <see cref="F:System.String.Empty">String.Empty</see> is returned.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, an <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            </remarks>
            <param name="login">A login</param>
            <returns>The user name part of the login</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidDomainName(System.String)">
            <summary>
            Returns <see langword="true"/> if passed a valid domain name.
            </summary>
            <remarks>
            Valid domains contain letters or numbers and period (for subdomains).
            For example
            <c>
            hca
            hca.net
            hca.test.net
            </c>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            </remarks>
            <param name="domain">The domain string</param>
            <returns><see langword="true"/> if valid</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidUserName(System.String)">
            <summary>
            Returns <see langword="true"/> if passed a valid user name.
            </summary>
            <remarks>
            Valid user names contain letters, numbers and underscore(though discouraged).
            For example
            <c>
            krb5156
            corpdbuser
            </c>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            </remarks>
            <param name="userName">The user name string</param>
            <returns><see langword="true"/> if valid</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)">
            <summary>
            Returns <see langword="true"/> if a valid phone number.
            </summary>
            <remarks>
            North American (USA, Canada, Caribbean Islands, and US territories) current format is of the form: 
            NXX NXX XXXX [Extension] (where N is 2-9 and X is 0-9) Within the area code certain combinations 
            are reserved or not usable for regular use this includes N11, N9X, 37X, and 96X. 
            This is subject to change especially for the N9X, 37X, and 96X restrictions. 
            New format would be: NXX(X) (X)NXX XXXX (where (X) is the added digit. 
            Note N restriction would evidentially be removed.) Note however, 
            this code does not check new format since it is not in use yet. 
            North American Standards referenced can be found at:
            		<a href="http://www.nanpa.com/">NANPA</a>
            <p>
            Groups must be separated by a space(s), a hyphen, or a period between them. 
            Extensions may be delimited by 'extension', 'extn', 'ext', 'ex', 'xtn', 'e', 'x', '-', '.', ',', 
            with an optional period or colon. Extensions are limited to 5 digits. 
            In researching phone number data in Active Directory it was discovered that the 
            greatest variation of formats are with extensions. 
            Often incorrect extensions are entered such as 'e...' to indicate no entry. 
            In these cases, the extension is ignored.
            </p>
            </remarks>
            <param name="phoneNumber">The phone number to check</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetAreaCodeOfNorthAmericanPhoneNumber(System.String)">
            <summary>
            Return the Area Code of the phone number or empty string
            if not valued.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the area code from</param>
            <returns>the Area Code or <see cref="F:System.String.Empty">String.Empty</see> if not valued.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetPrefixOfNorthAmericanPhoneNumber(System.String)">
            <summary>
            Return the Prefix of the phone number.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the prefix from</param>
            <returns>the Prefix or <see cref="F:System.String.Empty">String.Empty</see>.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetLocalNumberOfNorthAmericanPhoneNumber(System.String)">
            <summary>
            Return the Local Number of the phone number.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the local number from</param>
            <returns>the Local Number or <see cref="F:System.String.Empty">String.Empty</see> if <see langword="null"/> passed.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetExtensionOfNorthAmericanPhoneNumber(System.String)">
            <summary>
            Return the Extension of the phone number.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the extension from</param>
            <returns>the Extension value or <see cref="F:System.String.Empty">String.Empty</see>.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.StripOffExtensionOfNorthAmericanPhoneNumber(System.String)">
            <summary>
            Return the phone number without the extension.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the extension from</param>
            <returns>the phone number value without the extension or <see cref="F:System.String.Empty">String.Empty</see>.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)">
            <summary>
            Return <see langword="true"/> if number can be parsed as an international number.
            </summary>
            <remarks>
            International numbers must be parsed based on the number of distinguishable groups 
            in the value passed. All numbers must include the Country Code[CC] and the Subscriber number[SN]. 
            A subscriber number can further be broken into three parts: National Designation Code (NDC) (
            aka area code) Prefix (usually an exchange office or node point) (P) Local Number 
            (LN) Extension (always follows the LN and designated by an extension delimiter. 
            The following groupings are recognized [CC][SN] [CC][NDC][LN] [CC][NDC][P][LN] 
            The country code may have a + which is standard notation for international numbers. 
            The area code (NDC) can have surrounding parentheses but both must be specified or 
            the number is considered invalid. Groups must be separated by a space(s), a hyphen, 
            or a period between them. Extensions digits are limited to 5.
            
            The following groupings are recognized
            [CC][SN]
            [CC][NDC][LN]
            [CC][NDC][P][LN]
            
            The country code may have a + which is standard notation for 
            international numbers.
            The area code (NDC) can have surrounding parentheses but both must be specified or
            the number is considered invalid.
            <p>
            Extensions may be delimited by 'extension', 'extn', 'ext', 'ex', 'xtn', 'e', 'x', '-', '.', ',', 
            with an optional period or colon. Extensions are limited to 5 digits. In researching phone number 
            data in Active Directory it was discovered that the greatest variation of formats are with extensions. 
            Often incorrect extensions are entered such as 'e...' to indicate no entry. 
            In these cases, the extension is ignored.
            </p>
            </remarks>
            <example>
            The Following represent valid international numbers:
            <code>
            Form 1:
            +672 134578
            Form 2:
            +32 105-56457
            Form 3:
            +1 (205) 768-3456
            With Extension:
            +672 134578 ext. 123
            +32 105-56457 x 345
            +1 (205) 768-3456 ex: 78
            </code>
            </example>
            <param name="phoneNumber">the number to parse</param>
            <returns><see langword="true"/> if valid international number</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetCountryCodeOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the country code of an international phone number
            </summary>
            <param name="phoneNumber">The number to parse</param>
            <returns>The country code or <see cref="F:System.String.Empty">String.Empty</see> if invalid international number</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetAreaCodeOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the area code of an international phone number
            </summary>
            <remarks>
            This really gets the National destination code (NDC)of the subscriber number
            part of the phone number. Many countries call this the area code but it can
            also represent the city code or national prefix.
            Since an international number does not have to have an area code, this will
            return an <see cref="F:System.String.Empty">String.Empty</see> when not valued.
            </remarks>
            <param name="phoneNumber">The number to parse</param>
            <returns>The area code or <see cref="F:System.String.Empty">String.Empty</see> if invalid international number or area code not specified</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetPrefixOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the prefix of an international phone number
            </summary>
            <remarks>
            The prefix will only be returned if the number is composed such that it can be Recognized within the passed phone 
            number. Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/> for patterns that are Recognized.
            It is expected that this will return the <see cref="F:System.String.Empty">String.Empty</see> often since many countries do not distinguish prefixes 
            from the local number. 
            </remarks>
            <param name="phoneNumber">The number to parse</param>
            <returns>The prefix or <see cref="F:System.String.Empty">String.Empty</see> if invalid international number or prefix not specified</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetLocalNumberOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the Local Number of the phone number.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the local number from</param>
            <returns>the Local Number or <see cref="F:System.String.Empty">String.Empty</see> if <see langword="null"/> passed or invalid phone number.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.GetExtensionOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the Extension of the phone number.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidInternationalPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the extension from</param>
            <returns>the Extension value or <see cref="F:System.String.Empty">String.Empty</see> if phone number <see langword="null"/>, invalid or extension not specified.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.StripOffExtensionOfInternationalPhoneNumber(System.String)">
            <summary>
            Return the phone number without the extension.
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see cref="F:System.String.Empty">String.Empty</see> is always returned.
            Refer to <see cref="M:Hca.Common.Utility.StandardRegularExpression.IsValidNorthAmericanPhoneNumber(System.String)"/> for details
            on formatting rules.
            </remarks>
            <param name="phoneNumber">The number to get the extension from</param>
            <returns>the phone number value without the extension or <see cref="F:System.String.Empty">String.Empty</see>.</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidDepartmentNumber(System.String)">
            <summary>
            Returns <see langword="true"/> if passed number is a valid Department number
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            A valid department is a 3 position alphanumeric.
            </remarks>
            <param name="deptNumber">The dept number to check</param>
            <returns><see langword="true"/> if a dept number</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidWholeNumber(System.String)">
            <summary>
            Returns <see langword="true"/> if passed number is a whole number
            </summary>
            <remarks>
            If <see langword="null"/> is passed, <see langword="false"/> is always returned.
            </remarks>
            <param name="number">The number to check</param>
            <returns><see langword="true"/> if a whole number</returns>
        </member>
        <member name="M:Hca.Common.Utility.StandardRegularExpression.IsValidEmail(System.String)">
            <summary>
            Validate that an email address is in a valid format.
            </summary>
            <remarks>
            This method checks that the email is well formed based on RFC 2821.
            It checks for appropriate IP addresses include subnet masking and
            alternate forms such as prefixes which must be in quotes.
            If an empty string or <see langword="null"/> is passed, <see langword="false"/> is always returned.
            </remarks>
            <param name="checkEmailAddress">The email address to check</param>
            <returns><see langword="true"/> if the address is a valid email address</returns>
            <example>
            Normal usage is:
            <code>
            	bool ok = StandardRegularExpression.IsValidEmail("first.last@test.com");
            </code>
            Which would return <see langword="true"/>.
            Also this is valid
            <code>
            	bool ok = StandardRegularExpression.IsValidEmail("?.?.?????@test.com");
            </code>
            Checking with IPs
            <code>
            	bool ok = StandardRegularExpression.IsValidEmail("first.last@[69.170.150.140]");
            </code>
            But this is not valid according to RFC though some email programs
            allow.
            <code>
             bool ok = StandardRegularExpression.IsValidEmail("first.last@69.170.150.140");
            </code>
            This is also valid but probably never used...
            <code>
            	bool ok = StandardRegularExpression.IsValidEmail("~~~~~~~~~~~~@test.com");
            </code>
            </example>
        </member>
        <member name="T:Hca.Common.Utility.StringUtility">
            <summary>An internal utility for working with strings.</summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.Utility.StringUtility.#ctor">
            <summary>Private constructor prevents instantiation.</summary>		
        </member>
        <member name="M:Hca.Common.Utility.StringUtility.NullOrTrimString(System.String)">
            <summary>This utility method will return the passed argument as a trimmed string if it has a value (i.e. not <see langword="null"/> and not an empty string). Otherwise, it returns <see langword="null"/>.</summary>
            <param name="input">The string to process.</param>
            <returns>Either a trimmed string with Length > 0, or <see langword="null"/>.</returns>
        </member>
        <member name="T:Hca.Common.Utility.SystemUtility">
            <summary>
            This class provides methods that are common to all systems and
            don't fall into any existing category.
            </summary>
            <remarks>
            <para><b>Functional Requirements</b></para>
            <see cref="T:Hca.Common.Utility.SystemUtility"/> class must contain methods that are 
            complementary to .NET system level methods. These are methods that you need but 
            the core API did not provide this functionality.
            
            <para><b>Tenets</b></para>
            For <see cref="M:Hca.Common.Utility.SystemUtility.DeepCopy(System.Object)"/>, any object that is copied must be serializable.
            <see cref="M:Hca.Common.Utility.SystemUtility.NullOrTrimString(System.String)"/> should be used to check most string input parameters 
            so users do not have to worry about trimming their input. It also provides a 
            consistent way to check to see if the string was provided. We recommend that 
            <see langword="null"/> rather than empty strings are passed back. This ensures that the return 
            string is trimmed and not empty.
            
            <para><b>Design</b></para>
            This class provides helper methods that complement .NET's <see cref="N:System"/> namespace.  It has one 
            method that performs a deep copy and one that cleans a string so that any null value is 
            converted to any empty string.
            <para/>
            The deep copy method serializes that object and deserializes it into a new object.
            
            <para><b>Usage</b></para>
            This class provides methods that are common to all systems and don't fall into any 
            particular category.
            
            <!--
            <para><b>Best Practices</b></para>
            
            <para/><para/>
            -->
            </remarks>
            <example>
            <hcaExample desc="SystemUtility">
            <code>
            MyDataType data1 = new MyDataType();
            . . . // set properties on data1
            MyDataType data2 = (MyDataType)SystemUtility.DeepCopy(data1);
            </code>
            </hcaExample>
            </example>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.#ctor">
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.DeepCopy(System.Object)">
            <summary>
            Makes a replica of the passed object that replicates all members of the 
            object recursively. 
            </summary>
            <remarks>
            <p>
            This replica should be semantically meaningful 
            (i.e., the new instance should be in a valid state given it's a new 
            object.)
            This method Serializes the object and Deserializes it into a new object.
            Therefore, this method will only work on an object the is marked with
            the [Serializable] attribute.
            </p>
            The Serialization functionality can be overridden by an object
            using the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface.
            </remarks>
            <example>
            <code>
            		public class MyClass : ObjectBase, ISerializable{
            			...
            			void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){
            				info.AddValue( "One", this.field1 );
            				info.AddValue( "Two", this.field2 );
            			}
            			// This constructor is used to rebuild the object when Deserialized
            			protected MyClass( SerializationInfo info, StreamingContext context)
            			{
            				this.field1 = info.GetString("One");
            				this.field2 = info.GetString("Two");
            			}
            		}
            </code>
            </example>
            <param name="source">The object to replicate from</param>
            <returns>a complete copy of the object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Will be thrown if the object is not marked serializable.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.NullOrTrimString(System.String)">
            <summary>
            This utility method will return the passed argument as a trimmed
            string if it has a value (i.e. not <see langword="null"/> and not an empty string).
            Otherwise, it returns <see langword="null"/>.
            </summary>
            <param name="value">The string to process</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetCurrentDomainAssemblies">
            <summary>
            Gathers all the domain assemblies and returns an
            array of strings displaying the assembly full name
            and where it is located (GAC or local).
            </summary>
            <remarks>
            This output might be used on a diagnostic page showing
            all assemblies, their version, and where they are loading from.
            By default, the logger outputs this information as well when it 
            is first called.
            <p/>
            You might also have a console application that talks to the app
            and calls this method to output its assemblies.
            <p/>
            Typical output would look like the following:
            <code>
            Assembly 'log4net, Version=1.2.0.30714, Culture=neutral, PublicKeyToken=b32731d11ce58905' from  'GAC'
            Assembly 'mscorlib, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' from 'c:\winnt\microsoft.net\framework\v1.1.4322\mscorlib.dll'
            </code>
            </remarks>
            <returns>An array of strings</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object,System.Type,System.Object)">
            <overloads>
            <summary>
            This method returns <see cref="T:System.Reflection.FieldInfo"/> for fields in a passed instance.
            </summary>
            <remarks>
            <para>
            Since the <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object,System.Type,System.Object)"/> method in <see cref="T:System.Type"/> does not recurse the parent inheritance chain for non-public fields 
            (even when the <see cref="T:System.Reflection.BindingFlags"/> indicate to do so), this method provides that capability and hence is a 
            replacement for the <see cref="M:System.Type.GetFields"/> method. However, if your need is to only include public 
            fields, use the <see cref="M:System.Type.GetFields"/> for this purpose.</para>
            <para>If the instance passed is <see langword="null"/>, the routine returns immediately and does not modify the array list
            passed If the type to check is <see langword="null"/>, the instance type is used as the start type for getting fields.</para>
            This method does not recurse into the <see cref="T:System.Object">System.Object</see> class.
            </remarks>
            </overloads>
            <summary>
            This overload will return all public and non-public fields for a class inclusive of fields in parent classes
            which have the given attribute and value.
            </summary>
            <remarks>
            If the attribute Type is <see langword="null"/>, no attributes are used to filter the resulting fields returned and is as if 
            you called <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object)"/>.
            If the attribute Value is checked, it is check against the value passed even if <see langword="null"/>.
            </remarks>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <param name="fieldCheckValue">A value that the field's value is checked against</param>
            <returns>An array of zero or more <see cref="T:System.Reflection.FieldInfo"/> objects</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Object,System.Type,System.Object)">
            <summary>
            This overload will return all public and non-public fields for a class inclusive of fields in parent classes
            which have the given attribute and value using the instance's type as the type to start getting fields.
            </summary>
            <remarks>
            If the attribute Type is <see langword="null"/>, no attributes are used to filter the resulting fields returned and is as if 
            you called <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object)"/>.
            If the attribute Value is checked, it is check against the value passed even if <see langword="null"/>.
            </remarks>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <param name="fieldCheckValue">A value that the field's value is checked against</param>
            <returns>An array of zero or more <see cref="T:System.Reflection.FieldInfo"/> objects</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object,System.Type)">
            <summary>
            This overload returns the fields that are marked with the passed attribute type for all public and nonpublic
            fields inclusive of inheritance.
            </summary>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <returns>An array of zero or more <see cref="T:System.Reflection.FieldInfo"/> objects</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Object,System.Type)">
            <summary>
            This overload returns the fields that are marked with the passed attribute type for all public and nonpublic
            fields inclusive of inheritance using the type of the instance passed.
            </summary>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <returns>An array of zero or more <see cref="T:System.Reflection.FieldInfo"/> objects</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object)">
            <summary>
            This overload will return all public and non-public fields for a class inclusive of fields in parent classes.
            </summary>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <returns>An array of zero or more <see cref="T:System.Reflection.FieldInfo"/> objects</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFields(System.Object)">
            <summary>
            This overload will return all public and non-public fields for a class inclusive of fields in parent classes
            using the passed instance's type as the type to inquire on.
            </summary>
            <param name="instance">The object instance to retrieve fields from</param>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Type,System.Object,System.Type,System.Object)">
            <overloads>
            <summary>
            This method returns the name of fields in a passed instance.
            </summary>
            <remarks>
            Refer to <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object,System.Type,System.Object)"/> for general discussion. These method behave the same as the GetFields
            overloads except that instead of returning the FieldInfo, they return the field name.
            </remarks>
            </overloads>
            <summary>
            This overload will return all public and non-public field names for a class inclusive of fields in parent classes
            which have the given attribute and value.
            </summary>
            <remarks>
            If the attribute Type is <see langword="null"/>, no attributes are used to filter the resulting fields returned and is as if 
            you called <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object)"/>.
            If the attribute Value is checked, it is check against the value passed even if <see langword="null"/>.
            </remarks>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <param name="fieldCheckValue">A value that the field's value is checked against</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Object,System.Type,System.Object)">
            <summary>
            This overload will return all public and non-public field names for a class inclusive of fields in parent classes
            which have the given attribute and value using the instance type's type to start getting fields.
            </summary>
            <remarks>
            If the attribute Type is <see langword="null"/>, no attributes are used to filter the resulting fields returned and is as if 
            you called <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Object)"/>.
            If the attribute Value is checked, it is check against the value passed even if <see langword="null"/>.
            </remarks>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <param name="fieldCheckValue">A value that the field's value is checked against</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Type,System.Object,System.Type)">
            <summary>
            This overload returns the field names that are marked with the passed attribute type for all public and nonpublic
            fields inclusive of inheritance.
            </summary>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Object,System.Type)">
            <summary>
            This overload returns the field names that are marked with the passed attribute type for all public and nonpublic
            fields inclusive of inheritance using the instance type's type to start getting fields.
            </summary>
            <param name="instance">The object instance to retrieve fields from</param>
            <param name="attributeType">The <see cref="T:System.Type"/> of the attribute to filter the return list of fields</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Type,System.Object)">
            <summary>
            This overload will return all public and non-public field names for a class inclusive of fields in parent classes.
            </summary>
            <param name="typeToCheck">The Type to start the check from.</param>
            <param name="instance">The object instance to retrieve fields from</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldNames(System.Object)">
            <summary>
            This overload will return all public and non-public field names for a class inclusive of fields in parent classes
            using the instance type's type to start getting fields.
            </summary>
            <param name="instance">The object instance to retrieve fields from</param>
            <returns>An array of zero or more field names</returns>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetFieldsImpl(System.Object,System.Type,System.Type,System.Object,System.Boolean,System.Boolean,System.Reflection.BindingFlags,System.Collections.ArrayList@)">
            <summary>
            Implementation of <see cref="M:Hca.Common.Utility.SystemUtility.GetFields(System.Type,System.Object,System.Type,System.Object)"/>
            </summary>
            <param name="instance">instance to get fields from</param>
            <param name="typeToCheck">Type to start search.</param>
            <param name="attributeType">attribute type to filter on if any</param>
            <param name="fieldCheckValue">value used to filter on for the field's value</param>
            <param name="isExistenceCheck">If <see langword="true"/>, only the existence of the attribute is made and any value is ignored.</param>
            <param name="includeNameOnly">If <see langword="true"/>, include only the name of the field instead of the full FieldInfo</param>
            <param name="bindingFlags">binding flags to use</param>
            <param name="memberList">list of <see cref="T:System.Reflection.FieldInfo"/> objects that match</param>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetAssemblyCodeBasePath(System.Reflection.Assembly)">
            <summary>Gets the code base directory path for a given assembly.</summary>
            <param name="assembly">An assembly.</param>
            <returns>Either <paramref name="assembly"/>.<see cref="P:System.Reflection.Assembly.CodeBase"/>, or, if the assembly was loaded from the GAC, then the string value found in HKEY_LOCAL_MACHINE\SOFTWARE\HCA\DevBlocks\GAC CodeBase\{assembly full name}, where {assembly full name} is <paramref name="assembly"/>.<see cref="P:System.Reflection.Assembly.FullName"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="assembly"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if <paramref name="assembly"/> was loaded from the GAC (i.e., if <paramref name="assembly"/>.<see cref="P:System.Reflection.Assembly.GlobalAssemblyCache"/> is <see langword="true"/>), but the registry does not specify a valid code base directory path for it.</exception>
        </member>
        <member name="M:Hca.Common.Utility.SystemUtility.GetGacAssemblyCodeBasePath(System.Reflection.Assembly)">
            <summary>Queries the registry for the code base directory path for a given Global Assembly Cache assembly.</summary>
            <param name="assembly">An assembly loaded from the GAC.</param>
            <returns>The string value found in HKEY_LOCAL_MACHINE\SOFTWARE\HCA\DevBlocks\GAC CodeBase\{assembly full name}, where {assembly full name} is <paramref name="assembly"/>.<see cref="P:System.Reflection.Assembly.FullName"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="assembly"/> is <see langword="null"/>, or was not loaded from the GAC (i.e., if <paramref name="assembly"/>.<see cref="P:System.Reflection.Assembly.GlobalAssemblyCache"/> is <b>false</b>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the registry does not specify a valid code base directory path for <paramref name="assembly"/>.</exception>
        </member>
        <member name="T:Hca.Common.Utility.UsableReaderWriterLock">
            <summary></summary>
            <remarks></remarks>
            <example><code><![CDATA[
            ]]></code></example>\
            <threadsafety static="true" instance="true" />
        </member>
        <member name="T:Hca.Common.Utility.ValueComparator">
            <summary>
            This class takes two objects and will determine if they are equivalent. Equivalence means that both objects 
            are of the same type and have the same values (where "same values" is defined as if the two items compare equal 
            using the <see cref="M:System.Object.Equals(System.Object)"/> method (if a value object), or by equating each part of a composite object.
            </summary>
            <threadsafety static="true" instance="true"/>
            <remarks>
            <para><b>Functional Requirements</b></para>
            <see cref="T:Hca.Common.Utility.ValueComparator"/> class must implement a full value 
            comparison of two objects.
            
            <para><b>Tenets</b></para>
            Any two objects that are compared must be of the same type.
            
            <para><b>Design</b></para>
            This class has only one method, <see cref="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object)"/>, which performs a full value for value 
            comparison of two objects. It iterates through parent and child objects, including arrays 
            and collections. In general, every value in the two objects must be the same for the 
            comparison to be equal. However, there are two exceptions to this rule:
            <list type="bullet">
            	<item>
            		If a class implements <see cref="T:System.IComparable"/>, then the equality is 
            		determined by this implementation.
            	</item>
            	<item>
            		If a class has the <see cref="T:Hca.Common.AlwaysEquivalentAttribute"/> applied, 
            		then any two objects of this class will always be equal. This attribute essentially 
            		tells the <see cref="T:Hca.Common.Utility.ValueComparator"/> to ignore the object.
            	</item>
            </list>
            This class does handle aggregates (arrays and collection) and hence if you have an object that has object 
            references or sequences, it	will recurse into those objects and compare their elements until only leaf nodes are 
            reached. Cycles are detected in self referencing or cyclical relationships (such as common with bi-directional reln) and 
            are not recursed.
            <para/>
            Since this class uses reflection, if byte code security is placed on a class and this class can't gain access 
            to a member, that member is ignored. Hence care should be taken when using this class in these cases especially if
            secured members are necessary to equate equality. One solution is for that class to implement the <see cref="T:System.IComparable"/> 
            interface so that the interface may be used without having to drill into the parts of the class.
            
            <para><b>Usage</b></para>
            This class is used to compare two objects and determine if they are equivalent. Equivalence 
            means that both objects are of the same type and have the same values (where "same values" 
            is defined as if the two items compare equal using the <see cref="M:System.Object.Equals(System.Object)"/> method (if a value 
            object), or by equating each part of a composite object.
            
            <para><b>Configuration</b></para>
            The <see cref="T:Hca.Common.Utility.ValueComparator"/> class should have one or more limiting namespaces 
            specified, which indicate the top most parent class(es) to compare for an object. If no limiting 
            namespace is specified then <see cref="T:Hca.Common.Utility.ValueComparator"/> class compares the object's 
            parent, then the parent's parent, etc. By default, the <see cref="N:System"/> namespace is excluded 
            from traversal.
            <para/>
            This limiting namespace should be as specific as is needed to ensure a correct comparison. 
            A higher-level namespace will encompass all of its child namespaces as well. Any collection 
            of namespaces to exclude is in addition to the default <see cref="N:System"/> namespace.
            <para/>
            Parent classes are navigated until the top most class is reached or a class is reached that is in the excluded 
            packages list. If <see langword="null"/> is passed for the excluded list, 
            the <see cref="N:System"/> and <see cref="N:Microsoft"/> namespace is 
            excluded by default. If an empty exclude list is passed, no namespaces are excluded. Otherwise, the namespaces 
            listed using a starts with comparison are excluded for navigation.
            <note>
            <p>
            It is recommended that System be a value in the list since it is not advisable to compare up into the .NET 
            framework classes(Unfortunately, Microsoft did not serialize all members of a their classes while also not 
            marking them such that you could know via reflection that the member was not included and hence there is no 
            way	to determine whether to compare or not compare the property.)
            </p>
            </note>
            <p>
            This class also takes the <see cref="T:System.IComparable"/> interface into account and will use that if the class implements 
            this interface. This will allow a class to define special equivalence semantics as needed. When collections are 
            encountered, the <see cref="T:System.Collections.IEnumerable"/> interface is used to iterate	through the list of elements. If the <see cref="T:System.Collections.IEnumerable"/>
            is an <see cref="T:Hca.Common.ISet"/> then comparison is done using contains checking instead of ordered element checking
            as is done for all other collection types.
            </p>
            <note>
            <p>
            Since <see cref="T:System.Collections.IEnumerable"/> types are containers, no members present in the base collection type are
            used for comparison purposes. By default current collection types in .NET and our custom <see cref="T:Hca.Common.ISet"/> types
            do not define in fields that contribute to the value for comparison purposes. However, if this is
            the case you should override <see cref="T:System.IComparable"/> since this takes precedence over 
            <see cref="T:System.Collections.IEnumerable"/>.
            </p>
            </note>
            
            <para><b>Best Practices</b></para>
            Use the <see cref="T:Hca.Common.BaseType.ObjectBase"/> class' 
            <see cref="M:Hca.Common.BaseType.ObjectBase.Equals(System.Object)">ObjectBase.Equals</see> method instead 
            of the <see cref="T:Hca.Common.Utility.ValueComparator"/> class when comparing objects that inherit 
            from <see cref="T:Hca.Common.BaseType.ObjectBase"/>. <see cref="T:Hca.Common.BaseType.ObjectBase"/> 
            class can be used outside of <see cref="T:Hca.Common.BaseType.ObjectBase"/> where needed.
            </remarks>
            <example>
            <hcaExample>
            <code>
            MyDataType data1 = new MyDataType();
            MyDataType data2 = new MyDataType();
            . . . // set properties on data1 and data2
            bool isEqual = ValueComparator.IsEqual(data1, data2);
            </code>
            </hcaExample>
            <para/>
            To invoke comparison using default of excluding classes in the System.* namespace:
            <code>
            bool isEqual = ValueComparator.IsEqual(obj1, obj2);
            </code>
            To invoke comparison and include all types:
            <code>
            bool isEqual = ValueComparator.IsEqual(obj1, obj2, new string[0]);
            </code>
            To invoke comparison and exclude a specific list of namespaces:
            <code>
            bool isEqual = ValueComparator.IsEqual(obj1, obj2, new string[]{"System","Microsoft"});
            </code>
            </example>
        </member>
        <member name="F:Hca.Common.Utility.ValueComparator.log">
            <summary>
            Logger for this class
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.ValueComparator.depth">
            <summary>
            This field provides the depth of recursion into determining
            the comparison of two objects.
            </summary>
        </member>
        <member name="F:Hca.Common.Utility.ValueComparator.visited">
            <summary>
            This field provides the collection of objects visited on the recursion of
            comparisons. It is used to break cycles that may exist in the 
            comparison chain.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.#ctor">
            <summary>
            Hide constructor so class is not instantiated.
            </summary>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object)">
            <overloads>This method provides equivalence checking for two objects.</overloads>
            <summary>
            This method provides equivalence checking for two objects with no namespace exclusions. 
            </summary>
            <remarks>
            Value objects
            from the .Net framework compare equal if their Equals method returns true. 
            User defined objects compare equal if their parts inclusive of drill-down 
            into members are equal based on member by member equivalence. Any member 
            which is not accessible is not considered into the comparison. If an 
            unexpected exception occurs, a runtime exception is thrown.
            </remarks>
            <param name="obj1">The first object to compare</param>
            <param name="obj2">The second object to compare</param>
            <returns><see langword="true"/> if the objects compare equal</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">Thrown if unexpected exception occurs</exception>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object,System.String[])">
            <summary>
            This method provides equivalence checking for two objects with namespace exclusions. 
            </summary>
            <remarks>
            Value objects from the .Net framework compare equal if their Equals method returns true. 
            User defined objects compare equal if their parts inclusive of drill-down into members are equal based on 
            member by member equivalence. Any member which is not accessible is not considered into the comparison. If an 
            unexpected exception occurs, a runtime exception is thrown.
            </remarks>
            <param name="obj1">The first object to compare</param>
            <param name="obj2">The second object to compare</param>
            <param name="namespaceExcludes">An array of strings of namespaces that should be excluded for evaluation.</param>
            <returns><see langword="true"/> if the objects compare equal</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">Thrown if unexpected exception occurs</exception>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.IsEqualImpl(System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            This is the actual implementation for the <see cref="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object)"/> method.
            <see cref="M:Hca.Common.Utility.ValueComparator.IsEqual(System.Object,System.Object,System.String[])"/>
            </summary>
            <param name="obj1">The first object to compare</param>
            <param name="obj2">The second object to compare</param>
            <param name="namespaceExcludeList">A list of namespace strings that should be excluded from evaluation.</param>
            <returns><see langword="true"/> if the objects compare equal</returns>
            <exception cref="T:Hca.Common.BaseException.HcaApplicationException">Thrown if unexpected exception occurs</exception>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.CompareClass(System.Type,System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            This class puts the two objects through a series of tests to determine if they are equal.  These test include 
            determining whether the Parent (inherited) classes are equal, whether the two objects implement 
            <see cref="T:System.IComparable"/>, whether the base type of the two objects are arrays or collections, are System 
            value types, or are composite types.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the two objects.</param>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see langword="true"/> if equal, false if not equal.</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestParent(System.Type,System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            Determines whether the Parent (inherited / base) classes
            of the two objects are equal.  If the namespace of the parent class
            is listed in the Excluded Namespace list then the parent class is skipped.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the two objects.</param>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestArray(System.Type,System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            Determines whether this type is an array.  If so, test each element for equality.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the two objects.</param>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.CompareAlwaysTruePresent(System.Reflection.FieldInfo)">
            <summary>
            Checks an object to see if the NoCompare Attribute is present.
            </summary>
            <param name="fieldInfo">Field to check</param>
            <returns><see langword="true"/> if the attribute is present</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestIEnumerable(System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            Determines whether this type is a collection.
            </summary>
            <remarks>
            If a enumerable type implements <see cref="T:Hca.Common.ISet"/> then we need to do set based equality. Otherwise
            we treat it as a sequence and compare correspondingly.
            </remarks>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestIComparable(System.Object,System.Object)">
            <summary>
            Determines whether this type implements <see cref="T:System.IComparable"/>.  Is so, use the <see cref="M:System.IComparable.CompareTo(System.Object)"/> method.
            </summary>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestSystemValueType(System.Type,System.Object,System.Object)">
            <summary>
            Determines whether this type is a System Value Type.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the two objects.</param>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.TestFields(System.Type,System.Object,System.Object,System.Collections.Specialized.StringCollection)">
            <summary>
            Tests each Field value (public and private).
            <see langword="Static"/> fields are skipped.
            </summary>
            <remarks>
            Note that we are not testing Properties (which are treated separately in .Net).
            Properties can either be an accessor of a private field or a derived value.
            Since a Property value is always based off of a Field Value there is no need to test it.
            </remarks>
            <param name="type">The <see cref="T:System.Type"/> of the two objects.</param>
            <param name="obj1">The first object to compare.</param>
            <param name="obj2">The second object to compare.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns><see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Equal"/>, <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.NotEqual"/>, or <see cref="F:Hca.Common.Utility.ValueComparator.CompareState.Continue"/> (if equality is not yet determined)</returns>
        </member>
        <member name="M:Hca.Common.Utility.ValueComparator.NavigateParent(System.String,System.Collections.Specialized.StringCollection)">
            <summary>
            Helper method to determine whether to navigate to a parent package
            </summary>
            <param name="classNamespace">The namespace to lookup.</param>
            <param name="namespaceExcludeList">A collection of namespaces that should be excluded for evaluation.</param>
            <returns>True is the namespace should be tested, false if not.</returns>
        </member>
        <member name="T:Hca.Common.Utility.WindowsSecurity">
            <summary>Provides static methods abstracting baseline .NET and Win32 security operations.</summary>
            <remarks>
            <para>The methods provided by this class break out into three related areas:</para>
            <para><see cref="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.Net.NetworkCredential)"/> takes standard Windows credentials (domain, username, password) 
            and returns a logged-on Windows identity.</para>
            <para><see cref="M:Hca.Common.Utility.WindowsSecurity.GetCurrentDotNetPrincipal"/> and <see cref="M:Hca.Common.Utility.WindowsSecurity.GetCurrentWin32Identity"/> may 
            be used to query the security information associated with the current thread.</para>
            <para><see cref="M:Hca.Common.Utility.WindowsSecurity.EnterDotNetPrincipalContext(System.Security.Principal.IPrincipal)"/> and <see cref="M:Hca.Common.Utility.WindowsSecurity.EnterWin32IdentityContext(System.String,System.String,System.String)"/> 
            may be used to temporarily modify the security information associated with the current thread.</para>
            <para>It is important to understand the distinction between the concepts of ".NET principal" and "Win32 identity". The term 
            "Win32 identity" is used to refer to the unmanaged (i.e., non-.NET), process-level account token. This token is used to 
            authorize access to Windows resources (such as the file system), as well as SQL Server (when using integrated authentication).</para>
            <para>The term ".NET principal" refers to the <see cref="T:System.Security.Principal.IPrincipal"/> instance associated with the current thread's 
            managed wrapper (see <see cref="T:System.Threading.Thread"/> and <see cref="P:System.Threading.Thread.CurrentPrincipal"/>). This identity is usually used to 
            represent the client on whose behalf some server code is executing (e.g., the browser user in ASP.NET).</para>
            <para>Note that manipulating the Win32 identity is inherently both costlier and riskier than manipulating the 
            .NET principal. Cost is greater because it requires calls into unmanaged code. Risk is greater because of the 
            low-level resource access that may be available to some Windows accounts.</para>
            </remarks>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.#ctor">
            <summary>Private constructor prevents instantiation of static-only class.</summary>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.GetCurrentDotNetPrincipal">
            <summary>Gets the <see cref="T:System.Security.Principal.IPrincipal"/> on the current .NET managed <see cref="T:System.Threading.Thread"/>.</summary>
            <returns>The principal on the current .NET managed thread.</returns>
            <exception cref="T:System.Security.SecurityException">Thrown if the caller does not have the required permission.</exception>
            <remarks>This method is implemented in terms of <see cref="P:System.Threading.Thread.CurrentPrincipal"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.EnterDotNetPrincipalContext(System.Security.Principal.IPrincipal)">
            <summary>Sets the <see cref="T:System.Security.Principal.IPrincipal"/> on the current .NET managed <see cref="T:System.Threading.Thread"/>.</summary>
            <param name="principal">The <see cref="T:System.Security.Principal.IPrincipal"/> to place on the current .NET managed <see cref="T:System.Threading.Thread"/>.</param>
            <returns>An <see cref="T:System.IDisposable"/> handle for reverting to the previous principal when done.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="principal"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the caller does not have the required permission.</exception>
            <remarks><b>Note:</b> Consuming code is not required to maintain a reference to the returned object or to call <see cref="M:System.IDisposable.Dispose"/> if there will be no need to revert to the previous principal.</remarks>
            <example>
            The following example demonstrates typical usage of this method:
            <code>
            using (WindowsSecurity.EnterDotNetPrincipalContext(usersPrincipal))
            {
            	//	Call code that expects to find a user's principal on the managed thread...
            }
            </code>
            For complex cases where the using() syntax is not appropriate, use a finally clause and call <see cref="M:System.IDisposable.Dispose"/> explicitly:
            <code>
            IDisposable context = WindowsSecurity.EnterDotNetPrincipalContext(usersPrincipal);
            
            //	Call code that expects to find a user's principal on the managed thread...
            
            finally
            {
            	context.Dispose();
            }
            </code>
            If you are sure there will be no need to revert to the previous principal, disposal is unnecessary:
            <code>
            WindowsSecurity.EnterDotNetPrincipalContext(usersPrincipal);
            //	Call code that expects to find a user's principal on the managed thread...
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.GetCurrentWin32Identity">
            <summary>Gets the <see cref="T:System.Security.Principal.WindowsIdentity"/> on the current Win32 unmanaged thread.</summary>
            <returns>The principal on the current .NET managed thread.</returns>
            <exception cref="T:System.Security.SecurityException">Thrown if the caller does not have the required permission.</exception>
            <remarks>This method is implemented in terms of <see cref="M:System.Security.Principal.WindowsIdentity.GetCurrent"/>.</remarks>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.EnterWin32IdentityContext(System.String,System.String,System.String)">
            <overloads>Sets the <see cref="T:System.Security.Principal.WindowsIdentity"/> on the current Win32 unmanaged thread.</overloads>
            
            <summary>Sets the <see cref="T:System.Security.Principal.WindowsIdentity"/> on the current Win32 unmanaged thread to the identity specified by the given credentials.</summary>
            <param name="domain">The domain of the identity to place on the current Win32 unmanaged thread.</param>
            <param name="userName">The name of the identity to place on the current Win32 unmanaged thread.</param>
            <param name="password">The password of the identity to place on the current Win32 unmanaged thread.</param>
            <returns>An <see cref="T:System.IDisposable"/> handle for reverting to the previous identity when done.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="userName"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the logon fails or if impersonation fails.</exception>
            <remarks><b>Warning:</b> Consuming code must maintain a reference to the returned object and call <see cref="M:System.IDisposable.Dispose"/> in order to ensure that all resources associated with impersonation are released.</remarks>
            <example>
            The following example demonstrates typical usage of this method:
            <code>
            using (WindowsSecurity.EnterWin32IdentityContext(serviceAccountDomain, serviceAccountName, serviceAccountPassword))
            {
            	//	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            }
            </code>
            For complex cases where the using() syntax is not appropriate, use a finally clause and call <see cref="M:System.IDisposable.Dispose"/> explicitly:
            <code>
            IDisposable context = WindowsSecurity.EnterWin32IdentityContext(serviceAccountIdentity);
            
            //	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            
            finally
            {
            	context.Dispose();
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.EnterWin32IdentityContext(System.Net.NetworkCredential)">
            <summary>Sets the <see cref="T:System.Security.Principal.WindowsIdentity"/> on the current Win32 unmanaged thread to the identity specified by the given credentials.</summary>
            <param name="credential">Contains the domain, name, and password of the identity to place on the current Win32 unmanaged thread.</param>
            <returns>An <see cref="T:System.IDisposable"/> handle for reverting to the previous identity when done.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="credential"/> is <see langword="null"/>, or if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the logon fails or if impersonation fails.</exception>
            <remarks><b>Warning:</b> Consuming code must maintain a reference to the returned object and call <see cref="M:System.IDisposable.Dispose"/> in order to ensure that all resources associated with impersonation are released.</remarks>
            <example>
            The following example demonstrates typical usage of this method:
            <code>
            using (WindowsSecurity.EnterWin32IdentityContext(serviceAccountDomain, serviceAccountName, serviceAccountPassword))
            {
            	//	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            }
            </code>
            For complex cases where the using() syntax is not appropriate, use a finally clause and call <see cref="M:System.IDisposable.Dispose"/> explicitly:
            <code>
            IDisposable context = WindowsSecurity.EnterWin32IdentityContext(serviceAccountIdentity);
            
            //	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            
            finally
            {
            	context.Dispose();
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.EnterWin32IdentityContext(System.Security.Principal.WindowsIdentity)">
            <summary>Sets the <see cref="T:System.Security.Principal.WindowsIdentity"/> on the current Win32 unmanaged thread.</summary>
            <param name="identity">The <see cref="T:System.Security.Principal.WindowsIdentity"/> to place on the current Win32 unmanaged thread.</param>
            <returns>An <see cref="T:System.IDisposable"/> handle for reverting to the previous identity when done.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="identity"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if impersonation fails.</exception>
            <remarks><b>Warning:</b> Consuming code must maintain a reference to the returned object and call <see cref="M:System.IDisposable.Dispose"/> in order to ensure that all resources associated with impersonation are released.</remarks>
            <example>
            The following example demonstrates typical usage of this method:
            <code>
            using (WindowsSecurity.EnterWin32IdentityContext(serviceAccountDomain, serviceAccountName, serviceAccountPassword))
            {
            	//	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            }
            </code>
            For complex cases where the using() syntax is not appropriate, use a finally clause and call <see cref="M:System.IDisposable.Dispose"/> explicitly:
            <code>
            IDisposable context = WindowsSecurity.EnterWin32IdentityContext(serviceAccountIdentity);
            
            //	Call code that enforces access control against the Win32 identity on the unmanaged thread...
            
            finally
            {
            	context.Dispose();
            }
            </code>
            </example>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.Net.NetworkCredential)">
            <overloads>Logs on a Windows account using specified credentials.</overloads>
            
            <summary>Logs on a Windows account using credentials specified by a <see cref="T:System.Net.NetworkCredential"/> and the <see cref="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.NetworkClearText"/> <see cref="T:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle"/>.</summary>
            <param name="credential">Contains the domain, name, and password of the account to log on.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="credential"/> is <see langword="null"/>, or if <paramref name="credential"/>.<see cref="P:System.Net.NetworkCredential.UserName"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the logon fails.</exception>
            <returns>A <see cref="T:System.Security.Principal.WindowsIdentity"/> for the specified Windows account.</returns>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.String,System.String,System.String)">
            <summary>Logs on a Windows account using specified credentials and the <see cref="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.NetworkClearText"/> <see cref="T:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle"/>.</summary>
            <param name="domain">The domain of the account to log on.</param>
            <param name="userName">The name of the account to log on.</param>
            <param name="password">The password of the account to log on.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="userName"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the logon fails.</exception>
            <returns>A <see cref="T:System.Security.Principal.WindowsIdentity"/> for the specified Windows account.</returns>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.String,System.String,System.String,Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle)">
            <summary>Logs on a Windows account using specified credentials and <see cref="T:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle"/>.</summary>
            <param name="domain">The domain of the account to log on.</param>
            <param name="userName">The name of the account to log on.</param>
            <param name="password">The password of the account to log on.</param>
            <param name="style">The style of logon to perform.</param>
            <remarks>
            <para><paramref name="style"/> corresponds to LOGON32_LOGON_TYPE in the Win32 LogonUser documentation. The default value (see <see cref="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.String,System.String,System.String)"/>) should be correct for all commonly encountered situations. If in doubt, please use that overload; inappropriate values may result in security vulnerabilities.</para>
            <para>This method will always use the default Win32 default logon provider (LOGON32_PROVIDER_DEFAULT).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="userName"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the logon fails.</exception>
            <returns>A <see cref="T:System.Security.Principal.WindowsIdentity"/> for the specified Windows account.</returns>
        </member>
        <member name="T:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle">
            <summary>Win32 LogonUser logon types.</summary>
            <remarks>For passing through <see cref="M:Hca.Common.Utility.WindowsSecurity.LogonWindowsIdentity(System.String,System.String,System.String,Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle)"/>.</remarks>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.Interactive">
            <summary>Corresponds to LOGON32_LOGON_INTERACTIVE in Platform SDK : Security</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.Network">
            <summary>Corresponds to LOGON32_LOGON_NETWORK in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.Batch">
            <summary>Corresponds to LOGON32_LOGON_BATCH in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.Service">
            <summary>Corresponds to LOGON32_LOGON_SERVICE in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.Unlock">
            <summary>Corresponds to LOGON32_LOGON_UNLOCK in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.NetworkClearText">
            <summary>Corresponds to LOGON32_LOGON_NETWORK_CLEARTEXT in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.WindowsLogonStyle.NewCredentials">
            <summary>Corresponds to LOGON32_LOGON_NEW_CREDENTIALS in Platform SDK : Security.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.DotNetPrincipalContext.previousPrincipal">
            <summary>Holds the principal that was on the thread before we entered this context.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.DotNetPrincipalContext.disposalHelper">
            <summary>Abstracts correct <see cref="T:System.IDisposable"/> implementation.</summary>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.DotNetPrincipalContext.#ctor(System.Security.Principal.IPrincipal)">
            <summary>Enters a context with the specified <see cref="T:System.Security.Principal.IPrincipal"/> on the .NET managed <see cref="T:System.Threading.Thread"/>.</summary>
            <param name="principal">The principal to place on the .NET thread.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="principal"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if the caller does not have the required permission.</exception>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.DotNetPrincipalContext.System#IDisposable#Dispose">
            <summary>Exits the context, resetting the thread principal to what it was prior to entry.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.Win32IdentityContext.previousIdentity">
            <summary>Holds the identity that was on the process before we entered this context.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.Win32IdentityContext.impersonationContext">
            <summary>Holds the inner impersonation context.</summary>
        </member>
        <member name="F:Hca.Common.Utility.WindowsSecurity.Win32IdentityContext.disposalHelper">
            <summary>Abstracts correct <see cref="T:System.IDisposable"/> implementation.</summary>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.Win32IdentityContext.#ctor(System.Security.Principal.WindowsIdentity)">
            <summary>Enters a context with the specified <see cref="T:System.Security.Principal.WindowsIdentity"/> on the Win32 unmanaged thread.</summary>
            <param name="identity">The identity to place on the Win32 thread.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="identity"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown if impersonation fails.</exception>
        </member>
        <member name="M:Hca.Common.Utility.WindowsSecurity.Win32IdentityContext.System#IDisposable#Dispose">
            <summary>Exits the context, resetting the process identity to what it was prior to entry.</summary>
        </member>
        <member name="T:Hca.Common.AlwaysEquivalentAttribute">
            <summary>
            This is a custom attribute that acts as a marker to
            designate that a field should not be considered 
            when doing a comparison for equality. This should
            be used on transient instance fields that do not
            contribute to the value semantics of a class.
            </summary>
            <threadsafety static="true" instance="false" /> 
        </member>
        <member name="M:Hca.Common.AlwaysEquivalentAttribute.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="T:Hca.Common.InternalExceptionMessage">
            <summary>
            Summary description for InternalExceptionMessage.
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.#ctor">
            <summary>
            Hide Constructor
            </summary>		
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TestMessage">
            <summary>
            <para>Message used to test the <c>Message.ResourceMessage</c> with no formatting.</para>
            <para><b>Message:</b> "This is a test exception message."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TestMessage(System.String,System.String)">
            <summary>
            <para>Message with formattable arguments used to test <c>Message.ResourceMessage</c>.</para>
            <para><b>Message:</b> "This is a test exception message with formattable arguments: [{0}], [{1}]."</para>
            </summary>
            <param name="formatArg1">The first argument for the message.</param>
            <param name="formatArg2">The second argument for the message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ArgumentNull(System.String)">
            <summary>
            <para>This key is used when an argument is not provided but should be.</para>
            <para><b>Message:</b> "Argument [{0}] must be supplied."</para>
            </summary>
            <param name="argumentName">The name of the argument.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.XmlObjectTypeForArrayInvalid(System.Type,System.Type,System.String)">
            <summary>
            <para>Used when <see cref="T:Hca.Common.Builder.ObjectBuilder"/> cannot assign a given object to a given array element.</para>
            <para><b>Message:</b> "The object type [{0}] is not assignable to an array of type [{1}] for XML node [{2}]."</para>
            </summary>
            <param name="objectType">The type of the object supplied.</param>
            <param name="expectedType">The type of the object expected.</param>
            <param name="xmlNodeName">The node name where the object was to be valued.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ArgumentMustBeZeroOrGreater(System.String)">
            <summary>
            <para>Used when an argument must have a positive value and a negative value is passed.</para>
            <para><b>Message:</b> "[{0}] must be greater than or equal to zero."</para>
            </summary>
            <param name="argumentName">The name of the argument.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TypeInvalid">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Builder.ObjectBuilder"/> when an invalid type is encountered.</para>
            <para><b>Message:</b> "The specified type is not valid."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TypeUnexpected(System.Object,System.Type,System.String)">
            <summary>
            <para>This exception is used to designate a a class is not of the expected type.</para>
            <para><b>Message:</b> The Type [{0}] is not of the expected Type [{1}] for [{2}].</para>
            </summary>
            <remarks>If <see langword="null"/> is passed, <see langword="null"/> is shown.</remarks>
            <param name="objSupplied">The Object that was supplied.</param>
            <param name="typeExpected">The Type Expected.</param>
            <param name="itemName">The name of the argument, property, field that has the wrong type.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TypeNotAPrimitive(System.Type)">
            <summary>
            <para>Used when an argument is supposed to be a primitive type, but isn't.</para>
            <para><b>Message:</b> "The specified type is not a primitive type: [{0}]."</para>
            </summary>
            <param name="typeSupplied"> The (non-primitive) type of the object.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConstructorInvalid">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Builder.ObjectBuilder"/> when a type does not have any 
            defined constructors that match the specified signature.</para>
            <para><b>Message:</b> "An invalid constructor was specified."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ExceptionContextNameMustBeSpecified">
            <summary>
            <para>Used in <see cref="T:Hca.Common.BaseException.ExceptionConfig"/> when <c>contextName</c> is <see langword="null"/>.</para>
            <para><b>Message:</b> "The context name for getting Exception Messages must be defined."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.HashCodeCircularImplementation">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Utility.HashCodeGenerator"/> when <i>obj1</i> is not IIdentifiable but implements <see cref="M:System.Object.GetHashCode"/> in terms of <see cref="M:Hca.Common.Utility.HashCodeGenerator.CalculateHashCode(System.Object)"/>.</para>
            <para><b>Message:</b> "The argument to HashCodeGenerator.CalculateHashCode must implement IIdentifiable if it implements its GetHashCode in terms of CalculateHashCode."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigTypeWrong(System.Type,System.Type)">
            <overloads>
            Used when a non-config type was passed in a config request.
            </overloads>
            <summary>
            <para>Used when a specified non-config type was passed in a config request.</para>
            <para><b>Message:</b> "The supplied type [{0}] does not derive from [{1}]."</para>
            </summary>
            <param name="objectType">The object type that is of the wrong type.</param>
            <param name="expectedType">The type expected.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigTypeWrong(System.String,System.String,System.String)">
            <summary>
            <para>Used when a non-config type at a specified location in a config definition within a 
            specified context and a detailed message is available.</para>
            <para><b>Message:</b> "Invalid configuration type defined in the context(s) [{0}] in {1}: {2}."</para>
            </summary>
            <param name="configContext">The config definition context.</param>
            <param name="location">Location within the config definition.</param>
            <param name="message">A detailed error message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigObjectInstantiationFailure(System.Type,System.String)">
            <overloads>
            Used when building a config object fails.
            </overloads>
            <summary>
            <para>Used when building a config object of the specified type and context fails.</para>
            <para><b>Message:</b> "Could not build configuration object of type [{0}] in the context(s) [{1}]."</para>
            </summary>
            <param name="configType">The Type of config object to build.</param>
            <param name="configContext">The context of the config definition.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigObjectInstantiationFailure(System.Type,System.String,System.String,System.String)">
            <summary>
            <para>Used when building a config object of the specified type, context, and config location fails 
            and a detailed message is available.</para>
            <para><b>Message:</b> "Could not build configuration object of type [{0}] in the context(s) [{1}] defined in {2}: {3}."</para>
            </summary>
            <param name="configType">The Type of config object to build.</param>
            <param name="configContext">The context of the config definition.</param>
            <param name="location">The location of the config definition.</param>
            <param name="message">The detailed error message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigObjectNotFoundForType(System.Type)">
            <summary>
            <para>Used when the requested config type has no instances in any context.</para>
            <para><b>Message:</b> "No configuration objects were defined of type [{0}]."</para>
            </summary>
            <param name="configType">The Type of config object to build.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigObjectNotFoundForContext(System.Type,System.String)">
            <summary>
            <para>Used when the requested config type has no instances in the specified context.</para>
            <para><b>Message:</b> "No configuration objects were defined of type [{0}] in the [{1}] context."</para>
            </summary>
            <param name="configType">The Type of config object to build.</param>
            <param name="configContext">The context of the config definition.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigHasTooManyObjectsDefined(System.Type,System.String,System.String,System.String)">
            <summary>
            <para>Used when the requested config type has too many instances in the specified context.</para>
            <para><b>Message:</b> "More than one object was defined with type [{0}] in the [{1}] context. First found in {2}. 
            Second found in {3}."</para>
            </summary>
            <param name="configType">The Type of config object to build.</param>
            <param name="configContext">The context of the config definition.</param>
            <param name="firstLocation">First location definition found.</param>
            <param name="secondLocation">Second location definition found.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigReadOnly(System.Type)">
            <overloads>
            Used when an attempt is made to modify a <see cref="T:Hca.Common.Configuration.ConfigBase"/> 
            instance whose <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> property is set to <see langword="true"/>.
            </overloads>
            <summary>
            <para>Used when an attempt is made to modify a <see cref="T:Hca.Common.Configuration.ConfigBase"/> instance of the specified config type 
            whose <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> property is set to <see langword="true"/>.</para>
            <para><b>Message:</b> "Cannot modify this [{0}]  because it's read only."</para>
            </summary>
            <param name="configType">The Type of the config object.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigReadOnly(System.Type,System.String)">
            <summary>
            <para>Used when an attempt is made from a specified source to modify a 
            <see cref="T:Hca.Common.Configuration.ConfigBase"/> instance of the specified config type 
            whose <see cref="P:Hca.Common.Configuration.ConfigBase.ReadOnly"/> property is set to <see langword="true"/>.</para>
            <para><b>Message:</b> "Cannot invoke [{1}] on this [{0}] because it's read only."</para>
            </summary>
            <param name="configType">The Type of the config object.</param>
            <param name="sourceName">The name of the property or method attempting to modify the object's value.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigUnusableTokenDefault(System.String,System.String)">
            <summary>
            <para>Used when a token default can not be used as specified.</para>
            <para><b>Message:</b> "Could not use the token default defined in [{0}]: cause[{1}]."</para>
            </summary>
            <param name="location">A description of where the token was defined.</param>
            <param name="causeDetail">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigUnusableToken(System.String,System.String)">
            <summary>
            <para>Used when a token default can not be used as specified.</para>
            <para><b>Message:</b> "Could not use the token defined in [{0}]: cause[{1}]."</para>
            </summary>
            <param name="location">A description of where the token was defined.</param>
            <param name="causeDetail">The message of the exception that caused this condition.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigDuplicateTokenDefault(System.String,System.String,System.String)">
             <summary>
             <para>Used when multiple default token definitions exist.</para>
             <para><b>Message:</b> "More than one value is defined for the token name [{0}]. First found in {1}. Second 
             found in {2}."</para>
             </summary>
             <param name="tokenName">The token name.</param>
             <param name="firstLocation">First definition location.</param>
             <param name="secondLocation">Second definition location.</param>
            <returns>The Message for this condition.</returns>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigDuplicateToken(System.String,System.String,System.String)">
             <summary>
             <para>Used when multiple token definitions exist.</para>
             <para><b>Message:</b> "More than one value is defined for the token name [{0}]. First found in {1}. 
             Second found in {2}."</para>
             </summary>
             <param name="tokenName">The token name.</param>
             <param name="firstLocation">First definition location.</param>
             <param name="secondLocation">Second definition location.</param>
            <returns>The Message for this condition.</returns>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigPropertyRequiresValue(System.Type,System.String)">
             <summary>
             <para>Used when a config xml definition has a property marked required but no value is specified in the definition.</para>
             <para><b>Message:</b> "A Config Object [{0}] definition for property [{1}] requires a value to be specified."</para>
             </summary>
             <param name="configType">The config type that has a missing property value.</param>
             <param name="propertyName">The name of the property that requires a value.</param>
            <returns>The Message for this condition.</returns>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.CredentialsContainInvalidCharacter(System.String,System.String)">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.Configuration.ConfiguredNetworkCredential"/> to report an invalid character in a set of credentials.</para>
            <para><b>Message:</b> "The specified credential elements contain an invalid character: UserName=[{0}], Domain=[{1}]."</para>
            </summary>
            <param name="userName">The value of the UserName property.</param>
            <param name="domain">The value of Domain property.</param>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.AbsurdCredentials">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.Configuration.ConfiguredNetworkCredential"/> to report an invalid set of credentials.</para>
            <para><b>Message:</b> "The specified combination of credential elements is invalid - if domain, user name, or password is specified, then both domain and user name must be specified."</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ElapseTimeAverageIndeterminate">
            <summary>
            <para>Used to indicate that there is a problem with the elapse time.</para>
            <para><b>Message:</b> "There is not enough data points to calculate an average elapse time."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.PropertyUtilityConverterMissing(System.Type)">
            <summary>
            <para>Used to indicate that a converter for a type was not found.</para>
            <para><b>Message:</b> "Unable to get or set index value. A converter for type [{0}] was not found."</para>
            </summary>
            <param name="converterType">The type of the missing converter.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.PropertyUtilityIndexMismatch">
            <summary>
            <para>Used to indicate that the amount of indexes supplied are not defined for this property.</para>
            <para><b>Message:</b> "The amount of indexes supplied are not defined for this property."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ResourceContextNameNotFound(System.String)">
            <summary>
            <para><see cref="T:Hca.Common.Resource.MissingResourceException"/> message when a specified context could not be found.</para>
            <para><b>Message:</b> "The contextName [{0}] was not found."</para>
            </summary>
            <param name="contextName">The name of the context not found.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ResourceNotFound(System.String,System.String)">
            <overloads>
            <see cref="T:Hca.Common.Resource.MissingResourceException"/> message when a resource could not be found.
            </overloads>
            <summary>
            <para><see cref="T:Hca.Common.Resource.MissingResourceException"/> message when a resource could not be found in a specified context.</para>
            <para><b>Message:</b> "The resource name [{1}] was not found in the contextName [{0}]."</para>
            </summary>
            <param name="contextName">The name of the resource context.</param>
            <param name="resourceKey">The resource that was being looked for.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ResourceNotFound(System.String)">
            <summary>
            <para><see cref="T:Hca.Common.Resource.MissingResourceException"/> message when a resource could not be found in any context.</para>
            <para><b>Message:</b> "The resource name [{0}] was not found."</para>
            </summary>
            <param name="resourceKey">The resource the could not be found.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.SupplementalExceptionMessage(System.String)">
            <summary>
            <para>This key is used when the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> displays a supplemental exception message.</para>
            <para><b>Message:</b> "Supplemental exception message: [{0}]."</para>
            </summary>
            <param name="message">The additional exception message to display.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.SupplementalExceptionMessageNotFound(System.String)">
            <summary>
            <para>This key is used when the <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> cannot load the supplemental exception message resource.</para>
            <para><b>Message:</b> "Supplemental exception message with key [{0}] was not found."</para>
            </summary>
            <param name="messageKey">The key that was used to find the message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigFactoryCreationFailed(System.String)">
            <summary>
            <para>Used if there is a problem instantiating an instance of <see cref="T:Hca.Common.Configuration.ConfigFactory"/>
            that is not configuration-based.</para>
            <para><b>Message:</b> "An exception occurred while creating ConfigFactory: [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The inner exception message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigFactoryReloadFailed(System.String)">
            <summary>
            <para>Used if there is a problem reloading the configuration in 
            <see cref="T:Hca.Common.Configuration.ConfigFactory"/>.</para>
            <para><b>Message:</b> "An exception occurred while refreshing ConfigFactory: [{0}]."</para>
            </summary>
            <param name="innerExcMessage">The inner exception message.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.MethodHasNoImplementation">
            <summary>
            <para>Used when a method has no usable implementation.</para>
            <para><b>Message:</b> "Method not supported at this time."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.DisposalHelperInvalidRelease">
            <summary>
            <para>Used when a call is made to <see cref="M:Hca.Common.Utility.DisposalHelper.ReleaseHold"/>, but no hold exists to be released.</para>
            <para><b>Message:</b> "The request to release a disposal hold is invalid; the current thread does not have any holds."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigFactoryAccessViolation(System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a caller requests a config type it is not authorized to retrieve.</para>
            <para><b>Message:</b> "Configuration of type [{0}] from assembly [{1}] was requested by unauthorized assembly [{2}]. For other assemblies to access this type, it must be compiled with the [{3}] applied."</para>
            <para><b>Parameter Note:</b></para>
            <para> parameter {1} is taken from the first formal parameter to this message.</para>
            </summary>
            <param name="configType">The requested Configuration Type.</param>
            <param name="callingAssembly">The assembly that is calling for this config type.</param>
            <param name="requiredAttributeName">The Attribute that must decorate the config type to allow access.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigPrimaryNotFound(System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when the specified primary configuration file cannot be located.</para>
            <para><b>Message:</b> "Could not locate specified primary configuration file [{0}]."</para>
            </summary>
            <param name="missingFileName">The file that is missing.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigIncludeNotFound(System.String,System.String)">
            <overloads>
            Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a specified include cannot be located.
            </overloads>
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a specified include from a requesting source cannot be located.</para>
            <para><b>Message:</b> "Could not locate {0}. (Include directive was from {1}.)"</para>
            </summary>
            <param name="missingInclude">The include that is missing.</param>
            <param name="requestingSource">The source that specified the include.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigIncludeNotFound(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a specified include from a specified line number and column
            of a requesting source cannot be located.</para>
            <para><b>Message:</b> "Could not locate {0}. (Include directive was from {1}: line {2}, column {3}.)"</para>
            </summary>
            <param name="missingInclude">The include that is missing.</param>
            <param name="requestingSource">The source that specified the include.</param>
            <param name="line">The line number within the config file.</param>
            <param name="column">The column within the line.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigRootElementInvalid(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a source's root element is invalid.</para>
            <para><b>Message:</b> "Invalid root element [{0}:{1}] in {2}. Expected [{3}:{4}]."</para>
            </summary>
            <param name="uriRootNamespace">The namespace URI of the invalid root node.</param>
            <param name="rootElementName">The root element name of the invalid root node.</param>
            <param name="sourceReference">The description of source with the bad root.</param>
            <param name="uriConfigNamespace">The namespace URI for configuration XML.</param>
            <param name="configElementName">The root element name for configuration XML.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigXmlMalformed(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a source's XML is malformed.</para>
            <para><b>Message:</b> "Malformed XML in {0} (line {1}, column {2}): {3}."</para>
            </summary>
            <param name="sourceReference">The source reference for the malformed xml.</param>
            <param name="line">The line in the source where the error was detected.</param>
            <param name="column">The column in the line where the error was detected.</param>
            <param name="description">A description of the error.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ConfigXmlInvalid(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a source's XML is invalid.</para>
            <para><b>Message:</b> "Invalid XML in {0} (line {1}, column {2}): {3}."</para>
            </summary>
            <param name="sourceReference">A description of the source of the erroneous XML.</param>
            <param name="line">The line in the source where the error was detected.</param>
            <param name="column">The column in the line where the error was detected.</param>
            <param name="description">A description of the error.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.DisposalInvocationIllegal">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Utility.DisposalDelegator"/> when multiple Dispose() calls are made on an 
            instance that disallows them.</para>
            <para><b>Message:</b> "Contrary to the standard IDisposable contract, this object does not allow multiple calls 
            to Dispose()."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.SecurityImpersonationFailed(System.String)">
            <summary>
            <para>Displayed by <see cref="T:Hca.Common.Utility.WindowsSecurity"/> when impersonation fails.</para>
            <para><b>Message:</b> "Unable to impersonate user [{0}]."</para>
            </summary>
            <param name="userName">The name of the user.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.SecurityLogonFailed(System.String,System.String)">
            <summary>
            <para>Displayed by <see cref="T:Hca.Common.Utility.WindowsSecurity"/> when logon fails.</para>
            <para><b>Message:</b> "Unable to logon with user [{0}] in domain [{1}]. Check that the account is set up and enabled."</para>
            </summary>
            <param name="userName">The name of the user.</param>
            <param name="domain">The domain for the user.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderAmbiguousValue(System.String)">
            <summary>
            Used to indicate that stated value is ambigous.
            <para><b>Message:</b> "Unable to assign value with XML [{0}]. A value must be either declared in attribute or element's contents."</para>
            </summary>
            <param name="xmlNodeName">The XML node that the action was acting on.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderAmbiguousKey(System.String)">
            <summary>
            Used to indicate that stated key is ambigous.
            <para><b>Message:</b> "Unable to assign key with XML [{0}]. A key must be either declared in attribute or element's contents."</para>
            </summary>
            <param name="xmlNodeName">The XML node that the action was acting on.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderBuildFailure(System.String)">
            <summary>
            Used to indicate that an XML node caused a build failure.
            <para><b>Message:</b> "There was an error creating object from XML node [{0}]."</para>
            </summary>
            <param name="xmlNodeName">The xml node that was being processed.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderCtorNotFound(System.String)">
            <summary>
            Used to indicate that an XML node's constructor could not be located.
            <para><b>Message:</b> "Could not locate class constructor matching XML node [{0}]."</para>
            </summary>
            <param name="xmlNodeName">The xml node that was being processed.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderCopyPropertyFailure(System.String,System.String)">
            <summary>
            Used to indicate that there was a problem creating object.
            <para><b>Message:</b> "Error creating object and copying to property [{0}] for XML node [{1}]."</para>
            </summary>
            <param name="propertyName">The name of property.</param>
            <param name="xmlNodeName">The xml node that was being processed.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderParseFailure(System.String,System.Type,System.String)">
            <summary>
            Used to indicate that there was a problem creating object.
            <para><b>Message:</b> "Error parsing [{0}] to type [{1}] for XML node [{2}]."</para>
            </summary>
            <param name="valueToParse">The value that was parsed.</param>
            <param name="typeToParse">The type of the value parsed.</param>
            <param name="xmlNode">The XML node.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderPropertyTypeMissingInterface(System.String,System.Type,System.String)">
            <summary>
            <para>Used when a specified property type doesn't implement a required interface.</para>
            <para><b>Message:</b> "The type specified for property [{0}] must implement the [{1}] interface for XML node [{2}]."</para>
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="typeToParse">The type of the value parsed.</param>
            <param name="xmlNode">The XML node.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderPropertyMissing(System.String,System.Type,System.String)">
            <summary>
            <para>Used when no property with the specified name exists on a given type.</para>
            <para><b>Message:</b> "The type [{1}] has no property named [{0}] for XML node [{2}]."</para>
            </summary>
            <param name="propertyName">The name of the property that is missing.</param>
            <param name="typeToParse">The type of the value parsed.</param>
            <param name="xmlNode">The XML node.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ObjectBuilderInvalidArrayAssignment(System.Type,System.Type,System.String)">
            <summary>
            <para>Used when <see cref="T:Hca.Common.Builder.ObjectBuilder"/> cannot assign a given object to a given array element.</para>
            <para><b>Message:</b> "The object type [{0}] is not assignable to an array of type [{1}] for XML node [{2}]."</para>
            </summary>
            <param name="objectType">The type of the object.</param>
            <param name="elementType">The type of the array's elements.</param>
            <param name="xmlNode">The XML node.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TokenFilterTokenAlreadyDefined(System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Builder.TokenFilter"/> when an attempt is made to add a known filter with a name that has already been defined.</para>
            <para><b>Message:</b> "The token name [{0}] has already been assigned a value."</para>
            </summary>
            <param name="tokenName">The name of the token.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.TokenFilterTokenContainsDelimiter(System.Char,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Builder.TokenFilter"/> when a token name has the delimiter character in it.</para>
            <para><b>Message:</b> "The delimiter character [{0}] must not appear in the token name [{1}]."</para>
            </summary>
            <param name="delimiter">The delimiter character.</param>
            <param name="tokenName">The name of the token.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ToStringBuilderInvalidDetailLevel">
            <summary>
            <para>Used when <c>detailLevel</c> in <see cref="T:Hca.Common.Builder.ToStringBuilder"/> is not one of the 
            enumerated values.</para>
            <para><b>Message:</b> "An unexpected detail level was encountered."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ToStringBuilderMemberAccessDenied(System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Builder.ToStringBuilder"/> when access to a particular member is denied.</para>
            <para><b>Message:</b> "Unexpected IllegalAccessException: {0}."</para>
            </summary>
            <param name="excMsg">The message from the underlying exception.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ToStringBuilderInvalidFormat">
            <summary>
            <para>Used when an invalid format string is used in <see cref="T:Hca.Common.Builder.ToStringBuilder"/>.</para>
            <para><b>Message:</b> "Invalid ToStringBuilder format string."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ToStringBuilderInvalidStyle">
            <summary>
            <para>Used when an invalid style is used in <see cref="T:Hca.Common.Builder.ToStringBuilder"/>.</para>
            <para><b>Message:</b> "Invalid ToStringBuilder style specified."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.PropertyNotReadable(System.String)">
            <summary>
            <para>Used to indicate that a property is not readable.</para>
            <para><b>Message:</b> "Property [{0}] is not readable."</para>
            </summary>
            <param name="propertyName">The Name of the property that could not be read.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.PropertyNotWritable(System.String)">
            <summary>
            <para>Used to indicate that a property is not writable.</para>
            <para><b>Message:</b> "Property [{0}] is not writable."</para>
            </summary>
            <param name="propertyName">The Name of the property that could not be written.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ValueTypeAssignedNull">
            <summary>
            <para>This exception is used when the default value supplied is <see langword="null"/> while the type it's supplied for is 
            a value type.</para>
            <para><b>Message:</b> "defaultValue cannot be null for a value type."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ClassNotSerializable">
            <summary>
            <para>This key is used when an object is expected to be serializable but is not.</para>
            <para><b>Message:</b> "This class is not serializable, and this function requires a serializable object."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.AsmNotFromGac(System.Reflection.Assembly)">
            <summary>
            <para>This message is used by <see cref="M:Hca.Common.Utility.SystemUtility.GetGacAssemblyCodeBasePath(System.Reflection.Assembly)"/> when the parameter value isn't a GAC assembly.</para>
            <para>Message: "The provided assembly, [{0}], was not loaded from the Global Assembly Cache."</para>
            </summary>
            <param name="assembly">The (non-GAC) assembly.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.ErrorRegKeyForGacAsm(System.Reflection.Assembly,System.String)">
            <summary>
            <para>This message is used by <see cref="M:Hca.Common.Utility.SystemUtility.GetGacAssemblyCodeBasePath(System.Reflection.Assembly)"/> when there is an exception querying the registry for a GAC assembly's code base.</para>
            <para>Message: "Unexpected exception retrieving a code base directory path for GAC assembly [{0}] from the Windows registry. (A string value was expected at [HKEY_LOCAL_MACHINE\{1}\{0}].)"</para>
            </summary>
            <param name="assembly">The GAC assembly.</param>
            <param name="hklmPath">The HKLM path being queried.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.NoRegKeyForGacAsm(System.Reflection.Assembly,System.String)">
            <summary>
            <para>This message is used by <see cref="M:Hca.Common.Utility.SystemUtility.GetGacAssemblyCodeBasePath(System.Reflection.Assembly)"/> when nothing is found querying the registry for a GAC assembly's code base.</para>
            <para>Message: "The Windows registry does not specify a code base directory path for GAC assembly [{0}]. (A string value was expected at [HKEY_LOCAL_MACHINE\{1}\{0}].)"</para>
            </summary>
            <param name="assembly">The GAC assembly.</param>
            <param name="hklmPath">The HKLM path being queried.</param>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.LoggingConfigurationNotLoaded">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.Logger.HcaLogger"/> when the configuration data cannot be loaded.</para>
            <para><b>Message:</b> "Unable to find logging configuration file, using basic configuration."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalExceptionMessage.CircularTokenReferenceFound(System.String)">
            <summary>
            <para>This message is used by <see cref="T:Hca.Common.Builder.TokenFilter"/> when a token's value references
            an ancestor token.</para>
            <para><b>Message:</b> "A token referenced in the value of token [{0}] references token name [{0}]."</para>
            </summary>
            <param name="tokenName">The token identified as an ancestor.</param>
        </member>
        <member name="T:Hca.Common.InternalMessage">
            <summary>
            This class defines internal messages from 
            a resource bundle. 
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionConfigurationInformationNotDefined">
            <summary>
            <para>Exception configuration information could not be located.</para>
            <para><b>Message:</b> "Exception configuration information was not defined, defaulting values with context name of [exception]."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionStackTrace(System.String)">
            <summary>
            <para>Used when dumping a stacktrace.</para>
            <para><b>Message:</b> "Exception StackTrace: {0}"</para>
            </summary>
            <param name="exceptionStackTrace">the stack trace</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.CausedByInnerException(System.String)">
            <summary>
            <para>Used when dumping an inner exception on a stacktrace.</para>
            <para><b>Message:</b> "Caused By: {0}"</para>
            </summary>
            <param name="innerExceptionStackTrace">the inner exception stacktrace</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.UserPrincipalFromThread(System.String,System.String)">
            <summary>
            <para>Used when outputting the user principal information from the thread.</para>
            <para><b>Message:</b> "User Principal as known to current thread:[{0}]{1}"</para>
            </summary>
            <param name="threadIdentity">user thread identity</param>
            <param name="newlineCharacter">newline character</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.UserPrincipalFromWindows(System.String,System.String)">
            <summary>
            <para>Used when outputting the user principal information from windows.</para>
            <para><b>Message:</b> "User Principal as known to windows subsystem:[{0}]{1}"</para>
            </summary>
            <param name="windowsIdentity">user windows identity</param>
            <param name="newlineCharacter">newline character</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.CausedByInnerExceptionWithMessage(System.Type,System.String,System.String)">
            <summary>
            <para>Used when an inner exception message is output.</para>
            <para><b>Message:</b> "Caused By: [{0}] with Message [{1}]{2}"</para>
            </summary>
            <param name="innerExceptionType">the type of the inner exception</param>
            <param name="innerExceptionMessage">the inner exception message</param>
            <param name="newlineCharacter">newline character</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnableToLoadMachineName">
            <summary>
            <para>Used in <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> when the machine name message cannot be acquired.</para>
            <para><b>Message:</b> "Unable to load machine name due to exception =&gt; "</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnableToLoadThreadPrincipal">
            <summary>
            <para>Used when the thread principal resource message cannot be acquired.</para>
            <para><b>Message:</b> "Unable to load Thread Principal due to exception => "</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnableToLoadWindowsPrincipal">
            <summary>
            <para>Used when the windows principal resource message cannot be acquired.</para>
            <para><b>Message:</b> "Unable to load Windows Principal due to exception => "</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnableToLoadApplicationDomain">
            <summary>
            <para>Used when the app domain resource message cannot be acquired.</para>
            <para><b>Message:</b> "Unable to load App Domain due to exception => "</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.StackTraceOnNewline(System.String,System.String)">
            <summary>
            <para>Used to output the stacktrace on a new line.</para>
            <para><b>Message:</b> "&lt;StackTrace:&gt;{0}{1}"</para>
            </summary>
            <param name="newlineCharacter">newline character</param>
            <param name="exceptionStackTrace">the stacktrace</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionTerseOutputId(System.Type,System.String,System.Reflection.MethodBase,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> when generating the terse output.</para>
            <para><b>Message:</b> "{3}{0} with Id[{1}] thrown in Target [{2}]"</para>
            </summary>
            <param name="typeThrown">full name of the type</param>
            <param name="exceptionId">the id of the exception</param>
            <param name="method">the method where the exception occurred</param>
            <param name="newlineCharacter">newline</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionTerseOutputAssembly(System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> when generating the terse output.</para>
            <para><b>Message:</b> " in class [{0}]"</para>
            </summary>
            <param name="applicationAssembly">The application assembly that caused the exception</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionTerseOutputMessage(System.String,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.BaseException.HcaApplicationException"/> when generating the terse output.</para>
            <para><b>Message:</b> "{1}Message:[{0}]{1}"</para>
            </summary>
            <param name="exceptionMessage">the message of the exception</param>
            <param name="newlineCharacter">newline character</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ExceptionAdditionalDetail(System.String,System.String)">
            <summary>
            Used to generate exception message with supplemental output.
            <para><b>Message:</b> "{0}&lt;Additional Detail:&gt; {1}"</para>
            </summary>
            <param name="innerExceptionMessage">The inner exception ToString() message.</param>
            <param name="supplementalMessage">The supplemental message details.</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.MessageResourceDescription(System.String,System.String)">
            <summary>
            Used to display where a resource was loaded from.
            <para><b>Message:</b> "message string resource [{0}] from [{1}]"</para>
            </summary>
            <param name="resourceName">The name of the resource item</param>
            <param name="resource">The name of the resource</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.TestMessage">
            <summary>
            <para>Message used to test the InternalResourceManager class.</para>
            <para><b>Message:</b> "This is a test message."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.TestMessage(System.String,System.String)">
            <summary>
            <para>Message with formattable arguments used to test the <see cref="T:Hca.Common.Message.ResourceMessage"/> class.</para>
            <para><b>Message:</b> "This is a test message with formattable arguments: [{0}], [{1}]."</para>
            </summary>
            <param name="formatArg1">first argument</param>
            <param name="formatArg2">second argument</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.CycleIndicator">
            <summary>
            <para>Used in <c>ToStringStyle</c> when recursing objects.</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.SizeStartTag">
            <summary>
            <para>Used in <c>ToStringStyle</c> when setting the start text when outputting 
            a collection, map or array size.</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.NullTag">
            <summary>
            <para>Used in <c>ToStringStyle</c> when displaying <c>null</c> as text.</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.LengthTooLong(System.Int32)">
            <summary>
            <para>Used in <c>ToStringStyle</c> when an array contains more 
            than 1000 items.</para>
            <para><b>Message:</b> "Length={0} TOO LONG"</para>
            </summary>
            <param name="actualLength">the actual length of the array</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigurationFileDescription(System.String)">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.Store.Xml.FileConfigSource"/>.</para>
            <para><b>Message:</b> "configuration file [{0}]"</para>
            </summary>
            <param name="absolutePath">The absolute path of the configuration file</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigPrimarySpecifiedInAppSettings(System.String,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a primary configuration file is specified in .NET's <see cref="P:System.Configuration.ConfigurationSettings.AppSettings"/>.</para>
            <para><b>Message:</b> "AppSetting [{0}] in .NET's configuration specifies [{1}] as the primary configuration file."</para>
            </summary>
            <param name="dataKey">The <see cref="P:System.Configuration.ConfigurationSettings.AppSettings"/> key specifying <paramref name="fileName"/>.</param>
            <param name="fileName">The specified file name.</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigPrimarySpecifiedInAppDomain(System.String,System.String)">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when a primary configuration file is specified in the <see cref="T:System.AppDomain"/>.</para>
            <para><b>Message:</b> "AppDomain data element [{0}] specifies [{1}] as the primary configuration file."</para>
            </summary>
            <param name="dataKey">The <see cref="T:System.AppDomain"/> data key specifying <paramref name="fileName"/>.</param>
            <param name="fileName">The specified file name.</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigPrimaryOverriding">
            <summary>
            <para>Used in <see cref="T:Hca.Common.Configuration.ConfigFactory"/> when the .NET ConfigFactory section is being ignored in favor of a specified primary configuration file .</para>
            <para><b>Message:</b> "Bypassing ConfigFactory section in .NET's configuration file in favor of specified primary configuration file."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.NoPrimaryConfigurationFound">
            <summary>
            <para>No configuration store was found.</para>
            <para><b>Message:</b> "No Common configuration was found in .NET's configuration file."</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.EncryptedConfigurationFileDescription(System.String)">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.Store.Xml.EncryptedFileConfigSource"/>.</para>
            <para><b>Message:</b> "encrypted configuration file [{0}]"</para>
            </summary>
            <param name="absolutePath">The absolute path of the configuration file</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigurationFileFromAssemblyDescription(System.String,System.String)">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.Store.Xml.AsmResourceConfigSource"/>.</para>
            <para><b>Message:</b> "configuration file resource [{0}] from assembly [{1}]"</para>
            </summary>
            <param name="resourceName">The resource name</param>
            <param name="assemblyName">The assembly name</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ConfigurationFactorySectionDescription">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.Store.Xml.AppConfigSource"/>.</para>
            <para><b>Message:</b> "ConfigFactory's section inside .NET's configuration file"</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.AssemblyConfigurationDescription(System.String)">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.AssemblyConfigurationFileAttribute"/>.</para>
            <para><b>Message:</b> "AssemblyConfigurationFile attribute on assembly [{0}]"</para>
            </summary>
            <param name="assemblyName">The assembly name</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.ApplicationDomainAssemblies">
            <summary>
            <para>Sentence fragment that describes an <see cref="T:Hca.Common.Configuration.Store.Xml.AttributedAssembliesConfigSource"/>.</para>
            <para><b>Message:</b> "application domain attributed assemblies"</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.LocationInConfigurationSource(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Sentence fragment that describes a location within an XML configuration source.</para>
            <para><b>Message:</b> "{0}: line {1}, column {2}"</para>
            </summary>
            <param name="sourceDescription">A description of the source of the XML</param>
            <param name="sourceLine">The line in the source where this definition appears</param>
            <param name="sourceColumn">The column in the line where this definition appears</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.HandleNameOfDisposal(System.String)">
            <summary>
            <para>Sentence fragment that describes a DisposalHelper hold handle for a given client.</para>
            <para><b>Message:</b> "DisposalHelper hold handle on object named [{0}]"</para>
            </summary>
            <param name="handleName">The name of the DisposalHelper's client object</param>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnknownValue">
            <summary>
            <para>Sentence fragment that represents an unknown value.</para>
            <para><b>Message:</b> "*Unknown"</para>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.UnspecifiedValue">
            <summary>
            <p>Fragment for indicating that some value is unspecified.</p>
            <p><b>Message:</b>"Unspecified"</p>
            </summary>
        </member>
        <member name="M:Hca.Common.InternalMessage.AndArguments(System.String,System.String,System.String[])">
            <summary>
            <p>Fragment that will concatenate 2 or more string values to form an "and" statement
            <b>Message:</b>{0} and {1}[ and {n}] where the additional ands are added if present upto
            the number of arguments passed.</p>
            </summary>
            <param name="arg1">The first argument</param>
            <param name="arg2">The second argument</param>
            <param name="additionalArgs">one or more additional arguments</param>
            <returns></returns>
        </member>
        <member name="F:Hca.Common.Message.FormattedMessage.log">
            <summary>Logger for the class</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.MESSAGES_BASE_NAME">
            <summary>Holds the baseName of Common's default  message resource file.</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.EXCEPTION_MESSAGES_BASE_NAME">
            <summary>Holds the baseName of Common's default exception message resource file.</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.log">
            <summary>Logger for the class</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.messagesSyncRoot">
            <summary>Used to synchronize just-in-time population of <see cref="F:Hca.Common.Message.ResourceMessage.messageResourceManager"/>.</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.exceptionMessagesSyncRoot">
            <summary>Used to synchronize just-in-time population of <see cref="F:Hca.Common.Message.ResourceMessage.exceptionMessageResourceManager"/>.</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.messageResourceManager">
            <summary>Holds the <see cref="T:System.Resources.ResourceManager"/> for Common's default message resource file.</summary>
        </member>
        <member name="F:Hca.Common.Message.ResourceMessage.exceptionMessageResourceManager">
            <summary>Holds the <see cref="T:System.Resources.ResourceManager"/> for Common's default exception message resource file.</summary>
        </member>
        <member name="P:Hca.Common.Message.ResourceMessage.MessageResourceManager">
            <summary>Gets the <see cref="T:System.Resources.ResourceManager"/> for Common's default message resource file.</summary>
        </member>
        <member name="P:Hca.Common.Message.ResourceMessage.ExceptionMessageResourceManager">
            <summary>Gets the <see cref="T:System.Resources.ResourceManager"/> for Common's default exception message resource file.</summary>
        </member>
        <member name="T:Hca.Common.NamespaceDoc">
            <summary>
            	<h2 class="dtH2">Objectives</h2>
            	This document explains the use of the Common framework classes. <see cref="N:Hca.Common"/> is a class 
            	library that contains base classes, utility classes, small frameworks, and more. Together it represents 
            	a set of patterns and ideas. Some ideas build upon each other in the framework. <see cref="N:Hca.Common"/> 
            	provides answers to the following:
            	<list type="bullet">
            		<item>Logging</item>
            		<item>Storing and obtaining application configuration information</item>
            		<item>Defining and obtaining resources</item>
            		<item>Defining and handling exceptions</item>
            		<item>Defining and obtaining services</item>
            		<item>Base class for transfer objects</item>
            		<item>New data types like nullable value types</item>
            	</list>
            	
            	<h2 class="dtH2">Scope</h2>
            	This document provides best practices and illustrative examples to show the intent of use of the various 
            	parts of the framework. The document is broken into two general areas, deployment of the framework within 
            	a project and a series of usage guides that talk about each part of the framework. This document is 
            	subject to change as new releases of the framework are released. Please refer to the document history 
            	section for details on these releases. 
            	
            	<h2 class="dtH2">Audience</h2>
            	Developers are the prime audience for this document. However, technical testing and code review personnel 
            	may find this document useful to understand the appropriate use of the <see cref="N:Hca.Common"/> classes.
            	
            	<h2 class="dtH2">References</h2>
            	The following works are referenced in this SDK:
            	<para/>
            	<i>Table 1: Referenced Works</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Label</th>
            				<th width="50%">Title</th>
            				<th width="30%">Reference</th>
            			</tr>
            			<tr>
            				<td>NAnt</td>
            				<td>NAnt build tool</td>
            				<td><see href="http://sf.net/projects/nant"/></td>
            			</tr>
            			<tr>
            				<td>Ant</td>
            				<td>Ant build tool</td>
            				<td><see href="http://ant.apache.org"/></td>
            			</tr>
            		</table>
            	</div>
            
            	<h2 class="dtH2">Design</h2>
            	<see cref="N:Hca.Common"/> is analogous to .NET's <see cref="N:System"/> namespace as all of HCA's reusable 
            	framework and applications extend from <see cref="N:Hca.Common"/> to some degree. <see cref="N:Hca.Common"/> 
            	packages key concepts like logging, exception handling, configuration creation, object identification, etc. 
            	Unlike .NET's <see cref="N:System"/> namespace, <see cref="N:Hca.Common"/> does not throw all its classes into 
            	one namespace. 
            	<hcaNote>
            		.NET's <see cref="N:System"/> namespace includes over 130 classes in one namespace.
            	</hcaNote>
            	
            	It partitions them into logical concepts like <see cref="N:Hca.Common.Logger"/>, 
            	<see cref="N:Hca.Common.Configuration"/>, <see cref="N:Hca.Common.Utility"/>, <see cref="N:Hca.Common.NullableValueType"/>, 
            	<see cref="N:Hca.Common.Resource"/>, etc. These partitions ensure that the class does not become entangled 
            	or blurred with another concept. In addition, circular dependency between namespaces is avoided. This 
            	prevents coupling of classes and possible introduction of hard to find bugs as well as making future 
            	refactoring difficult. Figure 1 details <see cref="N:Hca.Common"/>'s current namespace hierarchy. This diagram 
            	illustrates what each namespace is allowed to depend on, not how each namespace does depend on each other. 
            	For example, <see cref="N:Hca.Common.Logger"/> cannot depend on any other namespace and <see cref="N:Hca.Common.DataType"/> 
            	can use any namespace.
            	<para/>
            	<img src="common_namespace_hierarchy.gif"/>
            	<br/>
            	<i>Figure 1: Namespace Hierarchy</i>
            	
            	<h2 class="dtH2">Build and Deployment</h2>
            	
            	<h3 class="dtH3">Project Build Process Using NAnt</h3>
            	<i>NAnt</i> is a build process ported from <i>Ant</i>. <i>NAnt</i> is used to build and package <see cref="N:Hca.Common"/>. 
            	This section is intended for people that are developing <see cref="N:Hca.Common"/>.
            	<para/>
            	<i>DevPack</i> should be installed first. This ensures that the latest <i>NAnt</i> is installed with proper path 
            	settings. There is a build file supplied under the src folder of <see cref="N:Hca.Common"/>. Within <i>Visual Studio</i>, 
            	right-click the build file and execute the desired target.
            	
            	<h3 class="dtH3">Placement of Common DLL and Configuration File</h3>
            	<see cref="N:Hca.Common"/> and its dependencies should be installed with its install package, <i>DevBlocksCommon - #.#.#.#.msi</i>. 
            	The install package places the assemblies in the GAC for compatibility with COM+. The configuration files for 
            	<see cref="N:Hca.Common.Configuration"/> and <b>log4net</b> may be placed in the application domain's base directory 
            	or specified in the application's configuration file. See <see cref="N:Hca.Common.Configuration"/> and <see cref="N:Hca.Common.Logger"/> 
            	for more details.
            	
            	The <see cref="N:Hca.Common"/> install package will install the following in <see cref="N:Hca.Common"/>'s install directory:
            	<para/>
            	<i>Table 2: Package Contents</i>
            	<br/>
            	<div class="tablediv">
            		<table class="dtTABLE" cellspacing="0" width="100%">
            			<tr valign="top">
            				<th width="20%">Location</th>
            				<th width="30%">Title</th>
            				<th width="50%">Description</th>
            			</tr>
            			<tr>
            				<td>bin</td>
            				<td>Release Files</td>
            				<td>
            					This folder includes the DLL release, its dependencies, and debug symbols. Correlating with the DLL's 
            					are XML files that provide intellisense help. An <c>ObjectBuilderTest.config</c> file is also provided 
            					as reference on how to write config objects in XML. 
            				</td>
            			</tr>
            			<tr>
            				<td>doc</td>
            				<td>Documentation Folder</td>
            				<td>
            					This folder includes the API help file for <see cref="N:Hca.Common"/> and <i>log4net</i>. It also includes a 
            					release.txt file showing the issues resolved for each release. This usage guide is here as well. 
            				</td>
            			</tr>
            			<tr>
            				<td>src</td>
            				<td>Source Files</td>
            				<td>
            					This folder includes the source files released in <see cref="N:Hca.Common"/> along with the unit test files 
            					that are not included in the release DLL.
            				</td>
            			</tr>
            		</table>
            	</div>
            	
            	<h3 class="dtH3">Debugging Common</h3>
            	<see cref="N:Hca.Common"/>'s debug symbols are installed with <see cref="N:Hca.Common"/>'s assembly. This file is the 
            	same name as the DLL but ends with a PDB extension. You need to add a reference to <see cref="N:Hca.Common"/>'s bin 
            	directory in your solution's properties under <i>Debug Symbol Files</i>. It is also necessary to add a reference to 
            	<see cref="N:Hca.Common"/>'s <i>src</i> directory in your solution's properties under <i>Debug Source Files</i>. This 
            	allows you to open a <see cref="N:Hca.Common"/> source file that is called by the code and place a break point in it. 
            	You can then run in debug mode and the IDE will load <see cref="N:Hca.Common"/>'s debug symbols and interpret your 
            	breakpoint properly.
            	
            	<h3 class="dtH3">Usage within ASP.NET Applications</h3>
            	In general, <see cref="N:Hca.Common"/>'s usage patterns of Web-based applications are no different than any other type 
            	of application. For Web applications, one exception is that the default location of the DevBlocks configuration files 
            	(logging.config) is the application base directory and not the directory where the main assembly resides (typically 
            	the bin directory). This behavior is consistent with the way that the .NET framework handles the <c>web.config</c> file. If 
            	<see cref="N:Hca.Common"/> is used in an ASPX page, it is necessary to add a <c>@ Assembly</c> directive in the page. For example: 
            	<hcaExample>
            	<code>
            <![CDATA[<%@ Assembly Name="HcaDevBlocksCommon, Version=1.3.0.1, Culture=neutral, PublicKeyToken=fd260fd4a2a56402" %>]]>
            </code>
            	Where X.X is the current version of Common. 
            	</hcaExample>
            	
            	<h3 class="dtH3">Considerations of use with Existing Projects</h3>
            	This section describes possible uses for <see cref="N:Hca.Common"/> in an existing project. For instance, a product 
            	might be receiving a feature upgrade and the decision is made to incorporate <see cref="N:Hca.Common"/> into this 
            	product. What areas of <see cref="N:Hca.Common"/> should be considered for incorporation?
            	
            	<h4 class="dtH4">Must Consider</h4>
            	Items or features of <see cref="N:Hca.Common"/> that should be incorporated into an existing product or project include:
            	<list type="bullet">
            		<item>
            			Refactor application exceptions to extend from <see cref="T:Hca.Common.BaseException.HcaApplicationException"/>. 
            			This allows the application to be modified to use <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>.
            		</item>
            		<item>
            			<see cref="T:Hca.Common.BaseException.ExceptionHandler"/> should handle caught exceptions. This allows the 
            			application to benefit from <see cref="T:Hca.Common.BaseException.ExceptionHandler"/>'s rich capabilities of 
            			handling both native and HCA specific exceptions and provide consistent logging of these exceptions.
            		</item>
            		<item>
            			Public methods for services should be wrapped in a <c>try/catch</c> using <see cref="T:Hca.Common.BaseException.ExceptionHandler"/> 
            			to handle the exception.
            		</item>
            		<item>
            			All diagnostic calls should be replaced with <see cref="T:Hca.Common.Logger.HcaLogger"/>. This will abstract out 
            			diagnostic information so it and the output sinks can be modified as needed.
            		</item>
            		<item>
            			All user messages should be placed in resource files and obtained through <see cref="T:System.Resources.ResourceManager"/>.
            		</item>
            	</list>
            	
            	<h4 class="dtH4">Might Consider</h4>
            	Items or features that should be considered for incorporation into an existing product or project include:
            	<list type="bullet">
            		<item>
            			If the application is not currently a service-oriented design, then this design approach might be considered. 
            			Service-oriented architecture provides coarse grain functionality reuse that is very beneficial. When services 
            			are used or any major functionality is incorporated into an interface design, then <c>ServiceFactory</c> should 
            			be used to abstract the service's creation.
            		</item>
            		<item>
            			If the application incorporates a domain model, <see cref="T:Hca.Common.BaseType.ValueObjectBase"/> should be 
            			considered as the base object for transfer objects.
            		</item>
            	</list>
            </summary>
        </member>
        <member name="T:Hca.Common.RequiredAttribute">
            <summary>
            Used to indicate that a field should not contain <see langword="null" />.
            </summary>
            <remarks>
            This attribute is intended to be used in validation calls. Based on the validation (e.g. config or value object 
            validations) you may need to call a base method to perform this check. If a field is not set and it is required, 
            an exception is thrown.
            </remarks>
        </member>
        <member name="M:Hca.Common.RequiredAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
    </members>
</doc>
